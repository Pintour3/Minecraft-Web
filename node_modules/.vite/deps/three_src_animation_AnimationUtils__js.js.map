{
  "version": 3,
  "sources": ["../../three/src/animation/AnimationUtils.js"],
  "sourcesContent": ["import { Quaternion } from '../math/Quaternion.js';\nimport { AdditiveAnimationBlendMode } from '../constants.js';\n\n/**\n * Converts an array to a specific type.\n *\n * @param {TypedArray|Array} array - The array to convert.\n * @param {TypedArray.constructor} type - The constructor of a typed array that defines the new type.\n * @return {TypedArray} The converted array.\n */\nfunction convertArray( array, type ) {\n\n\tif ( ! array || array.constructor === type ) return array;\n\n\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\treturn new type( array ); // create typed array\n\n\t}\n\n\treturn Array.prototype.slice.call( array ); // create Array\n\n}\n\n/**\n * Returns `true` if the given object is a typed array.\n *\n * @param {any} object - The object to check.\n * @return {boolean} Whether the given object is a typed array.\n */\nfunction isTypedArray( object ) {\n\n\treturn ArrayBuffer.isView( object ) && ! ( object instanceof DataView );\n\n}\n\n/**\n * Returns an array by which times and values can be sorted.\n *\n * @param {Array<number>} times - The keyframe time values.\n * @return {Array<number>} The array.\n */\nfunction getKeyframeOrder( times ) {\n\n\tfunction compareTime( i, j ) {\n\n\t\treturn times[ i ] - times[ j ];\n\n\t}\n\n\tconst n = times.length;\n\tconst result = new Array( n );\n\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\tresult.sort( compareTime );\n\n\treturn result;\n\n}\n\n/**\n * Sorts the given array by the previously computed order via `getKeyframeOrder()`.\n *\n * @param {Array<number>} values - The values to sort.\n * @param {number} stride - The stride.\n * @param {Array<number>} order - The sort order.\n * @return {Array<number>} The sorted values.\n */\nfunction sortedArray( values, stride, order ) {\n\n\tconst nValues = values.length;\n\tconst result = new values.constructor( nValues );\n\n\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\tconst srcOffset = order[ i ] * stride;\n\n\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * Used for parsing AOS keyframe formats.\n *\n * @param {Array<number>} jsonKeys - A list of JSON keyframes.\n * @param {Array<number>} times - This array will be filled with keyframe times by this function.\n * @param {Array<number>} values - This array will be filled with keyframe values by this function.\n * @param {string} valuePropertyName - The name of the property to use.\n */\nfunction flattenJSON( jsonKeys, times, values, valuePropertyName ) {\n\n\tlet i = 1, key = jsonKeys[ 0 ];\n\n\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\tkey = jsonKeys[ i ++ ];\n\n\t}\n\n\tif ( key === undefined ) return; // no data\n\n\tlet value = key[ valuePropertyName ];\n\tif ( value === undefined ) return; // no data\n\n\tif ( Array.isArray( value ) ) {\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push( ...value ); // push all elements\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else if ( value.toArray !== undefined ) {\n\n\t\t// ...assume THREE.Math-ish\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else {\n\n\t\t// otherwise push as-is\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push( value );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t}\n\n}\n\n/**\n * Creates a new clip, containing only the segment of the original clip between the given frames.\n *\n * @param {AnimationClip} sourceClip - The values to sort.\n * @param {string} name - The name of the clip.\n * @param {number} startFrame - The start frame.\n * @param {number} endFrame - The end frame.\n * @param {number} [fps=30] - The FPS.\n * @return {AnimationClip} The new sub clip.\n */\nfunction subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\tconst clip = sourceClip.clone();\n\n\tclip.name = name;\n\n\tconst tracks = [];\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tconst track = clip.tracks[ i ];\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = [];\n\t\tconst values = [];\n\n\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( times.length === 0 ) continue;\n\n\t\ttrack.times = convertArray( times, track.times.constructor );\n\t\ttrack.values = convertArray( values, track.values.constructor );\n\n\t\ttracks.push( track );\n\n\t}\n\n\tclip.tracks = tracks;\n\n\t// find minimum .times value across all tracks in the trimmed clip\n\n\tlet minStartTime = Infinity;\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t}\n\n\t}\n\n\t// shift all tracks such that clip begins at t=0\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t}\n\n\tclip.resetDuration();\n\n\treturn clip;\n\n}\n\n/**\n * Converts the keyframes of the given animation clip to an additive format.\n *\n * @param {AnimationClip} targetClip - The clip to make additive.\n * @param {number} [referenceFrame=0] - The reference frame.\n * @param {AnimationClip} [referenceClip=targetClip] - The reference clip.\n * @param {number} [fps=30] - The FPS.\n * @return {AnimationClip} The updated clip which is now additive.\n */\nfunction makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\tif ( fps <= 0 ) fps = 30;\n\n\tconst numTracks = referenceClip.tracks.length;\n\tconst referenceTime = referenceFrame / fps;\n\n\t// Make each track's values relative to the values at the reference frame\n\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t// Skip this track if it's non-numeric\n\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t} );\n\n\t\tif ( targetTrack === undefined ) continue;\n\n\t\tlet referenceOffset = 0;\n\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\treferenceOffset = referenceValueSize / 3;\n\n\t\t}\n\n\t\tlet targetOffset = 0;\n\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\ttargetOffset = targetValueSize / 3;\n\n\t\t}\n\n\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\tlet referenceValue;\n\n\t\t// Find the value to subtract out of the track\n\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else {\n\n\t\t\t// Interpolate to the reference value\n\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\treferenceValue = interpolant.resultBuffer.slice( startIndex, endIndex );\n\n\t\t}\n\n\t\t// Conjugate the quaternion\n\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\n\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t}\n\n\t\t// Subtract the reference value from all of the track values\n\n\t\tconst numTimes = targetTrack.times.length;\n\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart,\n\t\t\t\t\treferenceValue,\n\t\t\t\t\t0,\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\n\n\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\n\n\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\treturn targetClip;\n\n}\n\n/**\n * A class with various methods to assist with animations.\n *\n * @hideconstructor\n */\nclass AnimationUtils {\n\n\t/**\n\t * Converts an array to a specific type\n\t *\n\t * @static\n\t * @param {TypedArray|Array} array - The array to convert.\n\t * @param {TypedArray.constructor} type - The constructor of a type array.\n\t * @return {TypedArray} The converted array\n\t */\n\tstatic convertArray( array, type ) {\n\n\t\treturn convertArray( array, type );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given object is a typed array.\n\t *\n\t * @static\n\t * @param {any} object - The object to check.\n\t * @return {boolean} Whether the given object is a typed array.\n\t */\n\tstatic isTypedArray( object ) {\n\n\t\treturn isTypedArray( object );\n\n\t}\n\n\t/**\n\t * Returns an array by which times and values can be sorted.\n\t *\n\t * @static\n\t * @param {Array<number>} times - The keyframe time values.\n\t * @return {Array<number>} The array.\n\t */\n\tstatic getKeyframeOrder( times ) {\n\n\t\treturn getKeyframeOrder( times );\n\n\t}\n\n\t/**\n\t * Sorts the given array by the previously computed order via `getKeyframeOrder()`.\n\t *\n\t * @static\n\t * @param {Array<number>} values - The values to sort.\n\t * @param {number} stride - The stride.\n\t * @param {Array<number>} order - The sort order.\n\t * @return {Array<number>} The sorted values.\n\t */\n\tstatic sortedArray( values, stride, order ) {\n\n\t\treturn sortedArray( values, stride, order );\n\n\t}\n\n\t/**\n\t * Used for parsing AOS keyframe formats.\n\t *\n\t * @static\n\t * @param {Array<number>} jsonKeys - A list of JSON keyframes.\n\t * @param {Array<number>} times - This array will be filled with keyframe times by this method.\n\t * @param {Array<number>} values - This array will be filled with keyframe values by this method.\n\t * @param {string} valuePropertyName - The name of the property to use.\n\t */\n\tstatic flattenJSON( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tflattenJSON( jsonKeys, times, values, valuePropertyName );\n\n\t}\n\n\t/**\n\t * Creates a new clip, containing only the segment of the original clip between the given frames.\n\t *\n\t * @static\n\t * @param {AnimationClip} sourceClip - The values to sort.\n\t * @param {string} name - The name of the clip.\n\t * @param {number} startFrame - The start frame.\n\t * @param {number} endFrame - The end frame.\n\t * @param {number} [fps=30] - The FPS.\n\t * @return {AnimationClip} The new sub clip.\n\t */\n\tstatic subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\t\treturn subclip( sourceClip, name, startFrame, endFrame, fps );\n\n\t}\n\n\t/**\n\t * Converts the keyframes of the given animation clip to an additive format.\n\t *\n\t * @static\n\t * @param {AnimationClip} targetClip - The clip to make additive.\n\t * @param {number} [referenceFrame=0] - The reference frame.\n\t * @param {AnimationClip} [referenceClip=targetClip] - The reference clip.\n\t * @param {number} [fps=30] - The FPS.\n\t * @return {AnimationClip} The updated clip which is now additive.\n\t */\n\tstatic makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\t\treturn makeClipAdditive( targetClip, referenceFrame, referenceClip, fps );\n\n\t}\n\n}\n\nexport {\n\tconvertArray,\n\tisTypedArray,\n\tgetKeyframeOrder,\n\tsortedArray,\n\tflattenJSON,\n\tsubclip,\n\tmakeClipAdditive,\n\tAnimationUtils\n};\n"],
  "mappings": "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",
  "names": []
}
