{
  "version": 3,
  "sources": ["../../three/src/nodes/core/constants.js", "../../three/src/math/Matrix3.js", "../../three/src/utils.js", "../../three/src/math/ColorManagement.js", "../../three/src/math/Color.js", "../../three/src/math/Matrix2.js", "../../three/src/math/Vector3.js", "../../three/src/math/Matrix4.js", "../../three/src/math/Vector2.js", "../../three/src/math/Vector4.js", "../../three/src/nodes/core/NodeUtils.js", "../../three/src/core/EventDispatcher.js", "../../three/src/nodes/core/Node.js", "../../three/src/nodes/core/TempNode.js", "../../three/src/nodes/core/InputNode.js", "../../three/src/nodes/core/UniformGroupNode.js", "../../three/src/nodes/utils/ArrayElementNode.js", "../../three/src/nodes/utils/ConvertNode.js", "../../three/src/nodes/utils/JoinNode.js", "../../three/src/nodes/utils/SplitNode.js", "../../three/src/nodes/utils/SetNode.js", "../../three/src/nodes/utils/FlipNode.js", "../../three/src/nodes/core/ConstNode.js", "../../three/src/nodes/utils/MemberNode.js", "../../three/src/nodes/tsl/TSLCore.js", "../../three/src/nodes/core/UniformNode.js", "../../three/src/nodes/core/ArrayNode.js", "../../three/src/nodes/core/PropertyNode.js", "../../three/src/nodes/core/AssignNode.js", "../../three/src/nodes/code/FunctionCallNode.js", "../../three/src/nodes/math/OperatorNode.js", "../../three/src/nodes/math/MathNode.js", "../../three/src/nodes/math/ConditionalNode.js", "../../three/src/nodes/core/ContextNode.js", "../../three/src/nodes/core/VarNode.js", "../../three/src/nodes/core/SubBuildNode.js", "../../three/src/nodes/core/VaryingNode.js", "../../three/src/nodes/display/ColorSpaceFunctions.js", "../../three/src/nodes/display/ColorSpaceNode.js", "../../three/src/nodes/accessors/ReferenceBaseNode.js", "../../three/src/nodes/accessors/RendererReferenceNode.js", "../../three/src/nodes/display/ToneMappingNode.js", "../../three/src/extras/DataUtils.js", "../../three/src/core/BufferAttribute.js", "../../three/src/core/InterleavedBufferAttribute.js", "../../three/src/core/InterleavedBuffer.js", "../../three/src/nodes/accessors/BufferAttributeNode.js", "../../three/src/nodes/gpgpu/ComputeNode.js", "../../three/src/nodes/core/CacheNode.js", "../../three/src/nodes/core/BypassNode.js", "../../three/src/nodes/utils/RemapNode.js", "../../three/src/nodes/code/ExpressionNode.js", "../../three/src/nodes/utils/Discard.js", "../../three/src/nodes/display/RenderOutputNode.js", "../../three/src/nodes/utils/DebugNode.js", "../../three/src/math/Box3.js", "../../three/src/math/Sphere.js", "../../three/src/nodes/accessors/Object3DNode.js", "../../three/src/nodes/accessors/BufferNode.js", "../../three/src/nodes/accessors/UniformArrayNode.js", "../../three/src/nodes/accessors/BuiltinNode.js", "../../three/src/nodes/display/ScreenNode.js", "../../three/src/nodes/accessors/Camera.js", "../../three/src/nodes/accessors/ModelNode.js", "../../three/src/nodes/core/AttributeNode.js", "../../three/src/nodes/accessors/Position.js", "../../three/src/nodes/accessors/VelocityNode.js"],
  "sourcesContent": ["/**\n * Possible shader stages.\n *\n * @property {string} VERTEX The vertex shader stage.\n * @property {string} FRAGMENT The fragment shader stage.\n */\nexport const NodeShaderStage = {\n\tVERTEX: 'vertex',\n\tFRAGMENT: 'fragment'\n};\n\n/**\n * Update types of a node.\n *\n * @property {string} NONE The update method is not executed.\n * @property {string} FRAME The update method is executed per frame.\n * @property {string} RENDER The update method is executed per render. A frame might be produced by multiple render calls so this value allows more detailed updates than FRAME.\n * @property {string} OBJECT The update method is executed per {@link Object3D} that uses the node for rendering.\n */\nexport const NodeUpdateType = {\n\tNONE: 'none',\n\tFRAME: 'frame',\n\tRENDER: 'render',\n\tOBJECT: 'object'\n};\n\n/**\n * Data types of a node.\n *\n * @property {string} BOOLEAN Boolean type.\n * @property {string} INTEGER Integer type.\n * @property {string} FLOAT Float type.\n * @property {string} VECTOR2 Two-dimensional vector type.\n * @property {string} VECTOR3 Three-dimensional vector type.\n * @property {string} VECTOR4 Four-dimensional vector type.\n * @property {string} MATRIX2 2x2 matrix type.\n * @property {string} MATRIX3 3x3 matrix type.\n * @property {string} MATRIX4 4x4 matrix type.\n */\nexport const NodeType = {\n\tBOOLEAN: 'bool',\n\tINTEGER: 'int',\n\tFLOAT: 'float',\n\tVECTOR2: 'vec2',\n\tVECTOR3: 'vec3',\n\tVECTOR4: 'vec4',\n\tMATRIX2: 'mat2',\n\tMATRIX3: 'mat3',\n\tMATRIX4: 'mat4'\n};\n\n/**\n * Access types of a node. These are relevant for compute and storage usage.\n *\n * @property {string} READ_ONLY Read-only access\n * @property {string} WRITE_ONLY Write-only access.\n * @property {string} READ_WRITE Read and write access.\n */\nexport const NodeAccess = {\n\tREAD_ONLY: 'readOnly',\n\tWRITE_ONLY: 'writeOnly',\n\tREAD_WRITE: 'readWrite',\n};\n\nexport const defaultShaderStages = [ 'fragment', 'vertex' ];\nexport const defaultBuildStages = [ 'setup', 'analyze', 'generate' ];\nexport const shaderStages = [ ...defaultShaderStages, 'compute' ];\nexport const vectorComponents = [ 'x', 'y', 'z', 'w' ];\n", "/**\n * Represents a 3x3 matrix.\n *\n * A Note on Row-Major and Column-Major Ordering:\n *\n * The constructor and {@link Matrix3#set} method take arguments in\n * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}\n * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.\n * This means that calling:\n * ```js\n * const m = new THREE.Matrix();\n * m.set( 11, 12, 13,\n *        21, 22, 23,\n *        31, 32, 33 );\n * ```\n * will result in the elements array containing:\n * ```js\n * m.elements = [ 11, 21, 31,\n *                12, 22, 32,\n *                13, 23, 33 ];\n * ```\n * and internally all calculations are performed using column-major ordering.\n * However, as the actual ordering makes no difference mathematically and\n * most people are used to thinking about matrices in row-major order, the\n * three.js documentation shows matrices in row-major order. Just bear in\n * mind that if you are reading the source code, you'll have to take the\n * transpose of any matrices outlined here to make sense of the calculations.\n */\nclass Matrix3 {\n\n\t/**\n\t * Constructs a new 3x3 matrix. The arguments are supposed to be\n\t * in row-major order. If no arguments are provided, the constructor\n\t * initializes the matrix as an identity matrix.\n\t *\n\t * @param {number} [n11] - 1-1 matrix element.\n\t * @param {number} [n12] - 1-2 matrix element.\n\t * @param {number} [n13] - 1-3 matrix element.\n\t * @param {number} [n21] - 2-1 matrix element.\n\t * @param {number} [n22] - 2-2 matrix element.\n\t * @param {number} [n23] - 2-3 matrix element.\n\t * @param {number} [n31] - 3-1 matrix element.\n\t * @param {number} [n32] - 3-2 matrix element.\n\t * @param {number} [n33] - 3-3 matrix element.\n\t */\n\tconstructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tMatrix3.prototype.isMatrix3 = true;\n\n\t\t/**\n\t\t * A column-major list of matrix values.\n\t\t *\n\t\t * @type {Array<number>}\n\t\t */\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the elements of the matrix.The arguments are supposed to be\n\t * in row-major order.\n\t *\n\t * @param {number} [n11] - 1-1 matrix element.\n\t * @param {number} [n12] - 1-2 matrix element.\n\t * @param {number} [n13] - 1-3 matrix element.\n\t * @param {number} [n21] - 2-1 matrix element.\n\t * @param {number} [n22] - 2-2 matrix element.\n\t * @param {number} [n23] - 2-3 matrix element.\n\t * @param {number} [n31] - 3-1 matrix element.\n\t * @param {number} [n32] - 3-2 matrix element.\n\t * @param {number} [n33] - 3-3 matrix element.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tset( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this matrix to the 3x3 identity matrix.\n\t *\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the values of the given matrix to this instance.\n\t *\n\t * @param {Matrix3} m - The matrix to copy.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Extracts the basis of this matrix into the three axis vectors provided.\n\t *\n\t * @param {Vector3} xAxis - The basis's x axis.\n\t * @param {Vector3} yAxis - The basis's y axis.\n\t * @param {Vector3} zAxis - The basis's z axis.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrix3Column( this, 0 );\n\t\tyAxis.setFromMatrix3Column( this, 1 );\n\t\tzAxis.setFromMatrix3Column( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.\n\t *\n\t * @param {Matrix4} m - The 4x4 matrix.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tsetFromMatrix4( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Post-multiplies this matrix by the given 3x3 matrix.\n\t *\n\t * @param {Matrix3} m - The matrix to multiply with.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\t/**\n\t * Pre-multiplies this matrix by the given 3x3 matrix.\n\t *\n\t * @param {Matrix3} m - The matrix to multiply with.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\t/**\n\t * Multiples the given 3x3 matrices and stores the result\n\t * in this matrix.\n\t *\n\t * @param {Matrix3} a - The first matrix.\n\t * @param {Matrix3} b - The second matrix.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies every component of the matrix by the given scalar.\n\t *\n\t * @param {number} s - The scalar.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes and returns the determinant of this matrix.\n\t *\n\t * @return {number} The determinant.\n\t */\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t}\n\n\t/**\n\t * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.\n\t * You can not invert with a determinant of zero. If you attempt this, the method produces\n\t * a zero matrix instead.\n\t *\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tinvert() {\n\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],\n\t\t\tn12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],\n\t\t\tn13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Transposes this matrix in place.\n\t *\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\ttranspose() {\n\n\t\tlet tmp;\n\t\tconst m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the normal matrix which is the inverse transpose of the upper\n\t * left 3x3 portion of the given 4x4 matrix.\n\t *\n\t * @param {Matrix4} matrix4 - The 4x4 matrix.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tgetNormalMatrix( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).invert().transpose();\n\n\t}\n\n\t/**\n\t * Transposes this matrix into the supplied array, and returns itself unchanged.\n\t *\n\t * @param {Array<number>} r - An array to store the transposed matrix elements.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\ttransposeIntoArray( r ) {\n\n\t\tconst m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the UV transform matrix from offset, repeat, rotation, and center.\n\t *\n\t * @param {number} tx - Offset x.\n\t * @param {number} ty - Offset y.\n\t * @param {number} sx - Repeat x.\n\t * @param {number} sy - Repeat y.\n\t * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.\n\t * @param {number} cx - Center x of rotation.\n\t * @param {number} cy - Center y of rotation\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tsetUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\tconst c = Math.cos( rotation );\n\t\tconst s = Math.sin( rotation );\n\n\t\tthis.set(\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Scales this matrix with the given scalar values.\n\t *\n\t * @param {number} sx - The amount to scale in the X axis.\n\t * @param {number} sy - The amount to scale in the Y axis.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tscale( sx, sy ) {\n\n\t\tthis.premultiply( _m3.makeScale( sx, sy ) );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Rotates this matrix by the given angle.\n\t *\n\t * @param {number} theta - The rotation in radians.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\trotate( theta ) {\n\n\t\tthis.premultiply( _m3.makeRotation( - theta ) );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Translates this matrix by the given scalar values.\n\t *\n\t * @param {number} tx - The amount to translate in the X axis.\n\t * @param {number} ty - The amount to translate in the Y axis.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\ttranslate( tx, ty ) {\n\n\t\tthis.premultiply( _m3.makeTranslation( tx, ty ) );\n\n\t\treturn this;\n\n\t}\n\n\t// for 2D Transforms\n\n\t/**\n\t * Sets this matrix as a 2D translation transform.\n\t *\n\t * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.\n\t * @param {number} y - The amount to translate in the Y axis.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tmakeTranslation( x, y ) {\n\n\t\tif ( x.isVector2 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x.x,\n\t\t\t\t0, 1, x.y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x,\n\t\t\t\t0, 1, y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this matrix as a 2D rotational transformation.\n\t *\n\t * @param {number} theta - The rotation in radians.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tmakeRotation( theta ) {\n\n\t\t// counterclockwise\n\n\t\tconst c = Math.cos( theta );\n\t\tconst s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0,\n\t\t\ts, c, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this matrix as a 2D scale transform.\n\t *\n\t * @param {number} x - The amount to scale in the X axis.\n\t * @param {number} y - The amount to scale in the Y axis.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tmakeScale( x, y ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0,\n\t\t\t0, y, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this matrix is equal with the given one.\n\t *\n\t * @param {Matrix3} matrix - The matrix to test for equality.\n\t * @return {boolean} Whether this matrix is equal with the given one.\n\t */\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Sets the elements of the matrix from the given array.\n\t *\n\t * @param {Array<number>} array - The matrix elements in column-major order.\n\t * @param {number} [offset=0] - Index of the first element in the array.\n\t * @return {Matrix3} A reference to this matrix.\n\t */\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Writes the elements of this matrix to the given array. If no array is provided,\n\t * the method returns a new instance.\n\t *\n\t * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.\n\t * @param {number} [offset=0] - Index of the first element in the array.\n\t * @return {Array<number>} The matrix elements in column-major order.\n\t */\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n\t/**\n\t * Returns a matrix with copied values from this instance.\n\t *\n\t * @return {Matrix3} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t}\n\n}\n\nconst _m3 = /*@__PURE__*/ new Matrix3();\n\nexport { Matrix3 };\n", "function arrayMin( array ) {\n\n\tif ( array.length === 0 ) return Infinity;\n\n\tlet min = array[ 0 ];\n\n\tfor ( let i = 1, l = array.length; i < l; ++ i ) {\n\n\t\tif ( array[ i ] < min ) min = array[ i ];\n\n\t}\n\n\treturn min;\n\n}\n\nfunction arrayMax( array ) {\n\n\tif ( array.length === 0 ) return - Infinity;\n\n\tlet max = array[ 0 ];\n\n\tfor ( let i = 1, l = array.length; i < l; ++ i ) {\n\n\t\tif ( array[ i ] > max ) max = array[ i ];\n\n\t}\n\n\treturn max;\n\n}\n\nfunction arrayNeedsUint32( array ) {\n\n\t// assumes larger values usually on last\n\n\tfor ( let i = array.length - 1; i >= 0; -- i ) {\n\n\t\tif ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n\n\t}\n\n\treturn false;\n\n}\n\nconst TYPED_ARRAYS = {\n\tInt8Array: Int8Array,\n\tUint8Array: Uint8Array,\n\tUint8ClampedArray: Uint8ClampedArray,\n\tInt16Array: Int16Array,\n\tUint16Array: Uint16Array,\n\tInt32Array: Int32Array,\n\tUint32Array: Uint32Array,\n\tFloat32Array: Float32Array,\n\tFloat64Array: Float64Array\n};\n\nfunction getTypedArray( type, buffer ) {\n\n\treturn new TYPED_ARRAYS[ type ]( buffer );\n\n}\n\nfunction createElementNS( name ) {\n\n\treturn document.createElementNS( 'http://www.w3.org/1999/xhtml', name );\n\n}\n\nfunction createCanvasElement() {\n\n\tconst canvas = createElementNS( 'canvas' );\n\tcanvas.style.display = 'block';\n\treturn canvas;\n\n}\n\nconst _cache = {};\n\nfunction warnOnce( message ) {\n\n\tif ( message in _cache ) return;\n\n\t_cache[ message ] = true;\n\n\tconsole.warn( message );\n\n}\n\nfunction probeAsync( gl, sync, interval ) {\n\n\treturn new Promise( function ( resolve, reject ) {\n\n\t\tfunction probe() {\n\n\t\t\tswitch ( gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 ) ) {\n\n\t\t\t\tcase gl.WAIT_FAILED:\n\t\t\t\t\treject();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.TIMEOUT_EXPIRED:\n\t\t\t\t\tsetTimeout( probe, interval );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tresolve();\n\n\t\t\t}\n\n\t\t}\n\n\t\tsetTimeout( probe, interval );\n\n\t} );\n\n}\n\nfunction toNormalizedProjectionMatrix( projectionMatrix ) {\n\n\tconst m = projectionMatrix.elements;\n\n\t// Convert [-1, 1] to [0, 1] projection matrix\n\tm[ 2 ] = 0.5 * m[ 2 ] + 0.5 * m[ 3 ];\n\tm[ 6 ] = 0.5 * m[ 6 ] + 0.5 * m[ 7 ];\n\tm[ 10 ] = 0.5 * m[ 10 ] + 0.5 * m[ 11 ];\n\tm[ 14 ] = 0.5 * m[ 14 ] + 0.5 * m[ 15 ];\n\n}\n\nfunction toReversedProjectionMatrix( projectionMatrix ) {\n\n\tconst m = projectionMatrix.elements;\n\tconst isPerspectiveMatrix = m[ 11 ] === - 1;\n\n\t// Reverse [0, 1] projection matrix\n\tif ( isPerspectiveMatrix ) {\n\n\t\tm[ 10 ] = - m[ 10 ] - 1;\n\t\tm[ 14 ] = - m[ 14 ];\n\n\t} else {\n\n\t\tm[ 10 ] = - m[ 10 ];\n\t\tm[ 14 ] = - m[ 14 ] + 1;\n\n\t}\n\n}\n\nexport { arrayMin, arrayMax, arrayNeedsUint32, getTypedArray, createElementNS, createCanvasElement, warnOnce, probeAsync, toNormalizedProjectionMatrix, toReversedProjectionMatrix };\n", "import { SRGBColorSpace, LinearSRGBColorSpace, SRGBTransfer, LinearTransfer, NoColorSpace } from '../constants.js';\nimport { Matrix3 } from './Matrix3.js';\nimport { warnOnce } from '../utils.js';\n\nconst LINEAR_REC709_TO_XYZ = /*@__PURE__*/ new Matrix3().set(\n\t0.4123908, 0.3575843, 0.1804808,\n\t0.2126390, 0.7151687, 0.0721923,\n\t0.0193308, 0.1191948, 0.9505322\n);\n\nconst XYZ_TO_LINEAR_REC709 = /*@__PURE__*/ new Matrix3().set(\n\t3.2409699, - 1.5373832, - 0.4986108,\n\t- 0.9692436, 1.8759675, 0.0415551,\n\t0.0556301, - 0.2039770, 1.0569715\n);\n\nfunction createColorManagement() {\n\n\tconst ColorManagement = {\n\n\t\tenabled: true,\n\n\t\tworkingColorSpace: LinearSRGBColorSpace,\n\n\t\t/**\n\t\t * Implementations of supported color spaces.\n\t\t *\n\t\t * Required:\n\t\t *\t- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n\t\t *\t- whitePoint: reference white [ x y ]\n\t\t *\t- transfer: transfer function (pre-defined)\n\t\t *\t- toXYZ: Matrix3 RGB to XYZ transform\n\t\t *\t- fromXYZ: Matrix3 XYZ to RGB transform\n\t\t *\t- luminanceCoefficients: RGB luminance coefficients\n\t\t *\n\t\t * Optional:\n\t\t *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace, toneMappingMode: 'extended' | 'standard' }\n\t\t *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n\t\t *\n\t\t * Reference:\n\t\t * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n\t\t */\n\t\tspaces: {},\n\n\t\tconvert: function ( color, sourceColorSpace, targetColorSpace ) {\n\n\t\t\tif ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {\n\n\t\t\t\treturn color;\n\n\t\t\t}\n\n\t\t\tif ( this.spaces[ sourceColorSpace ].transfer === SRGBTransfer ) {\n\n\t\t\t\tcolor.r = SRGBToLinear( color.r );\n\t\t\t\tcolor.g = SRGBToLinear( color.g );\n\t\t\t\tcolor.b = SRGBToLinear( color.b );\n\n\t\t\t}\n\n\t\t\tif ( this.spaces[ sourceColorSpace ].primaries !== this.spaces[ targetColorSpace ].primaries ) {\n\n\t\t\t\tcolor.applyMatrix3( this.spaces[ sourceColorSpace ].toXYZ );\n\t\t\t\tcolor.applyMatrix3( this.spaces[ targetColorSpace ].fromXYZ );\n\n\t\t\t}\n\n\t\t\tif ( this.spaces[ targetColorSpace ].transfer === SRGBTransfer ) {\n\n\t\t\t\tcolor.r = LinearToSRGB( color.r );\n\t\t\t\tcolor.g = LinearToSRGB( color.g );\n\t\t\t\tcolor.b = LinearToSRGB( color.b );\n\n\t\t\t}\n\n\t\t\treturn color;\n\n\t\t},\n\n\t\tworkingToColorSpace: function ( color, targetColorSpace ) {\n\n\t\t\treturn this.convert( color, this.workingColorSpace, targetColorSpace );\n\n\t\t},\n\n\t\tcolorSpaceToWorking: function ( color, sourceColorSpace ) {\n\n\t\t\treturn this.convert( color, sourceColorSpace, this.workingColorSpace );\n\n\t\t},\n\n\t\tgetPrimaries: function ( colorSpace ) {\n\n\t\t\treturn this.spaces[ colorSpace ].primaries;\n\n\t\t},\n\n\t\tgetTransfer: function ( colorSpace ) {\n\n\t\t\tif ( colorSpace === NoColorSpace ) return LinearTransfer;\n\n\t\t\treturn this.spaces[ colorSpace ].transfer;\n\n\t\t},\n\n\t\tgetToneMappingMode: function ( colorSpace ) {\n\n\t\t\treturn this.spaces[ colorSpace ].outputColorSpaceConfig.toneMappingMode || 'standard';\n\n\t\t},\n\n\t\tgetLuminanceCoefficients: function ( target, colorSpace = this.workingColorSpace ) {\n\n\t\t\treturn target.fromArray( this.spaces[ colorSpace ].luminanceCoefficients );\n\n\t\t},\n\n\t\tdefine: function ( colorSpaces ) {\n\n\t\t\tObject.assign( this.spaces, colorSpaces );\n\n\t\t},\n\n\t\t// Internal APIs\n\n\t\t_getMatrix: function ( targetMatrix, sourceColorSpace, targetColorSpace ) {\n\n\t\t\treturn targetMatrix\n\t\t\t\t.copy( this.spaces[ sourceColorSpace ].toXYZ )\n\t\t\t\t.multiply( this.spaces[ targetColorSpace ].fromXYZ );\n\n\t\t},\n\n\t\t_getDrawingBufferColorSpace: function ( colorSpace ) {\n\n\t\t\treturn this.spaces[ colorSpace ].outputColorSpaceConfig.drawingBufferColorSpace;\n\n\t\t},\n\n\t\t_getUnpackColorSpace: function ( colorSpace = this.workingColorSpace ) {\n\n\t\t\treturn this.spaces[ colorSpace ].workingColorSpaceConfig.unpackColorSpace;\n\n\t\t},\n\n\t\t// Deprecated\n\n\t\tfromWorkingColorSpace: function ( color, targetColorSpace ) {\n\n\t\t\twarnOnce( 'THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().' ); // @deprecated, r177\n\n\t\t\treturn ColorManagement.workingToColorSpace( color, targetColorSpace );\n\n\t\t},\n\n\t\ttoWorkingColorSpace: function ( color, sourceColorSpace ) {\n\n\t\t\twarnOnce( 'THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().' ); // @deprecated, r177\n\n\t\t\treturn ColorManagement.colorSpaceToWorking( color, sourceColorSpace );\n\n\t\t},\n\n\t};\n\n\t/******************************************************************************\n\t * sRGB definitions\n\t */\n\n\tconst REC709_PRIMARIES = [ 0.640, 0.330, 0.300, 0.600, 0.150, 0.060 ];\n\tconst REC709_LUMINANCE_COEFFICIENTS = [ 0.2126, 0.7152, 0.0722 ];\n\tconst D65 = [ 0.3127, 0.3290 ];\n\n\tColorManagement.define( {\n\n\t\t[ LinearSRGBColorSpace ]: {\n\t\t\tprimaries: REC709_PRIMARIES,\n\t\t\twhitePoint: D65,\n\t\t\ttransfer: LinearTransfer,\n\t\t\ttoXYZ: LINEAR_REC709_TO_XYZ,\n\t\t\tfromXYZ: XYZ_TO_LINEAR_REC709,\n\t\t\tluminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n\t\t\tworkingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\n\t\t\toutputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n\t\t},\n\n\t\t[ SRGBColorSpace ]: {\n\t\t\tprimaries: REC709_PRIMARIES,\n\t\t\twhitePoint: D65,\n\t\t\ttransfer: SRGBTransfer,\n\t\t\ttoXYZ: LINEAR_REC709_TO_XYZ,\n\t\t\tfromXYZ: XYZ_TO_LINEAR_REC709,\n\t\t\tluminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n\t\t\toutputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n\t\t},\n\n\t} );\n\n\treturn ColorManagement;\n\n}\n\nexport const ColorManagement = /*@__PURE__*/ createColorManagement();\n\nexport function SRGBToLinear( c ) {\n\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n}\n\nexport function LinearToSRGB( c ) {\n\n\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\n\n}\n", "import { clamp, euclideanModulo, lerp } from './MathUtils.js';\nimport { ColorManagement, SRGBToLinear, LinearToSRGB } from './ColorManagement.js';\nimport { SRGBColorSpace } from '../constants.js';\n\nconst _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\nconst _hslA = { h: 0, s: 0, l: 0 };\nconst _hslB = { h: 0, s: 0, l: 0 };\n\nfunction hue2rgb( p, q, t ) {\n\n\tif ( t < 0 ) t += 1;\n\tif ( t > 1 ) t -= 1;\n\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\tif ( t < 1 / 2 ) return q;\n\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\treturn p;\n\n}\n\n/**\n * A Color instance is represented by RGB components in the linear <i>working\n * color space</i>, which defaults to `LinearSRGBColorSpace`. Inputs\n * conventionally using `SRGBColorSpace` (such as hexadecimals and CSS\n * strings) are converted to the working color space automatically.\n *\n * ```js\n * // converted automatically from SRGBColorSpace to LinearSRGBColorSpace\n * const color = new THREE.Color().setHex( 0x112233 );\n * ```\n * Source color spaces may be specified explicitly, to ensure correct conversions.\n * ```js\n * // assumed already LinearSRGBColorSpace; no conversion\n * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5 );\n *\n * // converted explicitly from SRGBColorSpace to LinearSRGBColorSpace\n * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5, SRGBColorSpace );\n * ```\n * If THREE.ColorManagement is disabled, no conversions occur. For details,\n * see <i>Color management</i>. Iterating through a Color instance will yield\n * its components (r, g, b) in the corresponding order. A Color can be initialised\n * in any of the following ways:\n * ```js\n * //empty constructor - will default white\n * const color1 = new THREE.Color();\n *\n * //Hexadecimal color (recommended)\n * const color2 = new THREE.Color( 0xff0000 );\n *\n * //RGB string\n * const color3 = new THREE.Color(\"rgb(255, 0, 0)\");\n * const color4 = new THREE.Color(\"rgb(100%, 0%, 0%)\");\n *\n * //X11 color name - all 140 color names are supported.\n * //Note the lack of CamelCase in the name\n * const color5 = new THREE.Color( 'skyblue' );\n * //HSL string\n * const color6 = new THREE.Color(\"hsl(0, 100%, 50%)\");\n *\n * //Separate RGB values between 0 and 1\n * const color7 = new THREE.Color( 1, 0, 0 );\n * ```\n */\nclass Color {\n\n\t/**\n\t * Constructs a new color.\n\t *\n\t * Note that standard method of specifying color in three.js is with a hexadecimal triplet,\n\t * and that method is used throughout the rest of the documentation.\n\t *\n\t * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are\n\t * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.\n\t * @param {number} [g] - The green component.\n\t * @param {number} [b] - The blue component.\n\t */\n\tconstructor( r, g, b ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isColor = true;\n\n\t\t/**\n\t\t * The red component.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.r = 1;\n\n\t\t/**\n\t\t * The green component.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.g = 1;\n\n\t\t/**\n\t\t * The blue component.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.b = 1;\n\n\t\treturn this.set( r, g, b );\n\n\t}\n\n\t/**\n\t * Sets the colors's components from the given values.\n\t *\n\t * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are\n\t * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.\n\t * @param {number} [g] - The green component.\n\t * @param {number} [b] - The blue component.\n\t * @return {Color} A reference to this color.\n\t */\n\tset( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\n\t\t\tconst value = r;\n\n\t\t\tif ( value && value.isColor ) {\n\n\t\t\t\tthis.copy( value );\n\n\t\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\t\tthis.setHex( value );\n\n\t\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\t\tthis.setStyle( value );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.setRGB( r, g, b );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the colors's components to the given scalar value.\n\t *\n\t * @param {number} scalar - The scalar value.\n\t * @return {Color} A reference to this color.\n\t */\n\tsetScalar( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this color from a hexadecimal value.\n\t *\n\t * @param {number} hex - The hexadecimal value.\n\t * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n\t * @return {Color} A reference to this color.\n\t */\n\tsetHex( hex, colorSpace = SRGBColorSpace ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\tColorManagement.colorSpaceToWorking( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this color from RGB values.\n\t *\n\t * @param {number} r - Red channel value between `0.0` and `1.0`.\n\t * @param {number} g - Green channel value between `0.0` and `1.0`.\n\t * @param {number} b - Blue channel value between `0.0` and `1.0`.\n\t * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n\t * @return {Color} A reference to this color.\n\t */\n\tsetRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\tColorManagement.colorSpaceToWorking( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this color from RGB values.\n\t *\n\t * @param {number} h - Hue value between `0.0` and `1.0`.\n\t * @param {number} s - Saturation value between `0.0` and `1.0`.\n\t * @param {number} l - Lightness value between `0.0` and `1.0`.\n\t * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n\t * @return {Color} A reference to this color.\n\t */\n\tsetHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\th = euclideanModulo( h, 1 );\n\t\ts = clamp( s, 0, 1 );\n\t\tl = clamp( l, 0, 1 );\n\n\t\tif ( s === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = l;\n\n\t\t} else {\n\n\t\t\tconst p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\tconst q = ( 2 * l ) - p;\n\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t}\n\n\t\tColorManagement.colorSpaceToWorking( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,\n\t * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or\n\t * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -\n\t * all 140 color names are supported).\n\t *\n\t * @param {string} style - Color as a CSS-style string.\n\t * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n\t * @return {Color} A reference to this color.\n\t */\n\tsetStyle( style, colorSpace = SRGBColorSpace ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tlet m;\n\n\t\tif ( m = /^(\\w+)\\(([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tlet color;\n\t\t\tconst name = m[ 1 ];\n\t\t\tconst components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setHSL(\n\t\t\t\t\t\t\tparseFloat( color[ 1 ] ) / 360,\n\t\t\t\t\t\t\tparseFloat( color[ 2 ] ) / 100,\n\t\t\t\t\t\t\tparseFloat( color[ 3 ] ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color model ' + style );\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f\\d]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tconst hex = m[ 1 ];\n\t\t\tconst size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\treturn this.setRGB(\n\t\t\t\t\tparseInt( hex.charAt( 0 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 1 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 2 ), 16 ) / 15,\n\t\t\t\t\tcolorSpace\n\t\t\t\t);\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\treturn this.setHex( parseInt( hex, 16 ), colorSpace );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Invalid hex color ' + style );\n\n\t\t\t}\n\n\t\t} else if ( style && style.length > 0 ) {\n\n\t\t\treturn this.setColorName( style, colorSpace );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this color from a color name. Faster than {@link Color#setStyle} if\n\t * you don't need the other CSS-style formats.\n\t *\n\t * For convenience, the list of names is exposed in `Color.NAMES` as a hash.\n\t * ```js\n\t * Color.NAMES.aliceblue // returns 0xF0F8FF\n\t * ```\n\t *\n\t * @param {string} style - The color name.\n\t * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n\t * @return {Color} A reference to this color.\n\t */\n\tsetColorName( style, colorSpace = SRGBColorSpace ) {\n\n\t\t// color keywords\n\t\tconst hex = _colorKeywords[ style.toLowerCase() ];\n\n\t\tif ( hex !== undefined ) {\n\n\t\t\t// red\n\t\t\tthis.setHex( hex, colorSpace );\n\n\t\t} else {\n\n\t\t\t// unknown color\n\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a new color with copied values from this instance.\n\t *\n\t * @return {Color} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t}\n\n\t/**\n\t * Copies the values of the given color to this instance.\n\t *\n\t * @param {Color} color - The color to copy.\n\t * @return {Color} A reference to this color.\n\t */\n\tcopy( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the given color into this color, and then converts this color from\n\t * `SRGBColorSpace` to `LinearSRGBColorSpace`.\n\t *\n\t * @param {Color} color - The color to copy/convert.\n\t * @return {Color} A reference to this color.\n\t */\n\tcopySRGBToLinear( color ) {\n\n\t\tthis.r = SRGBToLinear( color.r );\n\t\tthis.g = SRGBToLinear( color.g );\n\t\tthis.b = SRGBToLinear( color.b );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the given color into this color, and then converts this color from\n\t * `LinearSRGBColorSpace` to `SRGBColorSpace`.\n\t *\n\t * @param {Color} color - The color to copy/convert.\n\t * @return {Color} A reference to this color.\n\t */\n\tcopyLinearToSRGB( color ) {\n\n\t\tthis.r = LinearToSRGB( color.r );\n\t\tthis.g = LinearToSRGB( color.g );\n\t\tthis.b = LinearToSRGB( color.b );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.\n\t *\n\t * @return {Color} A reference to this color.\n\t */\n\tconvertSRGBToLinear() {\n\n\t\tthis.copySRGBToLinear( this );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.\n\t *\n\t * @return {Color} A reference to this color.\n\t */\n\tconvertLinearToSRGB() {\n\n\t\tthis.copyLinearToSRGB( this );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the hexadecimal value of this color.\n\t *\n\t * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n\t * @return {number} The hexadecimal value.\n\t */\n\tgetHex( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );\n\n\t\treturn Math.round( clamp( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color.b * 255, 0, 255 ) );\n\n\t}\n\n\t/**\n\t * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').\n\t *\n\t * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n\t * @return {string} The hexadecimal value as a string.\n\t */\n\tgetHexString( colorSpace = SRGBColorSpace ) {\n\n\t\treturn ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );\n\n\t}\n\n\t/**\n\t * Converts the colors RGB values into the HSL format and stores them into the\n\t * given target object.\n\t *\n\t * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.\n\t * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n\t * @return {{h:number,s:number,l:number}} The HSL representation of this color.\n\t */\n\tgetHSL( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tconst max = Math.max( r, g, b );\n\t\tconst min = Math.min( r, g, b );\n\n\t\tlet hue, saturation;\n\t\tconst lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tconst delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\ttarget.h = hue;\n\t\ttarget.s = saturation;\n\t\ttarget.l = lightness;\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Returns the RGB values of this color and stores them into the given target object.\n\t *\n\t * @param {Color} target - The target color that is used to store the method's result.\n\t * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n\t * @return {Color} The RGB representation of this color.\n\t */\n\tgetRGB( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );\n\n\t\ttarget.r = _color.r;\n\t\ttarget.g = _color.g;\n\t\ttarget.b = _color.b;\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.\n\t *\n\t * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n\t * @return {string} The CSS representation of this color.\n\t */\n\tgetStyle( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tif ( colorSpace !== SRGBColorSpace ) {\n\n\t\t\t// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).\n\t\t\treturn `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;\n\n\t\t}\n\n\t\treturn `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;\n\n\t}\n\n\t/**\n\t * Adds the given HSL values to this color's values.\n\t * Internally, this converts the color's RGB values to HSL, adds HSL\n\t * and then converts the color back to RGB.\n\t *\n\t * @param {number} h - Hue value between `0.0` and `1.0`.\n\t * @param {number} s - Saturation value between `0.0` and `1.0`.\n\t * @param {number} l - Lightness value between `0.0` and `1.0`.\n\t * @return {Color} A reference to this color.\n\t */\n\toffsetHSL( h, s, l ) {\n\n\t\tthis.getHSL( _hslA );\n\n\t\treturn this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );\n\n\t}\n\n\t/**\n\t * Adds the RGB values of the given color to the RGB values of this color.\n\t *\n\t * @param {Color} color - The color to add.\n\t * @return {Color} A reference to this color.\n\t */\n\tadd( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the RGB values of the given colors and stores the result in this instance.\n\t *\n\t * @param {Color} color1 - The first color.\n\t * @param {Color} color2 - The second color.\n\t * @return {Color} A reference to this color.\n\t */\n\taddColors( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given scalar value to the RGB values of this color.\n\t *\n\t * @param {number} s - The scalar to add.\n\t * @return {Color} A reference to this color.\n\t */\n\taddScalar( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Subtracts the RGB values of the given color from the RGB values of this color.\n\t *\n\t * @param {Color} color - The color to subtract.\n\t * @return {Color} A reference to this color.\n\t */\n\tsub( color ) {\n\n\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies the RGB values of the given color with the RGB values of this color.\n\t *\n\t * @param {Color} color - The color to multiply.\n\t * @return {Color} A reference to this color.\n\t */\n\tmultiply( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies the given scalar value with the RGB values of this color.\n\t *\n\t * @param {number} s - The scalar to multiply.\n\t * @return {Color} A reference to this color.\n\t */\n\tmultiplyScalar( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Linearly interpolates this color's RGB values toward the RGB values of the\n\t * given color. The alpha argument can be thought of as the ratio between\n\t * the two colors, where `0.0` is this color and `1.0` is the first argument.\n\t *\n\t * @param {Color} color - The color to converge on.\n\t * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.\n\t * @return {Color} A reference to this color.\n\t */\n\tlerp( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Linearly interpolates between the given colors and stores the result in this instance.\n\t * The alpha argument can be thought of as the ratio between the two colors, where `0.0`\n\t * is the first and `1.0` is the second color.\n\t *\n\t * @param {Color} color1 - The first color.\n\t * @param {Color} color2 - The second color.\n\t * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.\n\t * @return {Color} A reference to this color.\n\t */\n\tlerpColors( color1, color2, alpha ) {\n\n\t\tthis.r = color1.r + ( color2.r - color1.r ) * alpha;\n\t\tthis.g = color1.g + ( color2.g - color1.g ) * alpha;\n\t\tthis.b = color1.b + ( color2.b - color1.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Linearly interpolates this color's HSL values toward the HSL values of the\n\t * given color. It differs from {@link Color#lerp} by not interpolating straight\n\t * from one color to the other, but instead going through all the hues in between\n\t * those two colors. The alpha argument can be thought of as the ratio between\n\t * the two colors, where 0.0 is this color and 1.0 is the first argument.\n\t *\n\t * @param {Color} color - The color to converge on.\n\t * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.\n\t * @return {Color} A reference to this color.\n\t */\n\tlerpHSL( color, alpha ) {\n\n\t\tthis.getHSL( _hslA );\n\t\tcolor.getHSL( _hslB );\n\n\t\tconst h = lerp( _hslA.h, _hslB.h, alpha );\n\t\tconst s = lerp( _hslA.s, _hslB.s, alpha );\n\t\tconst l = lerp( _hslA.l, _hslB.l, alpha );\n\n\t\tthis.setHSL( h, s, l );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the color's RGB components from the given 3D vector.\n\t *\n\t * @param {Vector3} v - The vector to set.\n\t * @return {Color} A reference to this color.\n\t */\n\tsetFromVector3( v ) {\n\n\t\tthis.r = v.x;\n\t\tthis.g = v.y;\n\t\tthis.b = v.z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Transforms this color with the given 3x3 matrix.\n\t *\n\t * @param {Matrix3} m - The matrix.\n\t * @return {Color} A reference to this color.\n\t */\n\tapplyMatrix3( m ) {\n\n\t\tconst r = this.r, g = this.g, b = this.b;\n\t\tconst e = m.elements;\n\n\t\tthis.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;\n\t\tthis.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;\n\t\tthis.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this color is equal with the given one.\n\t *\n\t * @param {Color} c - The color to test for equality.\n\t * @return {boolean} Whether this bounding color is equal with the given one.\n\t */\n\tequals( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t}\n\n\t/**\n\t * Sets this color's RGB components from the given array.\n\t *\n\t * @param {Array<number>} array - An array holding the RGB values.\n\t * @param {number} [offset=0] - The offset into the array.\n\t * @return {Color} A reference to this color.\n\t */\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Writes the RGB components of this color to the given array. If no array is provided,\n\t * the method returns a new instance.\n\t *\n\t * @param {Array<number>} [array=[]] - The target array holding the color components.\n\t * @param {number} [offset=0] - Index of the first element in the array.\n\t * @return {Array<number>} The color components.\n\t */\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n\t/**\n\t * Sets the components of this color from the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute holding color data.\n\t * @param {number} index - The index into the attribute.\n\t * @return {Color} A reference to this color.\n\t */\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.r = attribute.getX( index );\n\t\tthis.g = attribute.getY( index );\n\t\tthis.b = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * This methods defines the serialization result of this class. Returns the color\n\t * as a hexadecimal value.\n\t *\n\t * @return {number} The hexadecimal value.\n\t */\n\ttoJSON() {\n\n\t\treturn this.getHex();\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.r;\n\t\tyield this.g;\n\t\tyield this.b;\n\n\t}\n\n}\n\nconst _color = /*@__PURE__*/ new Color();\n\n/**\n * A dictionary with X11 color names.\n *\n * Note that multiple words such as Dark Orange become the string 'darkorange'.\n *\n * @static\n * @type {Object}\n */\nColor.NAMES = _colorKeywords;\n\nexport { Color };\n", "/**\n * Represents a 2x2 matrix.\n *\n * A Note on Row-Major and Column-Major Ordering:\n *\n * The constructor and {@link Matrix2#set} method take arguments in\n * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}\n * order, while internally they are stored in the {@link Matrix2#elements} array in column-major order.\n * This means that calling:\n * ```js\n * const m = new THREE.Matrix2();\n * m.set( 11, 12,\n *        21, 22 );\n * ```\n * will result in the elements array containing:\n * ```js\n * m.elements = [ 11, 21,\n *                12, 22 ];\n * ```\n * and internally all calculations are performed using column-major ordering.\n * However, as the actual ordering makes no difference mathematically and\n * most people are used to thinking about matrices in row-major order, the\n * three.js documentation shows matrices in row-major order. Just bear in\n * mind that if you are reading the source code, you'll have to take the\n * transpose of any matrices outlined here to make sense of the calculations.\n */\nexport class Matrix2 {\n\n\t/**\n\t * Constructs a new 2x2 matrix. The arguments are supposed to be\n\t * in row-major order. If no arguments are provided, the constructor\n\t * initializes the matrix as an identity matrix.\n\t *\n\t * @param {number} [n11] - 1-1 matrix element.\n\t * @param {number} [n12] - 1-2 matrix element.\n\t * @param {number} [n21] - 2-1 matrix element.\n\t * @param {number} [n22] - 2-2 matrix element.\n\t */\n\tconstructor( n11, n12, n21, n22 ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tMatrix2.prototype.isMatrix2 = true;\n\n\t\t/**\n\t\t * A column-major list of matrix values.\n\t\t *\n\t\t * @type {Array<number>}\n\t\t */\n\t\tthis.elements = [\n\t\t\t1, 0,\n\t\t\t0, 1,\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n21, n22 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets this matrix to the 2x2 identity matrix.\n\t *\n\t * @return {Matrix2} A reference to this matrix.\n\t */\n\tidentity() {\n\n\t\tthis.set(\n\t\t\t1, 0,\n\t\t\t0, 1,\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the elements of the matrix from the given array.\n\t *\n\t * @param {Array<number>} array - The matrix elements in column-major order.\n\t * @param {number} [offset=0] - Index of the first element in the array.\n\t * @return {Matrix2} A reference to this matrix.\n\t */\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the elements of the matrix.The arguments are supposed to be\n\t * in row-major order.\n\t *\n\t * @param {number} n11 - 1-1 matrix element.\n\t * @param {number} n12 - 1-2 matrix element.\n\t * @param {number} n21 - 2-1 matrix element.\n\t * @param {number} n22 - 2-2 matrix element.\n\t * @return {Matrix2} A reference to this matrix.\n\t */\n\tset( n11, n12, n21, n22 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 2 ] = n12;\n\t\tte[ 1 ] = n21; te[ 3 ] = n22;\n\n\t\treturn this;\n\n\t}\n\n}\n", "import { clamp } from './MathUtils.js';\nimport { Quaternion } from './Quaternion.js';\n\n/**\n * Class representing a 3D vector. A 3D vector is an ordered triplet of numbers\n * (labeled x, y and z), which can be used to represent a number of things, such as:\n *\n * - A point in 3D space.\n * - A direction and length in 3D space. In three.js the length will\n * always be the Euclidean distance(straight-line distance) from `(0, 0, 0)` to `(x, y, z)`\n * and the direction is also measured from `(0, 0, 0)` towards `(x, y, z)`.\n * - Any arbitrary ordered triplet of numbers.\n *\n * There are other things a 3D vector can be used to represent, such as\n * momentum vectors and so on, however these are the most\n * common uses in three.js.\n *\n * Iterating through a vector instance will yield its components `(x, y, z)` in\n * the corresponding order.\n * ```js\n * const a = new THREE.Vector3( 0, 1, 0 );\n *\n * //no arguments; will be initialised to (0, 0, 0)\n * const b = new THREE.Vector3( );\n *\n * const d = a.distanceTo( b );\n * ```\n */\nclass Vector3 {\n\n\t/**\n\t * Constructs a new 3D vector.\n\t *\n\t * @param {number} [x=0] - The x value of this vector.\n\t * @param {number} [y=0] - The y value of this vector.\n\t * @param {number} [z=0] - The z value of this vector.\n\t */\n\tconstructor( x = 0, y = 0, z = 0 ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tVector3.prototype.isVector3 = true;\n\n\t\t/**\n\t\t * The x value of this vector.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.x = x;\n\n\t\t/**\n\t\t * The y value of this vector.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.y = y;\n\n\t\t/**\n\t\t * The z value of this vector.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.z = z;\n\n\t}\n\n\t/**\n\t * Sets the vector components.\n\t *\n\t * @param {number} x - The value of the x component.\n\t * @param {number} y - The value of the y component.\n\t * @param {number} z - The value of the z component.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tset( x, y, z ) {\n\n\t\tif ( z === undefined ) z = this.z; // sprite.scale.set(x,y)\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector components to the same value.\n\t *\n\t * @param {number} scalar - The value to set for all vector components.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector's x component to the given value\n\t *\n\t * @param {number} x - The value to set.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector's y component to the given value\n\t *\n\t * @param {number} y - The value to set.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector's z component to the given value\n\t *\n\t * @param {number} z - The value to set.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Allows to set a vector component with an index.\n\t *\n\t * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.\n\t * @param {number} value - The value to set.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the value of the vector component which matches the given index.\n\t *\n\t * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.\n\t * @return {number} A vector component value.\n\t */\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a new vector with copied values from this instance.\n\t *\n\t * @return {Vector3} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t}\n\n\t/**\n\t * Copies the values of the given vector to this instance.\n\t *\n\t * @param {Vector3} v - The vector to copy.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given vector to this instance.\n\t *\n\t * @param {Vector3} v - The vector to add.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given scalar value to all components of this instance.\n\t *\n\t * @param {number} s - The scalar to add.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given vectors and stores the result in this instance.\n\t *\n\t * @param {Vector3} a - The first vector.\n\t * @param {Vector3} b - The second vector.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given vector scaled by the given factor to this instance.\n\t *\n\t * @param {Vector3|Vector4} v - The vector.\n\t * @param {number} s - The factor that scales `v`.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Subtracts the given vector from this instance.\n\t *\n\t * @param {Vector3} v - The vector to subtract.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Subtracts the given scalar value from all components of this instance.\n\t *\n\t * @param {number} s - The scalar to subtract.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Subtracts the given vectors and stores the result in this instance.\n\t *\n\t * @param {Vector3} a - The first vector.\n\t * @param {Vector3} b - The second vector.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies the given vector with this instance.\n\t *\n\t * @param {Vector3} v - The vector to multiply.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies the given scalar value with all components of this instance.\n\t *\n\t * @param {number} scalar - The scalar to multiply.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies the given vectors and stores the result in this instance.\n\t *\n\t * @param {Vector3} a - The first vector.\n\t * @param {Vector3} b - The second vector.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tmultiplyVectors( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Applies the given Euler rotation to this vector.\n\t *\n\t * @param {Euler} euler - The Euler angles.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tapplyEuler( euler ) {\n\n\t\treturn this.applyQuaternion( _quaternion.setFromEuler( euler ) );\n\n\t}\n\n\t/**\n\t * Applies a rotation specified by an axis and an angle to this vector.\n\t *\n\t * @param {Vector3} axis - A normalized vector representing the rotation axis.\n\t * @param {number} angle - The angle in radians.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tapplyAxisAngle( axis, angle ) {\n\n\t\treturn this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );\n\n\t}\n\n\t/**\n\t * Multiplies this vector with the given 3x3 matrix.\n\t *\n\t * @param {Matrix3} m - The 3x3 matrix.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies this vector by the given normal matrix and normalizes\n\t * the result.\n\t *\n\t * @param {Matrix3} m - The normal matrix.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tapplyNormalMatrix( m ) {\n\n\t\treturn this.applyMatrix3( m ).normalize();\n\n\t}\n\n\t/**\n\t * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and\n\t * divides by perspective.\n\t *\n\t * @param {Matrix4} m - The matrix to apply.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tconst w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Applies the given Quaternion to this vector.\n\t *\n\t * @param {Quaternion} q - The Quaternion.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tapplyQuaternion( q ) {\n\n\t\t// quaternion q is assumed to have unit length\n\n\t\tconst vx = this.x, vy = this.y, vz = this.z;\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// t = 2 * cross( q.xyz, v );\n\t\tconst tx = 2 * ( qy * vz - qz * vy );\n\t\tconst ty = 2 * ( qz * vx - qx * vz );\n\t\tconst tz = 2 * ( qx * vy - qy * vx );\n\n\t\t// v + q.w * t + cross( q.xyz, t );\n\t\tthis.x = vx + qw * tx + qy * tz - qz * ty;\n\t\tthis.y = vy + qw * ty + qz * tx - qx * tz;\n\t\tthis.z = vz + qw * tz + qx * ty - qy * tx;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Projects this vector from world space into the camera's normalized\n\t * device coordinate (NDC) space.\n\t *\n\t * @param {Camera} camera - The camera.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t}\n\n\t/**\n\t * Unprojects this vector from the camera's normalized device coordinate (NDC)\n\t * space into world space.\n\t *\n\t * @param {Camera} camera - The camera.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tunproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n\t}\n\n\t/**\n\t * Transforms the direction of this vector by a matrix (the upper left 3 x 3\n\t * subset of the given 4x4 matrix and then normalizes the result.\n\t *\n\t * @param {Matrix4} m - The matrix.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\ttransformDirection( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t}\n\n\t/**\n\t * Divides this instance by the given vector.\n\t *\n\t * @param {Vector3} v - The vector to divide.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Divides this vector by the given scalar.\n\t *\n\t * @param {number} scalar - The scalar to divide.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\t/**\n\t * If this vector's x, y or z value is greater than the given vector's x, y or z\n\t * value, replace that value with the corresponding min value.\n\t *\n\t * @param {Vector3} v - The vector.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's x, y or z value is less than the given vector's x, y or z\n\t * value, replace that value with the corresponding max value.\n\t *\n\t * @param {Vector3} v - The vector.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's x, y or z value is greater than the max vector's x, y or z\n\t * value, it is replaced by the corresponding value.\n\t * If this vector's x, y or z value is less than the min vector's x, y or z value,\n\t * it is replaced by the corresponding value.\n\t *\n\t * @param {Vector3} min - The minimum x, y and z values.\n\t * @param {Vector3} max - The maximum x, y and z values in the desired range.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\tthis.y = clamp( this.y, min.y, max.y );\n\t\tthis.z = clamp( this.z, min.z, max.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's x, y or z values are greater than the max value, they are\n\t * replaced by the max value.\n\t * If this vector's x, y or z values are less than the min value, they are\n\t * replaced by the min value.\n\t *\n\t * @param {number} minVal - The minimum value the components will be clamped to.\n\t * @param {number} maxVal - The maximum value the components will be clamped to.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\tthis.y = clamp( this.y, minVal, maxVal );\n\t\tthis.z = clamp( this.z, minVal, maxVal );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's length is greater than the max value, it is replaced by\n\t * the max value.\n\t * If this vector's length is less than the min value, it is replaced by the\n\t * min value.\n\t *\n\t * @param {number} min - The minimum value the vector length will be clamped to.\n\t * @param {number} max - The maximum value the vector length will be clamped to.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t}\n\n\t/**\n\t * The components of this vector are rounded down to the nearest integer value.\n\t *\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The components of this vector are rounded up to the nearest integer value.\n\t *\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The components of this vector are rounded to the nearest integer value\n\t *\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The components of this vector are rounded towards zero (up if negative,\n\t * down if positive) to an integer value.\n\t *\n\t * @return {Vector3} A reference to this vector.\n\t */\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\t\tthis.z = Math.trunc( this.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.\n\t *\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Calculates the dot product of the given vector with this instance.\n\t *\n\t * @param {Vector3} v - The vector to compute the dot product with.\n\t * @return {number} The result of the dot product.\n\t */\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t}\n\n\t// TODO lengthSquared?\n\n\t/**\n\t * Computes the square of the Euclidean length (straight-line length) from\n\t * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should\n\t * compare the length squared instead as it is slightly more efficient to calculate.\n\t *\n\t * @return {number} The square length of this vector.\n\t */\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t}\n\n\t/**\n\t * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).\n\t *\n\t * @return {number} The length of this vector.\n\t */\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t}\n\n\t/**\n\t * Computes the Manhattan length of this vector.\n\t *\n\t * @return {number} The length of this vector.\n\t */\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t}\n\n\t/**\n\t * Converts this vector to a unit vector - that is, sets it equal to a vector\n\t * with the same direction as this one, but with a vector length of `1`.\n\t *\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\t/**\n\t * Sets this vector to a vector with the same direction as this one, but\n\t * with the specified length.\n\t *\n\t * @param {number} length - The new length of this vector.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\t/**\n\t * Linearly interpolates between the given vector and this instance, where\n\t * alpha is the percent distance along the line - alpha = 0 will be this\n\t * vector, and alpha = 1 will be the given one.\n\t *\n\t * @param {Vector3} v - The vector to interpolate towards.\n\t * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Linearly interpolates between the given vectors, where alpha is the percent\n\t * distance along the line - alpha = 0 will be first vector, and alpha = 1 will\n\t * be the second one. The result is stored in this instance.\n\t *\n\t * @param {Vector3} v1 - The first vector.\n\t * @param {Vector3} v2 - The second vector.\n\t * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Calculates the cross product of the given vector with this instance.\n\t *\n\t * @param {Vector3} v - The vector to compute the cross product with.\n\t * @return {Vector3} The result of the cross product.\n\t */\n\tcross( v ) {\n\n\t\treturn this.crossVectors( this, v );\n\n\t}\n\n\t/**\n\t * Calculates the cross product of the given vectors and stores the result\n\t * in this instance.\n\t *\n\t * @param {Vector3} a - The first vector.\n\t * @param {Vector3} b - The second vector.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tcrossVectors( a, b ) {\n\n\t\tconst ax = a.x, ay = a.y, az = a.z;\n\t\tconst bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Projects this vector onto the given one.\n\t *\n\t * @param {Vector3} v - The vector to project to.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tprojectOnVector( v ) {\n\n\t\tconst denominator = v.lengthSq();\n\n\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\n\n\t\tconst scalar = v.dot( this ) / denominator;\n\n\t\treturn this.copy( v ).multiplyScalar( scalar );\n\n\t}\n\n\t/**\n\t * Projects this vector onto a plane by subtracting this\n\t * vector projected onto the plane's normal from this vector.\n\t *\n\t * @param {Vector3} planeNormal - The plane normal.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tprojectOnPlane( planeNormal ) {\n\n\t\t_vector.copy( this ).projectOnVector( planeNormal );\n\n\t\treturn this.sub( _vector );\n\n\t}\n\n\t/**\n\t * Reflects this vector off a plane orthogonal to the given normal vector.\n\t *\n\t * @param {Vector3} normal - The (normalized) normal vector.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\treflect( normal ) {\n\n\t\treturn this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t}\n\t/**\n\t * Returns the angle between the given vector and this instance in radians.\n\t *\n\t * @param {Vector3} v - The vector to compute the angle with.\n\t * @return {number} The angle in radians.\n\t */\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\t/**\n\t * Computes the distance from the given vector to this instance.\n\t *\n\t * @param {Vector3} v - The vector to compute the distance to.\n\t * @return {number} The distance.\n\t */\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\t/**\n\t * Computes the squared distance from the given vector to this instance.\n\t * If you are just comparing the distance with another distance, you should compare\n\t * the distance squared instead as it is slightly more efficient to calculate.\n\t *\n\t * @param {Vector3} v - The vector to compute the squared distance to.\n\t * @return {number} The squared distance.\n\t */\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t}\n\n\t/**\n\t * Computes the Manhattan distance from the given vector to this instance.\n\t *\n\t * @param {Vector3} v - The vector to compute the Manhattan distance to.\n\t * @return {number} The Manhattan distance.\n\t */\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t}\n\n\t/**\n\t * Sets the vector components from the given spherical coordinates.\n\t *\n\t * @param {Spherical} s - The spherical coordinates.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetFromSpherical( s ) {\n\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t}\n\n\t/**\n\t * Sets the vector components from the given spherical coordinates.\n\t *\n\t * @param {number} radius - The radius.\n\t * @param {number} phi - The phi angle in radians.\n\t * @param {number} theta - The theta angle in radians.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetFromSphericalCoords( radius, phi, theta ) {\n\n\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\tthis.y = Math.cos( phi ) * radius;\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector components from the given cylindrical coordinates.\n\t *\n\t * @param {Cylindrical} c - The cylindrical coordinates.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetFromCylindrical( c ) {\n\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t}\n\n\t/**\n\t * Sets the vector components from the given cylindrical coordinates.\n\t *\n\t * @param {number} radius - The radius.\n\t * @param {number} theta - The theta angle in radians.\n\t * @param {number} y - The y value.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetFromCylindricalCoords( radius, theta, y ) {\n\n\t\tthis.x = radius * Math.sin( theta );\n\t\tthis.y = y;\n\t\tthis.z = radius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector components to the position elements of the\n\t * given transformation matrix.\n\t *\n\t * @param {Matrix4} m - The 4x4 matrix.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector components to the scale elements of the\n\t * given transformation matrix.\n\t *\n\t * @param {Matrix4} m - The 4x4 matrix.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetFromMatrixScale( m ) {\n\n\t\tconst sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tconst sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tconst sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector components from the specified matrix column.\n\t *\n\t * @param {Matrix4} m - The 4x4 matrix.\n\t * @param {number} index - The column index.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetFromMatrixColumn( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t}\n\n\t/**\n\t * Sets the vector components from the specified matrix column.\n\t *\n\t * @param {Matrix3} m - The 3x3 matrix.\n\t * @param {number} index - The column index.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetFromMatrix3Column( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 3 );\n\n\t}\n\n\t/**\n\t * Sets the vector components from the given Euler angles.\n\t *\n\t * @param {Euler} e - The Euler angles to set.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetFromEuler( e ) {\n\n\t\tthis.x = e._x;\n\t\tthis.y = e._y;\n\t\tthis.z = e._z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector components from the RGB components of the\n\t * given color.\n\t *\n\t * @param {Color} c - The color to set.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tsetFromColor( c ) {\n\n\t\tthis.x = c.r;\n\t\tthis.y = c.g;\n\t\tthis.z = c.b;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this vector is equal with the given one.\n\t *\n\t * @param {Vector3} v - The vector to test for equality.\n\t * @return {boolean} Whether this vector is equal with the given one.\n\t */\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t}\n\n\t/**\n\t * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`\n\t * and z value to be `array[ offset + 2 ]`.\n\t *\n\t * @param {Array<number>} array - An array holding the vector component values.\n\t * @param {number} [offset=0] - The offset into the array.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Writes the components of this vector to the given array. If no array is provided,\n\t * the method returns a new instance.\n\t *\n\t * @param {Array<number>} [array=[]] - The target array holding the vector components.\n\t * @param {number} [offset=0] - Index of the first element in the array.\n\t * @return {Array<number>} The vector components.\n\t */\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t}\n\n\t/**\n\t * Sets the components of this vector from the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute holding vector data.\n\t * @param {number} index - The index into the attribute.\n\t * @return {Vector3} A reference to this vector.\n\t */\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets each component of this vector to a pseudo-random value between `0` and\n\t * `1`, excluding `1`.\n\t *\n\t * @return {Vector3} A reference to this vector.\n\t */\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this vector to a uniformly random point on a unit sphere.\n\t *\n\t * @return {Vector3} A reference to this vector.\n\t */\n\trandomDirection() {\n\n\t\t// https://mathworld.wolfram.com/SpherePointPicking.html\n\n\t\tconst theta = Math.random() * Math.PI * 2;\n\t\tconst u = Math.random() * 2 - 1;\n\t\tconst c = Math.sqrt( 1 - u * u );\n\n\t\tthis.x = c * Math.cos( theta );\n\t\tthis.y = u;\n\t\tthis.z = c * Math.sin( theta );\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\n\t}\n\n}\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\n\nexport { Vector3 };\n", "import { WebGLCoordinateSystem, WebGPUCoordinateSystem } from '../constants.js';\nimport { Vector3 } from './Vector3.js';\n\n/**\n * Represents a 4x4 matrix.\n *\n * The most common use of a 4x4 matrix in 3D computer graphics is as a transformation matrix.\n * For an introduction to transformation matrices as used in WebGL, check out [this tutorial]{@link https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices}\n *\n * This allows a 3D vector representing a point in 3D space to undergo\n * transformations such as translation, rotation, shear, scale, reflection,\n * orthogonal or perspective projection and so on, by being multiplied by the\n * matrix. This is known as `applying` the matrix to the vector.\n *\n * A Note on Row-Major and Column-Major Ordering:\n *\n * The constructor and {@link Matrix3#set} method take arguments in\n * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}\n * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.\n * This means that calling:\n * ```js\n * const m = new THREE.Matrix4();\n * m.set( 11, 12, 13, 14,\n *        21, 22, 23, 24,\n *        31, 32, 33, 34,\n *        41, 42, 43, 44 );\n * ```\n * will result in the elements array containing:\n * ```js\n * m.elements = [ 11, 21, 31, 41,\n *                12, 22, 32, 42,\n *                13, 23, 33, 43,\n *                14, 24, 34, 44 ];\n * ```\n * and internally all calculations are performed using column-major ordering.\n * However, as the actual ordering makes no difference mathematically and\n * most people are used to thinking about matrices in row-major order, the\n * three.js documentation shows matrices in row-major order. Just bear in\n * mind that if you are reading the source code, you'll have to take the\n * transpose of any matrices outlined here to make sense of the calculations.\n */\nclass Matrix4 {\n\n\t/**\n\t * Constructs a new 4x4 matrix. The arguments are supposed to be\n\t * in row-major order. If no arguments are provided, the constructor\n\t * initializes the matrix as an identity matrix.\n\t *\n\t * @param {number} [n11] - 1-1 matrix element.\n\t * @param {number} [n12] - 1-2 matrix element.\n\t * @param {number} [n13] - 1-3 matrix element.\n\t * @param {number} [n14] - 1-4 matrix element.\n\t * @param {number} [n21] - 2-1 matrix element.\n\t * @param {number} [n22] - 2-2 matrix element.\n\t * @param {number} [n23] - 2-3 matrix element.\n\t * @param {number} [n24] - 2-4 matrix element.\n\t * @param {number} [n31] - 3-1 matrix element.\n\t * @param {number} [n32] - 3-2 matrix element.\n\t * @param {number} [n33] - 3-3 matrix element.\n\t * @param {number} [n34] - 3-4 matrix element.\n\t * @param {number} [n41] - 4-1 matrix element.\n\t * @param {number} [n42] - 4-2 matrix element.\n\t * @param {number} [n43] - 4-3 matrix element.\n\t * @param {number} [n44] - 4-4 matrix element.\n\t */\n\tconstructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tMatrix4.prototype.isMatrix4 = true;\n\n\t\t/**\n\t\t * A column-major list of matrix values.\n\t\t *\n\t\t * @type {Array<number>}\n\t\t */\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the elements of the matrix.The arguments are supposed to be\n\t * in row-major order.\n\t *\n\t * @param {number} [n11] - 1-1 matrix element.\n\t * @param {number} [n12] - 1-2 matrix element.\n\t * @param {number} [n13] - 1-3 matrix element.\n\t * @param {number} [n14] - 1-4 matrix element.\n\t * @param {number} [n21] - 2-1 matrix element.\n\t * @param {number} [n22] - 2-2 matrix element.\n\t * @param {number} [n23] - 2-3 matrix element.\n\t * @param {number} [n24] - 2-4 matrix element.\n\t * @param {number} [n31] - 3-1 matrix element.\n\t * @param {number} [n32] - 3-2 matrix element.\n\t * @param {number} [n33] - 3-3 matrix element.\n\t * @param {number} [n34] - 3-4 matrix element.\n\t * @param {number} [n41] - 4-1 matrix element.\n\t * @param {number} [n42] - 4-2 matrix element.\n\t * @param {number} [n43] - 4-3 matrix element.\n\t * @param {number} [n44] - 4-4 matrix element.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tset( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this matrix to the 4x4 identity matrix.\n\t *\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a matrix with copied values from this instance.\n\t *\n\t * @return {Matrix4} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new Matrix4().fromArray( this.elements );\n\n\t}\n\n\t/**\n\t * Copies the values of the given matrix to this instance.\n\t *\n\t * @param {Matrix4} m - The matrix to copy.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the translation component of the given matrix\n\t * into this matrix's translation component.\n\t *\n\t * @param {Matrix4} m - The matrix to copy the translation component.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tcopyPosition( m ) {\n\n\t\tconst te = this.elements, me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.\n\t *\n\t * @param {Matrix3} m - The 3x3 matrix.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tsetFromMatrix3( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ], 0,\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ], 0,\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ], 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Extracts the basis of this matrix into the three axis vectors provided.\n\t *\n\t * @param {Vector3} xAxis - The basis's x axis.\n\t * @param {Vector3} yAxis - The basis's y axis.\n\t * @param {Vector3} zAxis - The basis's z axis.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the given basis vectors to this matrix.\n\t *\n\t * @param {Vector3} xAxis - The basis's x axis.\n\t * @param {Vector3} yAxis - The basis's y axis.\n\t * @param {Vector3} zAxis - The basis's z axis.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmakeBasis( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Extracts the rotation component of the given matrix\n\t * into this matrix's rotation component.\n\t *\n\t * Note: This method does not support reflection matrices.\n\t *\n\t * @param {Matrix4} m - The matrix.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\textractRotation( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tconst scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();\n\t\tconst scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();\n\t\tconst scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the rotation component (the upper left 3x3 matrix) of this matrix to\n\t * the rotation specified by the given Euler angles. The rest of\n\t * the matrix is set to the identity. Depending on the {@link Euler#order},\n\t * there are six possible outcomes. See [this page]{@link https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix}\n\t * for a complete list.\n\t *\n\t * @param {Euler} euler - The Euler angles.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmakeRotationFromEuler( euler ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = euler.x, y = euler.y, z = euler.z;\n\t\tconst a = Math.cos( x ), b = Math.sin( x );\n\t\tconst c = Math.cos( y ), d = Math.sin( y );\n\t\tconst e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// bottom row\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// last column\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the rotation component of this matrix to the rotation specified by\n\t * the given Quaternion as outlined [here]{@link https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion}\n\t * The rest of the matrix is set to the identity.\n\t *\n\t * @param {Quaternion} q - The Quaternion.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmakeRotationFromQuaternion( q ) {\n\n\t\treturn this.compose( _zero, q, _one );\n\n\t}\n\n\t/**\n\t * Sets the rotation component of the transformation matrix, looking from `eye` towards\n\t * `target`, and oriented by the up-direction.\n\t *\n\t * @param {Vector3} eye - The eye vector.\n\t * @param {Vector3} target - The target vector.\n\t * @param {Vector3} up - The up vector.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tlookAt( eye, target, up ) {\n\n\t\tconst te = this.elements;\n\n\t\t_z.subVectors( eye, target );\n\n\t\tif ( _z.lengthSq() === 0 ) {\n\n\t\t\t// eye and target are in the same position\n\n\t\t\t_z.z = 1;\n\n\t\t}\n\n\t\t_z.normalize();\n\t\t_x.crossVectors( up, _z );\n\n\t\tif ( _x.lengthSq() === 0 ) {\n\n\t\t\t// up and z are parallel\n\n\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t_z.x += 0.0001;\n\n\t\t\t} else {\n\n\t\t\t\t_z.z += 0.0001;\n\n\t\t\t}\n\n\t\t\t_z.normalize();\n\t\t\t_x.crossVectors( up, _z );\n\n\t\t}\n\n\t\t_x.normalize();\n\t\t_y.crossVectors( _z, _x );\n\n\t\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\n\t\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\n\t\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Post-multiplies this matrix by the given 4x4 matrix.\n\t *\n\t * @param {Matrix4} m - The matrix to multiply with.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\t/**\n\t * Pre-multiplies this matrix by the given 4x4 matrix.\n\t *\n\t * @param {Matrix4} m - The matrix to multiply with.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\t/**\n\t * Multiples the given 4x4 matrices and stores the result\n\t * in this matrix.\n\t *\n\t * @param {Matrix4} a - The first matrix.\n\t * @param {Matrix4} b - The second matrix.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tconst a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tconst b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies every component of the matrix by the given scalar.\n\t *\n\t * @param {number} s - The scalar.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes and returns the determinant of this matrix.\n\t *\n\t * Based on the method outlined [here]{@link http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html}.\n\t *\n\t * @return {number} The determinant.\n\t */\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tconst n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tconst n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tconst n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t}\n\n\t/**\n\t * Transposes this matrix in place.\n\t *\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\ttranspose() {\n\n\t\tconst te = this.elements;\n\t\tlet tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the position component for this matrix from the given vector,\n\t * without affecting the rest of the matrix.\n\t *\n\t * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.\n\t * @param {number} y - The y component of the vector.\n\t * @param {number} z - The z component of the vector.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tsetPosition( x, y, z ) {\n\n\t\tconst te = this.elements;\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tte[ 12 ] = x.x;\n\t\t\tte[ 13 ] = x.y;\n\t\t\tte[ 14 ] = x.z;\n\n\t\t} else {\n\n\t\t\tte[ 12 ] = x;\n\t\t\tte[ 13 ] = y;\n\t\t\tte[ 14 ] = z;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.\n\t * You can not invert with a determinant of zero. If you attempt this, the method produces\n\t * a zero matrix instead.\n\t *\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tinvert() {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],\n\t\t\tn12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],\n\t\t\tn13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],\n\t\t\tn14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies the columns of this matrix by the given vector.\n\t *\n\t * @param {Vector3} v - The scale vector.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tscale( v ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Gets the maximum scale value of the three axes.\n\t *\n\t * @return {number} The maximum scale.\n\t */\n\tgetMaxScaleOnAxis() {\n\n\t\tconst te = this.elements;\n\n\t\tconst scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tconst scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tconst scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t}\n\n\t/**\n\t * Sets this matrix as a translation transform from the given vector.\n\t *\n\t * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.\n\t * @param {number} y - The amount to translate in the Y axis.\n\t * @param {number} z - The amount to translate in the z axis.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmakeTranslation( x, y, z ) {\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x.x,\n\t\t\t\t0, 1, 0, x.y,\n\t\t\t\t0, 0, 1, x.z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this matrix as a rotational transformation around the X axis by\n\t * the given angle.\n\t *\n\t * @param {number} theta - The rotation in radians.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmakeRotationX( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s, c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this matrix as a rotational transformation around the Y axis by\n\t * the given angle.\n\t *\n\t * @param {number} theta - The rotation in radians.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmakeRotationY( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this matrix as a rotational transformation around the Z axis by\n\t * the given angle.\n\t *\n\t * @param {number} theta - The rotation in radians.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmakeRotationZ( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts, c, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this matrix as a rotational transformation around the given axis by\n\t * the given angle.\n\t *\n\t * This is a somewhat controversial but mathematically sound alternative to\n\t * rotating via Quaternions. See the discussion [here]{@link https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199}.\n\t *\n\t * @param {Vector3} axis - The normalized rotation axis.\n\t * @param {number} angle - The rotation in radians.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmakeRotationAxis( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tconst c = Math.cos( angle );\n\t\tconst s = Math.sin( angle );\n\t\tconst t = 1 - c;\n\t\tconst x = axis.x, y = axis.y, z = axis.z;\n\t\tconst tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this matrix as a scale transformation.\n\t *\n\t * @param {number} x - The amount to scale in the X axis.\n\t * @param {number} y - The amount to scale in the Y axis.\n\t * @param {number} z - The amount to scale in the Z axis.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmakeScale( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this matrix as a shear transformation.\n\t *\n\t * @param {number} xy - The amount to shear X by Y.\n\t * @param {number} xz - The amount to shear X by Z.\n\t * @param {number} yx - The amount to shear Y by X.\n\t * @param {number} yz - The amount to shear Y by Z.\n\t * @param {number} zx - The amount to shear Z by X.\n\t * @param {number} zy - The amount to shear Z by Y.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmakeShear( xy, xz, yx, yz, zx, zy ) {\n\n\t\tthis.set(\n\n\t\t\t1, yx, zx, 0,\n\t\t\txy, 1, zy, 0,\n\t\t\txz, yz, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets this matrix to the transformation composed of the given position,\n\t * rotation (Quaternion) and scale.\n\t *\n\t * @param {Vector3} position - The position vector.\n\t * @param {Quaternion} quaternion - The rotation as a Quaternion.\n\t * @param {Vector3} scale - The scale vector.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tcompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\n\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\n\n\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\n\t\tte[ 1 ] = ( xy + wz ) * sx;\n\t\tte[ 2 ] = ( xz - wy ) * sx;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = ( xy - wz ) * sy;\n\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\n\t\tte[ 6 ] = ( yz + wx ) * sy;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = ( xz + wy ) * sz;\n\t\tte[ 9 ] = ( yz - wx ) * sz;\n\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = position.x;\n\t\tte[ 13 ] = position.y;\n\t\tte[ 14 ] = position.z;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Decomposes this matrix into its position, rotation and scale components\n\t * and provides the result in the given objects.\n\t *\n\t * Note: Not all matrices are decomposable in this way. For example, if an\n\t * object has a non-uniformly scaled parent, then the object's world matrix\n\t * may not be decomposable, and this method may not be appropriate.\n\t *\n\t * @param {Vector3} position - The position vector.\n\t * @param {Quaternion} quaternion - The rotation as a Quaternion.\n\t * @param {Vector3} scale - The scale vector.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tdecompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tlet sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\tconst sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\tconst sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = this.determinant();\n\t\tif ( det < 0 ) sx = - sx;\n\n\t\tposition.x = te[ 12 ];\n\t\tposition.y = te[ 13 ];\n\t\tposition.z = te[ 14 ];\n\n\t\t// scale the rotation part\n\t\t_m1.copy( this );\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1.elements[ 0 ] *= invSX;\n\t\t_m1.elements[ 1 ] *= invSX;\n\t\t_m1.elements[ 2 ] *= invSX;\n\n\t\t_m1.elements[ 4 ] *= invSY;\n\t\t_m1.elements[ 5 ] *= invSY;\n\t\t_m1.elements[ 6 ] *= invSY;\n\n\t\t_m1.elements[ 8 ] *= invSZ;\n\t\t_m1.elements[ 9 ] *= invSZ;\n\t\t_m1.elements[ 10 ] *= invSZ;\n\n\t\tquaternion.setFromRotationMatrix( _m1 );\n\n\t\tscale.x = sx;\n\t\tscale.y = sy;\n\t\tscale.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a perspective projection matrix. This is used internally by\n\t * {@link PerspectiveCamera#updateProjectionMatrix}.\n\n\t * @param {number} left - Left boundary of the viewing frustum at the near plane.\n\t * @param {number} right - Right boundary of the viewing frustum at the near plane.\n\t * @param {number} top - Top boundary of the viewing frustum at the near plane.\n\t * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.\n\t * @param {number} near - The distance from the camera to the near plane.\n\t * @param {number} far - The distance from the camera to the far plane.\n\t * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.\n\t * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmakePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = 2 * near / ( right - left );\n\t\tconst y = 2 * near / ( top - bottom );\n\n\t\tconst a = ( right + left ) / ( right - left );\n\t\tconst b = ( top + bottom ) / ( top - bottom );\n\n\t\tlet c, d;\n\n\t\tif ( reversedDepth ) {\n\n\t\t\tc = near / ( far - near );\n\t\t\td = ( far * near ) / ( far - near );\n\n\t\t} else {\n\n\t\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\t\tc = - ( far + near ) / ( far - near );\n\t\t\t\td = ( - 2 * far * near ) / ( far - near );\n\n\t\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\t\tc = - far / ( far - near );\n\t\t\t\td = ( - far * near ) / ( far - near );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t\t}\n\n\t\t}\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a; \tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b; \tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c; \tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a orthographic projection matrix. This is used internally by\n\t * {@link OrthographicCamera#updateProjectionMatrix}.\n\n\t * @param {number} left - Left boundary of the viewing frustum at the near plane.\n\t * @param {number} right - Right boundary of the viewing frustum at the near plane.\n\t * @param {number} top - Top boundary of the viewing frustum at the near plane.\n\t * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.\n\t * @param {number} near - The distance from the camera to the near plane.\n\t * @param {number} far - The distance from the camera to the far plane.\n\t * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.\n\t * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tmakeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = 2 / ( right - left );\n\t\tconst y = 2 / ( top - bottom );\n\n\t\tconst a = - ( right + left ) / ( right - left );\n\t\tconst b = - ( top + bottom ) / ( top - bottom );\n\n\t\tlet c, d;\n\n\t\tif ( reversedDepth ) {\n\n\t\t\tc = 1 / ( far - near );\n\t\t\td = far / ( far - near );\n\n\t\t} else {\n\n\t\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\t\tc = - 2 / ( far - near );\n\t\t\t\td = - ( far + near ) / ( far - near );\n\n\t\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\t\tc = - 1 / ( far - near );\n\t\t\t\td = - near / ( far - near );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t\t}\n\n\t\t}\n\n\t\tte[ 0 ] = x;\t\tte[ 4 ] = 0;\t\tte[ 8 ] = 0; \t\tte[ 12 ] = a;\n\t\tte[ 1 ] = 0; \t\tte[ 5 ] = y;\t\tte[ 9 ] = 0; \t\tte[ 13 ] = b;\n\t\tte[ 2 ] = 0; \t\tte[ 6 ] = 0;\t\tte[ 10 ] = c;\t\tte[ 14 ] = d;\n\t\tte[ 3 ] = 0; \t\tte[ 7 ] = 0;\t\tte[ 11 ] = 0;\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this matrix is equal with the given one.\n\t *\n\t * @param {Matrix4} matrix - The matrix to test for equality.\n\t * @return {boolean} Whether this matrix is equal with the given one.\n\t */\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Sets the elements of the matrix from the given array.\n\t *\n\t * @param {Array<number>} array - The matrix elements in column-major order.\n\t * @param {number} [offset=0] - Index of the first element in the array.\n\t * @return {Matrix4} A reference to this matrix.\n\t */\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Writes the elements of this matrix to the given array. If no array is provided,\n\t * the method returns a new instance.\n\t *\n\t * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.\n\t * @param {number} [offset=0] - Index of the first element in the array.\n\t * @return {Array<number>} The matrix elements in column-major order.\n\t */\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n}\n\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );\nconst _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );\nconst _x = /*@__PURE__*/ new Vector3();\nconst _y = /*@__PURE__*/ new Vector3();\nconst _z = /*@__PURE__*/ new Vector3();\n\nexport { Matrix4 };\n", "import { clamp } from './MathUtils.js';\n\n/**\n * Class representing a 2D vector. A 2D vector is an ordered pair of numbers\n * (labeled x and y), which can be used to represent a number of things, such as:\n *\n * - A point in 2D space (i.e. a position on a plane).\n * - A direction and length across a plane. In three.js the length will\n * always be the Euclidean distance(straight-line distance) from `(0, 0)` to `(x, y)`\n * and the direction is also measured from `(0, 0)` towards `(x, y)`.\n * - Any arbitrary ordered pair of numbers.\n *\n * There are other things a 2D vector can be used to represent, such as\n * momentum vectors, complex numbers and so on, however these are the most\n * common uses in three.js.\n *\n * Iterating through a vector instance will yield its components `(x, y)` in\n * the corresponding order.\n * ```js\n * const a = new THREE.Vector2( 0, 1 );\n *\n * //no arguments; will be initialised to (0, 0)\n * const b = new THREE.Vector2( );\n *\n * const d = a.distanceTo( b );\n * ```\n */\nclass Vector2 {\n\n\t/**\n\t * Constructs a new 2D vector.\n\t *\n\t * @param {number} [x=0] - The x value of this vector.\n\t * @param {number} [y=0] - The y value of this vector.\n\t */\n\tconstructor( x = 0, y = 0 ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tVector2.prototype.isVector2 = true;\n\n\t\t/**\n\t\t * The x value of this vector.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.x = x;\n\n\t\t/**\n\t\t * The y value of this vector.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.y = y;\n\n\t}\n\n\t/**\n\t * Alias for {@link Vector2#x}.\n\t *\n\t * @type {number}\n\t */\n\tget width() {\n\n\t\treturn this.x;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t}\n\n\t/**\n\t * Alias for {@link Vector2#y}.\n\t *\n\t * @type {number}\n\t */\n\tget height() {\n\n\t\treturn this.y;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t}\n\n\t/**\n\t * Sets the vector components.\n\t *\n\t * @param {number} x - The value of the x component.\n\t * @param {number} y - The value of the y component.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tset( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector components to the same value.\n\t *\n\t * @param {number} scalar - The value to set for all vector components.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector's x component to the given value\n\t *\n\t * @param {number} x - The value to set.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector's y component to the given value\n\t *\n\t * @param {number} y - The value to set.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Allows to set a vector component with an index.\n\t *\n\t * @param {number} index - The component index. `0` equals to x, `1` equals to y.\n\t * @param {number} value - The value to set.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the value of the vector component which matches the given index.\n\t *\n\t * @param {number} index - The component index. `0` equals to x, `1` equals to y.\n\t * @return {number} A vector component value.\n\t */\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a new vector with copied values from this instance.\n\t *\n\t * @return {Vector2} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t}\n\n\t/**\n\t * Copies the values of the given vector to this instance.\n\t *\n\t * @param {Vector2} v - The vector to copy.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given vector to this instance.\n\t *\n\t * @param {Vector2} v - The vector to add.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given scalar value to all components of this instance.\n\t *\n\t * @param {number} s - The scalar to add.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given vectors and stores the result in this instance.\n\t *\n\t * @param {Vector2} a - The first vector.\n\t * @param {Vector2} b - The second vector.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given vector scaled by the given factor to this instance.\n\t *\n\t * @param {Vector2} v - The vector.\n\t * @param {number} s - The factor that scales `v`.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Subtracts the given vector from this instance.\n\t *\n\t * @param {Vector2} v - The vector to subtract.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Subtracts the given scalar value from all components of this instance.\n\t *\n\t * @param {number} s - The scalar to subtract.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Subtracts the given vectors and stores the result in this instance.\n\t *\n\t * @param {Vector2} a - The first vector.\n\t * @param {Vector2} b - The second vector.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies the given vector with this instance.\n\t *\n\t * @param {Vector2} v - The vector to multiply.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies the given scalar value with all components of this instance.\n\t *\n\t * @param {number} scalar - The scalar to multiply.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Divides this instance by the given vector.\n\t *\n\t * @param {Vector2} v - The vector to divide.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Divides this vector by the given scalar.\n\t *\n\t * @param {number} scalar - The scalar to divide.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\t/**\n\t * Multiplies this vector (with an implicit 1 as the 3rd component) by\n\t * the given 3x3 matrix.\n\t *\n\t * @param {Matrix3} m - The matrix to apply.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's x or y value is greater than the given vector's x or y\n\t * value, replace that value with the corresponding min value.\n\t *\n\t * @param {Vector2} v - The vector.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's x or y value is less than the given vector's x or y\n\t * value, replace that value with the corresponding max value.\n\t *\n\t * @param {Vector2} v - The vector.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's x or y value is greater than the max vector's x or y\n\t * value, it is replaced by the corresponding value.\n\t * If this vector's x or y value is less than the min vector's x or y value,\n\t * it is replaced by the corresponding value.\n\t *\n\t * @param {Vector2} min - The minimum x and y values.\n\t * @param {Vector2} max - The maximum x and y values in the desired range.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\tthis.y = clamp( this.y, min.y, max.y );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's x or y values are greater than the max value, they are\n\t * replaced by the max value.\n\t * If this vector's x or y values are less than the min value, they are\n\t * replaced by the min value.\n\t *\n\t * @param {number} minVal - The minimum value the components will be clamped to.\n\t * @param {number} maxVal - The maximum value the components will be clamped to.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\tthis.y = clamp( this.y, minVal, maxVal );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's length is greater than the max value, it is replaced by\n\t * the max value.\n\t * If this vector's length is less than the min value, it is replaced by the\n\t * min value.\n\t *\n\t * @param {number} min - The minimum value the vector length will be clamped to.\n\t * @param {number} max - The maximum value the vector length will be clamped to.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t}\n\n\t/**\n\t * The components of this vector are rounded down to the nearest integer value.\n\t *\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The components of this vector are rounded up to the nearest integer value.\n\t *\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The components of this vector are rounded to the nearest integer value\n\t *\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The components of this vector are rounded towards zero (up if negative,\n\t * down if positive) to an integer value.\n\t *\n\t * @return {Vector2} A reference to this vector.\n\t */\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Inverts this vector - i.e. sets x = -x and y = -y.\n\t *\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Calculates the dot product of the given vector with this instance.\n\t *\n\t * @param {Vector2} v - The vector to compute the dot product with.\n\t * @return {number} The result of the dot product.\n\t */\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t}\n\n\t/**\n\t * Calculates the cross product of the given vector with this instance.\n\t *\n\t * @param {Vector2} v - The vector to compute the cross product with.\n\t * @return {number} The result of the cross product.\n\t */\n\tcross( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t}\n\n\t/**\n\t * Computes the square of the Euclidean length (straight-line length) from\n\t * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should\n\t * compare the length squared instead as it is slightly more efficient to calculate.\n\t *\n\t * @return {number} The square length of this vector.\n\t */\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t}\n\n\t/**\n\t * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).\n\t *\n\t * @return {number} The length of this vector.\n\t */\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t}\n\n\t/**\n\t * Computes the Manhattan length of this vector.\n\t *\n\t * @return {number} The length of this vector.\n\t */\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t}\n\n\t/**\n\t * Converts this vector to a unit vector - that is, sets it equal to a vector\n\t * with the same direction as this one, but with a vector length of `1`.\n\t *\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\t/**\n\t * Computes the angle in radians of this vector with respect to the positive x-axis.\n\t *\n\t * @return {number} The angle in radians.\n\t */\n\tangle() {\n\n\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\n\n\t\treturn angle;\n\n\t}\n\n\t/**\n\t * Returns the angle between the given vector and this instance in radians.\n\t *\n\t * @param {Vector2} v - The vector to compute the angle with.\n\t * @return {number} The angle in radians.\n\t */\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\t/**\n\t * Computes the distance from the given vector to this instance.\n\t *\n\t * @param {Vector2} v - The vector to compute the distance to.\n\t * @return {number} The distance.\n\t */\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\t/**\n\t * Computes the squared distance from the given vector to this instance.\n\t * If you are just comparing the distance with another distance, you should compare\n\t * the distance squared instead as it is slightly more efficient to calculate.\n\t *\n\t * @param {Vector2} v - The vector to compute the squared distance to.\n\t * @return {number} The squared distance.\n\t */\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t}\n\n\t/**\n\t * Computes the Manhattan distance from the given vector to this instance.\n\t *\n\t * @param {Vector2} v - The vector to compute the Manhattan distance to.\n\t * @return {number} The Manhattan distance.\n\t */\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t}\n\n\t/**\n\t * Sets this vector to a vector with the same direction as this one, but\n\t * with the specified length.\n\t *\n\t * @param {number} length - The new length of this vector.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\t/**\n\t * Linearly interpolates between the given vector and this instance, where\n\t * alpha is the percent distance along the line - alpha = 0 will be this\n\t * vector, and alpha = 1 will be the given one.\n\t *\n\t * @param {Vector2} v - The vector to interpolate towards.\n\t * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Linearly interpolates between the given vectors, where alpha is the percent\n\t * distance along the line - alpha = 0 will be first vector, and alpha = 1 will\n\t * be the second one. The result is stored in this instance.\n\t *\n\t * @param {Vector2} v1 - The first vector.\n\t * @param {Vector2} v2 - The second vector.\n\t * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this vector is equal with the given one.\n\t *\n\t * @param {Vector2} v - The vector to test for equality.\n\t * @return {boolean} Whether this vector is equal with the given one.\n\t */\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t}\n\n\t/**\n\t * Sets this vector's x value to be `array[ offset ]` and y\n\t * value to be `array[ offset + 1 ]`.\n\t *\n\t * @param {Array<number>} array - An array holding the vector component values.\n\t * @param {number} [offset=0] - The offset into the array.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Writes the components of this vector to the given array. If no array is provided,\n\t * the method returns a new instance.\n\t *\n\t * @param {Array<number>} [array=[]] - The target array holding the vector components.\n\t * @param {number} [offset=0] - Index of the first element in the array.\n\t * @return {Array<number>} The vector components.\n\t */\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t}\n\n\t/**\n\t * Sets the components of this vector from the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute holding vector data.\n\t * @param {number} index - The index into the attribute.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Rotates this vector around the given center by the given angle.\n\t *\n\t * @param {Vector2} center - The point around which to rotate.\n\t * @param {number} angle - The angle to rotate, in radians.\n\t * @return {Vector2} A reference to this vector.\n\t */\n\trotateAround( center, angle ) {\n\n\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tconst x = this.x - center.x;\n\t\tconst y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets each component of this vector to a pseudo-random value between `0` and\n\t * `1`, excluding `1`.\n\t *\n\t * @return {Vector2} A reference to this vector.\n\t */\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\n\t}\n\n}\n\nexport { Vector2 };\n", "import { clamp } from './MathUtils.js';\n\n/**\n * Class representing a 4D vector. A 4D vector is an ordered quadruplet of numbers\n * (labeled x, y, z and w), which can be used to represent a number of things, such as:\n *\n * - A point in 4D space.\n * - A direction and length in 4D space. In three.js the length will\n * always be the Euclidean distance(straight-line distance) from `(0, 0, 0, 0)` to `(x, y, z, w)`\n * and the direction is also measured from `(0, 0, 0, 0)` towards `(x, y, z, w)`.\n * - Any arbitrary ordered quadruplet of numbers.\n *\n * There are other things a 4D vector can be used to represent, however these\n * are the most common uses in *three.js*.\n *\n * Iterating through a vector instance will yield its components `(x, y, z, w)` in\n * the corresponding order.\n * ```js\n * const a = new THREE.Vector4( 0, 1, 0, 0 );\n *\n * //no arguments; will be initialised to (0, 0, 0, 1)\n * const b = new THREE.Vector4( );\n *\n * const d = a.dot( b );\n * ```\n */\nclass Vector4 {\n\n\t/**\n\t * Constructs a new 4D vector.\n\t *\n\t * @param {number} [x=0] - The x value of this vector.\n\t * @param {number} [y=0] - The y value of this vector.\n\t * @param {number} [z=0] - The z value of this vector.\n\t * @param {number} [w=1] - The w value of this vector.\n\t */\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tVector4.prototype.isVector4 = true;\n\n\t\t/**\n\t\t * The x value of this vector.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.x = x;\n\n\t\t/**\n\t\t * The y value of this vector.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.y = y;\n\n\t\t/**\n\t\t * The z value of this vector.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.z = z;\n\n\t\t/**\n\t\t * The w value of this vector.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.w = w;\n\n\t}\n\n\t/**\n\t * Alias for {@link Vector4#z}.\n\t *\n\t * @type {number}\n\t */\n\tget width() {\n\n\t\treturn this.z;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.z = value;\n\n\t}\n\n\t/**\n\t * Alias for {@link Vector4#w}.\n\t *\n\t * @type {number}\n\t */\n\tget height() {\n\n\t\treturn this.w;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.w = value;\n\n\t}\n\n\t/**\n\t * Sets the vector components.\n\t *\n\t * @param {number} x - The value of the x component.\n\t * @param {number} y - The value of the y component.\n\t * @param {number} z - The value of the z component.\n\t * @param {number} w - The value of the w component.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tset( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector components to the same value.\n\t *\n\t * @param {number} scalar - The value to set for all vector components.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector's x component to the given value\n\t *\n\t * @param {number} x - The value to set.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector's y component to the given value\n\t *\n\t * @param {number} y - The value to set.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector's z component to the given value\n\t *\n\t * @param {number} z - The value to set.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector's w component to the given value\n\t *\n\t * @param {number} w - The value to set.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tsetW( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Allows to set a vector component with an index.\n\t *\n\t * @param {number} index - The component index. `0` equals to x, `1` equals to y,\n\t * `2` equals to z, `3` equals to w.\n\t * @param {number} value - The value to set.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the value of the vector component which matches the given index.\n\t *\n\t * @param {number} index - The component index. `0` equals to x, `1` equals to y,\n\t * `2` equals to z, `3` equals to w.\n\t * @return {number} A vector component value.\n\t */\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a new vector with copied values from this instance.\n\t *\n\t * @return {Vector4} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t}\n\n\t/**\n\t * Copies the values of the given vector to this instance.\n\t *\n\t * @param {Vector3|Vector4} v - The vector to copy.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given vector to this instance.\n\t *\n\t * @param {Vector4} v - The vector to add.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given scalar value to all components of this instance.\n\t *\n\t * @param {number} s - The scalar to add.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given vectors and stores the result in this instance.\n\t *\n\t * @param {Vector4} a - The first vector.\n\t * @param {Vector4} b - The second vector.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given vector scaled by the given factor to this instance.\n\t *\n\t * @param {Vector4} v - The vector.\n\t * @param {number} s - The factor that scales `v`.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Subtracts the given vector from this instance.\n\t *\n\t * @param {Vector4} v - The vector to subtract.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Subtracts the given scalar value from all components of this instance.\n\t *\n\t * @param {number} s - The scalar to subtract.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Subtracts the given vectors and stores the result in this instance.\n\t *\n\t * @param {Vector4} a - The first vector.\n\t * @param {Vector4} b - The second vector.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies the given vector with this instance.\n\t *\n\t * @param {Vector4} v - The vector to multiply.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\t\tthis.w *= v.w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies the given scalar value with all components of this instance.\n\t *\n\t * @param {number} scalar - The scalar to multiply.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Multiplies this vector with the given 4x4 matrix.\n\t *\n\t * @param {Matrix4} m - The 4x4 matrix.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Divides this instance by the given vector.\n\t *\n\t * @param {Vector4} v - The vector to divide.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\t\tthis.w /= v.w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Divides this vector by the given scalar.\n\t *\n\t * @param {number} scalar - The scalar to divide.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\t/**\n\t * Sets the x, y and z components of this\n\t * vector to the quaternion's axis and w to the angle.\n\t *\n\t * @param {Quaternion} q - The Quaternion to set.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tsetAxisAngleFromQuaternion( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tconst s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\tthis.x = 1;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t} else {\n\n\t\t\tthis.x = q.x / s;\n\t\t\tthis.y = q.y / s;\n\t\t\tthis.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the x, y and z components of this\n\t * vector to the axis of rotation and w to the angle.\n\t *\n\t * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tsetAxisAngleFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tlet angle, x, y, z; // variables for result\n\t\tconst epsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tconst xx = ( m11 + 1 ) / 2;\n\t\t\tconst yy = ( m22 + 1 ) / 2;\n\t\t\tconst zz = ( m33 + 1 ) / 2;\n\t\t\tconst xy = ( m12 + m21 ) / 4;\n\t\t\tconst xz = ( m13 + m31 ) / 4;\n\t\t\tconst yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tlet s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the vector components to the position elements of the\n\t * given transformation matrix.\n\t *\n\t * @param {Matrix4} m - The 4x4 matrix.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\t\tthis.w = e[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w\n\t * value, replace that value with the corresponding min value.\n\t *\n\t * @param {Vector4} v - The vector.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's x, y, z or w value is less than the given vector's x, y, z or w\n\t * value, replace that value with the corresponding max value.\n\t *\n\t * @param {Vector4} v - The vector.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w\n\t * value, it is replaced by the corresponding value.\n\t * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,\n\t * it is replaced by the corresponding value.\n\t *\n\t * @param {Vector4} min - The minimum x, y and z values.\n\t * @param {Vector4} max - The maximum x, y and z values in the desired range.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\tthis.y = clamp( this.y, min.y, max.y );\n\t\tthis.z = clamp( this.z, min.z, max.z );\n\t\tthis.w = clamp( this.w, min.w, max.w );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's x, y, z or w values are greater than the max value, they are\n\t * replaced by the max value.\n\t * If this vector's x, y, z or w values are less than the min value, they are\n\t * replaced by the min value.\n\t *\n\t * @param {number} minVal - The minimum value the components will be clamped to.\n\t * @param {number} maxVal - The maximum value the components will be clamped to.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\tthis.y = clamp( this.y, minVal, maxVal );\n\t\tthis.z = clamp( this.z, minVal, maxVal );\n\t\tthis.w = clamp( this.w, minVal, maxVal );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * If this vector's length is greater than the max value, it is replaced by\n\t * the max value.\n\t * If this vector's length is less than the min value, it is replaced by the\n\t * min value.\n\t *\n\t * @param {number} min - The minimum value the vector length will be clamped to.\n\t * @param {number} max - The maximum value the vector length will be clamped to.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t}\n\n\t/**\n\t * The components of this vector are rounded down to the nearest integer value.\n\t *\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The components of this vector are rounded up to the nearest integer value.\n\t *\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The components of this vector are rounded to the nearest integer value\n\t *\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The components of this vector are rounded towards zero (up if negative,\n\t * down if positive) to an integer value.\n\t *\n\t * @return {Vector4} A reference to this vector.\n\t */\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\t\tthis.z = Math.trunc( this.z );\n\t\tthis.w = Math.trunc( this.w );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.\n\t *\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Calculates the dot product of the given vector with this instance.\n\t *\n\t * @param {Vector4} v - The vector to compute the dot product with.\n\t * @return {number} The result of the dot product.\n\t */\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t}\n\n\t/**\n\t * Computes the square of the Euclidean length (straight-line length) from\n\t * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should\n\t * compare the length squared instead as it is slightly more efficient to calculate.\n\t *\n\t * @return {number} The square length of this vector.\n\t */\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t}\n\n\t/**\n\t * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).\n\t *\n\t * @return {number} The length of this vector.\n\t */\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t}\n\n\t/**\n\t * Computes the Manhattan length of this vector.\n\t *\n\t * @return {number} The length of this vector.\n\t */\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t}\n\n\t/**\n\t * Converts this vector to a unit vector - that is, sets it equal to a vector\n\t * with the same direction as this one, but with a vector length of `1`.\n\t *\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\t/**\n\t * Sets this vector to a vector with the same direction as this one, but\n\t * with the specified length.\n\t *\n\t * @param {number} length - The new length of this vector.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\t/**\n\t * Linearly interpolates between the given vector and this instance, where\n\t * alpha is the percent distance along the line - alpha = 0 will be this\n\t * vector, and alpha = 1 will be the given one.\n\t *\n\t * @param {Vector4} v - The vector to interpolate towards.\n\t * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Linearly interpolates between the given vectors, where alpha is the percent\n\t * distance along the line - alpha = 0 will be first vector, and alpha = 1 will\n\t * be the second one. The result is stored in this instance.\n\t *\n\t * @param {Vector4} v1 - The first vector.\n\t * @param {Vector4} v2 - The second vector.\n\t * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\t\tthis.w = v1.w + ( v2.w - v1.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this vector is equal with the given one.\n\t *\n\t * @param {Vector4} v - The vector to test for equality.\n\t * @return {boolean} Whether this vector is equal with the given one.\n\t */\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t}\n\n\t/**\n\t * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,\n\t * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.\n\t *\n\t * @param {Array<number>} array - An array holding the vector component values.\n\t * @param {number} [offset=0] - The offset into the array.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Writes the components of this vector to the given array. If no array is provided,\n\t * the method returns a new instance.\n\t *\n\t * @param {Array<number>} [array=[]] - The target array holding the vector components.\n\t * @param {number} [offset=0] - Index of the first element in the array.\n\t * @return {Array<number>} The vector components.\n\t */\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t}\n\n\t/**\n\t * Sets the components of this vector from the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute holding vector data.\n\t * @param {number} index - The index into the attribute.\n\t * @return {Vector4} A reference to this vector.\n\t */\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\t\tthis.w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets each component of this vector to a pseudo-random value between `0` and\n\t * `1`, excluding `1`.\n\t *\n\t * @return {Vector4} A reference to this vector.\n\t */\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\t\tthis.w = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\t\tyield this.w;\n\n\t}\n\n}\n\nexport { Vector4 };\n", "import { Color } from '../../math/Color.js';\nimport { Matrix2 } from '../../math/Matrix2.js';\nimport { Matrix3 } from '../../math/Matrix3.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Vector4 } from '../../math/Vector4.js';\n\n// cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.\n// A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.\n// Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.\n// See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480\n// https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\nfunction cyrb53( value, seed = 0 ) {\n\n\tlet h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n\n\tif ( value instanceof Array ) {\n\n\t\tfor ( let i = 0, val; i < value.length; i ++ ) {\n\n\t\t\tval = value[ i ];\n\t\t\th1 = Math.imul( h1 ^ val, 2654435761 );\n\t\t\th2 = Math.imul( h2 ^ val, 1597334677 );\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( let i = 0, ch; i < value.length; i ++ ) {\n\n\t\t\tch = value.charCodeAt( i );\n\t\t\th1 = Math.imul( h1 ^ ch, 2654435761 );\n\t\t\th2 = Math.imul( h2 ^ ch, 1597334677 );\n\n\t\t}\n\n\t}\n\n\th1 = Math.imul( h1 ^ ( h1 >>> 16 ), 2246822507 );\n\th1 ^= Math.imul( h2 ^ ( h2 >>> 13 ), 3266489909 );\n\th2 = Math.imul( h2 ^ ( h2 >>> 16 ), 2246822507 );\n\th2 ^= Math.imul( h1 ^ ( h1 >>> 13 ), 3266489909 );\n\n\treturn 4294967296 * ( 2097151 & h2 ) + ( h1 >>> 0 );\n\n}\n\n/**\n * Computes a hash for the given string.\n *\n * @method\n * @param {string} str - The string to be hashed.\n * @return {number} The hash.\n */\nexport const hashString = ( str ) => cyrb53( str );\n\n/**\n * Computes a hash for the given array.\n *\n * @method\n * @param {Array<number>} array - The array to be hashed.\n * @return {number} The hash.\n */\nexport const hashArray = ( array ) => cyrb53( array );\n\n/**\n * Computes a hash for the given list of parameters.\n *\n * @method\n * @param {...number} params - A list of parameters.\n * @return {number} The hash.\n */\nexport const hash = ( ...params ) => cyrb53( params );\n\n/**\n * Computes a cache key for the given node.\n *\n * @method\n * @param {Object|Node} object - The object to be hashed.\n * @param {boolean} [force=false] - Whether to force a cache key computation or not.\n * @return {number} The hash.\n */\nexport function getCacheKey( object, force = false ) {\n\n\tconst values = [];\n\n\tif ( object.isNode === true ) {\n\n\t\tvalues.push( object.id );\n\n\t}\n\n\tfor ( const { property, childNode } of getNodeChildren( object ) ) {\n\n\t\tvalues.push( cyrb53( property.slice( 0, - 4 ) ), childNode.getCacheKey( force ) );\n\n\t}\n\n\treturn cyrb53( values );\n\n}\n\n/**\n * This generator function can be used to iterate over the node children\n * of the given object.\n *\n * @generator\n * @param {Object} node - The object to be hashed.\n * @param {boolean} [toJSON=false] - Whether to return JSON or not.\n * @yields {Object} A result node holding the property, index (if available) and the child node.\n */\nexport function* getNodeChildren( node, toJSON = false ) {\n\n\tfor ( const property of Object.getOwnPropertyNames( node ) ) {\n\n\t\t// Ignore private properties.\n\t\tif ( property.startsWith( '_' ) === true ) continue;\n\n\t\tconst object = node[ property ];\n\n\t\tif ( Array.isArray( object ) === true ) {\n\n\t\t\tfor ( let i = 0; i < object.length; i ++ ) {\n\n\t\t\t\tconst child = object[ i ];\n\n\t\t\t\tif ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {\n\n\t\t\t\t\tyield { property, index: i, childNode: child };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( object && object.isNode === true ) {\n\n\t\t\tyield { property, childNode: object };\n\n\t\t} else if ( object && Object.getPrototypeOf( object ) === Object.prototype ) {\n\n\t\t\tfor ( const subProperty in object ) {\n\n\t\t\t\t// Ignore private properties.\n\t\t\t\tif ( subProperty.startsWith( '_' ) === true ) continue;\n\n\t\t\t\tconst child = object[ subProperty ];\n\n\t\t\t\tif ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {\n\n\t\t\t\t\tyield { property, index: subProperty, childNode: child };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst typeFromLength = /*@__PURE__*/ new Map( [\n\t[ 1, 'float' ],\n\t[ 2, 'vec2' ],\n\t[ 3, 'vec3' ],\n\t[ 4, 'vec4' ],\n\t[ 9, 'mat3' ],\n\t[ 16, 'mat4' ]\n] );\n\nconst dataFromObject = /*@__PURE__*/ new WeakMap();\n\n/**\n * Returns the data type for the given the length.\n *\n * @method\n * @param {number} length - The length.\n * @return {string} The data type.\n */\nexport function getTypeFromLength( length ) {\n\n\treturn typeFromLength.get( length );\n\n}\n\n/**\n * Returns the typed array for the given data type.\n *\n * @method\n * @param {string} type - The data type.\n * @return {TypedArray} The typed array.\n */\nexport function getTypedArrayFromType( type ) {\n\n\t// Handle component type for vectors and matrices\n\tif ( /[iu]?vec\\d/.test( type ) ) {\n\n\t\t// Handle int vectors\n\t\tif ( type.startsWith( 'ivec' ) ) return Int32Array;\n\t\t// Handle uint vectors\n\t\tif ( type.startsWith( 'uvec' ) ) return Uint32Array;\n\t\t// Default to float vectors\n\t\treturn Float32Array;\n\n\t}\n\n\t// Handle matrices (always float)\n\tif ( /mat\\d/.test( type ) ) return Float32Array;\n\n\t// Basic types\n\tif ( /float/.test( type ) ) return Float32Array;\n\tif ( /uint/.test( type ) ) return Uint32Array;\n\tif ( /int/.test( type ) ) return Int32Array;\n\n\tthrow new Error( `THREE.NodeUtils: Unsupported type: ${type}` );\n\n}\n\n/**\n * Returns the length for the given data type.\n *\n * @method\n * @param {string} type - The data type.\n * @return {number} The length.\n */\nexport function getLengthFromType( type ) {\n\n\tif ( /float|int|uint/.test( type ) ) return 1;\n\tif ( /vec2/.test( type ) ) return 2;\n\tif ( /vec3/.test( type ) ) return 3;\n\tif ( /vec4/.test( type ) ) return 4;\n\tif ( /mat2/.test( type ) ) return 4;\n\tif ( /mat3/.test( type ) ) return 9;\n\tif ( /mat4/.test( type ) ) return 16;\n\n\tconsole.error( 'THREE.TSL: Unsupported type:', type );\n\n}\n\n/**\n * Returns the gpu memory length for the given data type.\n *\n * @method\n * @param {string} type - The data type.\n * @return {number} The length.\n */\nexport function getMemoryLengthFromType( type ) {\n\n\tif ( /float|int|uint/.test( type ) ) return 1;\n\tif ( /vec2/.test( type ) ) return 2;\n\tif ( /vec3/.test( type ) ) return 3;\n\tif ( /vec4/.test( type ) ) return 4;\n\tif ( /mat2/.test( type ) ) return 4;\n\tif ( /mat3/.test( type ) ) return 12;\n\tif ( /mat4/.test( type ) ) return 16;\n\n\tconsole.error( 'THREE.TSL: Unsupported type:', type );\n\n}\n\n/**\n * Returns the byte boundary for the given data type.\n *\n * @method\n * @param {string} type - The data type.\n * @return {number} The byte boundary.\n */\nexport function getByteBoundaryFromType( type ) {\n\n\tif ( /float|int|uint/.test( type ) ) return 4;\n\tif ( /vec2/.test( type ) ) return 8;\n\tif ( /vec3/.test( type ) ) return 16;\n\tif ( /vec4/.test( type ) ) return 16;\n\tif ( /mat2/.test( type ) ) return 8;\n\tif ( /mat3/.test( type ) ) return 48;\n\tif ( /mat4/.test( type ) ) return 64;\n\n\tconsole.error( 'THREE.TSL: Unsupported type:', type );\n\n}\n\n/**\n * Returns the data type for the given value.\n *\n * @method\n * @param {any} value - The value.\n * @return {?string} The data type.\n */\nexport function getValueType( value ) {\n\n\tif ( value === undefined || value === null ) return null;\n\n\tconst typeOf = typeof value;\n\n\tif ( value.isNode === true ) {\n\n\t\treturn 'node';\n\n\t} else if ( typeOf === 'number' ) {\n\n\t\treturn 'float';\n\n\t} else if ( typeOf === 'boolean' ) {\n\n\t\treturn 'bool';\n\n\t} else if ( typeOf === 'string' ) {\n\n\t\treturn 'string';\n\n\t} else if ( typeOf === 'function' ) {\n\n\t\treturn 'shader';\n\n\t} else if ( value.isVector2 === true ) {\n\n\t\treturn 'vec2';\n\n\t} else if ( value.isVector3 === true ) {\n\n\t\treturn 'vec3';\n\n\t} else if ( value.isVector4 === true ) {\n\n\t\treturn 'vec4';\n\n\t} else if ( value.isMatrix2 === true ) {\n\n\t\treturn 'mat2';\n\n\t} else if ( value.isMatrix3 === true ) {\n\n\t\treturn 'mat3';\n\n\t} else if ( value.isMatrix4 === true ) {\n\n\t\treturn 'mat4';\n\n\t} else if ( value.isColor === true ) {\n\n\t\treturn 'color';\n\n\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\treturn 'ArrayBuffer';\n\n\t}\n\n\treturn null;\n\n}\n\n/**\n * Returns the value/object for the given data type and parameters.\n *\n * @method\n * @param {string} type - The given type.\n * @param {...any} params - A parameter list.\n * @return {any} The value/object.\n */\nexport function getValueFromType( type, ...params ) {\n\n\tconst last4 = type ? type.slice( - 4 ) : undefined;\n\n\tif ( params.length === 1 ) { // ensure same behaviour as in NodeBuilder.format()\n\n\t\tif ( last4 === 'vec2' ) params = [ params[ 0 ], params[ 0 ] ];\n\t\telse if ( last4 === 'vec3' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ] ];\n\t\telse if ( last4 === 'vec4' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ], params[ 0 ] ];\n\n\t}\n\n\tif ( type === 'color' ) {\n\n\t\treturn new Color( ...params );\n\n\t} else if ( last4 === 'vec2' ) {\n\n\t\treturn new Vector2( ...params );\n\n\t} else if ( last4 === 'vec3' ) {\n\n\t\treturn new Vector3( ...params );\n\n\t} else if ( last4 === 'vec4' ) {\n\n\t\treturn new Vector4( ...params );\n\n\t} else if ( last4 === 'mat2' ) {\n\n\t\treturn new Matrix2( ...params );\n\n\t} else if ( last4 === 'mat3' ) {\n\n\t\treturn new Matrix3( ...params );\n\n\t} else if ( last4 === 'mat4' ) {\n\n\t\treturn new Matrix4( ...params );\n\n\t} else if ( type === 'bool' ) {\n\n\t\treturn params[ 0 ] || false;\n\n\t} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {\n\n\t\treturn params[ 0 ] || 0;\n\n\t} else if ( type === 'string' ) {\n\n\t\treturn params[ 0 ] || '';\n\n\t} else if ( type === 'ArrayBuffer' ) {\n\n\t\treturn base64ToArrayBuffer( params[ 0 ] );\n\n\t}\n\n\treturn null;\n\n}\n\n/**\n * Gets the object data that can be shared between different rendering steps.\n *\n * @param {Object} object - The object to get the data for.\n * @return {Object} The object data.\n */\nexport function getDataFromObject( object ) {\n\n\tlet data = dataFromObject.get( object );\n\n\tif ( data === undefined ) {\n\n\t\tdata = {};\n\t\tdataFromObject.set( object, data );\n\n\t}\n\n\treturn data;\n\n}\n\n/**\n * Converts the given array buffer to a Base64 string.\n *\n * @method\n * @param {ArrayBuffer} arrayBuffer - The array buffer.\n * @return {string} The Base64 string.\n */\nexport function arrayBufferToBase64( arrayBuffer ) {\n\n\tlet chars = '';\n\n\tconst array = new Uint8Array( arrayBuffer );\n\n\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\tchars += String.fromCharCode( array[ i ] );\n\n\t}\n\n\treturn btoa( chars );\n\n}\n\n/**\n * Converts the given Base64 string to an array buffer.\n *\n * @method\n * @param {string} base64 - The Base64 string.\n * @return {ArrayBuffer} The array buffer.\n */\nexport function base64ToArrayBuffer( base64 ) {\n\n\treturn Uint8Array.from( atob( base64 ), c => c.charCodeAt( 0 ) ).buffer;\n\n}\n", "/**\n * This modules allows to dispatch event objects on custom JavaScript objects.\n *\n * Main repository: [eventdispatcher.js]{@link https://github.com/mrdoob/eventdispatcher.js/}\n *\n * Code Example:\n * ```js\n * class Car extends EventDispatcher {\n * \tstart() {\n *\t\tthis.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );\n *\t}\n *};\n *\n * // Using events with the custom object\n * const car = new Car();\n * car.addEventListener( 'start', function ( event ) {\n * \talert( event.message );\n * } );\n *\n * car.start();\n * ```\n */\nclass EventDispatcher {\n\n\t/**\n\t * Adds the given event listener to the given event type.\n\t *\n\t * @param {string} type - The type of event to listen to.\n\t * @param {Function} listener - The function that gets called when the event is fired.\n\t */\n\taddEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given event listener has been added to the given event type.\n\t *\n\t * @param {string} type - The type of event.\n\t * @param {Function} listener - The listener to check.\n\t * @return {boolean} Whether the given event listener has been added to the given event type.\n\t */\n\thasEventListener( type, listener ) {\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners === undefined ) return false;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t}\n\n\t/**\n\t * Removes the given event listener from the given event type.\n\t *\n\t * @param {string} type - The type of event.\n\t * @param {Function} listener - The listener to remove.\n\t */\n\tremoveEventListener( type, listener ) {\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners === undefined ) return;\n\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Dispatches an event object.\n\t *\n\t * @param {Object} event - The event that gets fired.\n\t */\n\tdispatchEvent( event ) {\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners === undefined ) return;\n\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { EventDispatcher };\n", "import { NodeUpdateType } from './constants.js';\nimport { getNodeChildren, getCacheKey, hash } from './NodeUtils.js';\n\nimport { EventDispatcher } from '../../core/EventDispatcher.js';\nimport { MathUtils } from '../../math/MathUtils.js';\n\nconst _parentBuildStage = {\n\tanalyze: 'setup',\n\tgenerate: 'analyze'\n};\n\nlet _nodeId = 0;\n\n/**\n * Base class for all nodes.\n *\n * @augments EventDispatcher\n */\nclass Node extends EventDispatcher {\n\n\tstatic get type() {\n\n\t\treturn 'Node';\n\n\t}\n\n\t/**\n\t * Constructs a new node.\n\t *\n\t * @param {?string} nodeType - The node type.\n\t */\n\tconstructor( nodeType = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node type. This represents the result type of the node (e.g. `float` or `vec3`).\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.nodeType = nodeType;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#update} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#updateBefore} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#updateAfter} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateAfterType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The UUID of the node.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\t/**\n\t\t * The version of the node. The version automatically is increased when {@link Node#needsUpdate} is set to `true`.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * Whether this node is global or not. This property is relevant for the internal\n\t\t * node caching system. All nodes which should be declared just once should\n\t\t * set this flag to `true` (a typical example is {@link AttributeNode}).\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.global = false;\n\n\t\t/**\n\t\t * Create a list of parents for this node during the build process.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.parents = false;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNode = true;\n\n\t\t// private\n\n\t\t/**\n\t\t * The cache key of this node.\n\t\t *\n\t\t * @private\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis._cacheKey = null;\n\n\t\t/**\n\t\t * The cache key 's version.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._cacheKeyVersion = 0;\n\n\t\tObject.defineProperty( this, 'id', { value: _nodeId ++ } );\n\n\t}\n\n\t/**\n\t * Set this property to `true` when the node should be regenerated.\n\t *\n\t * @type {boolean}\n\t * @default false\n\t * @param {boolean} value\n\t */\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The type of the class. The value is usually the constructor name.\n\t *\n\t * @type {string}\n \t * @readonly\n\t */\n\tget type() {\n\n\t\treturn this.constructor.type;\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @param {string} updateType - The update type.\n\t * @return {Node} A reference to this node.\n\t */\n\tonUpdate( callback, updateType ) {\n\n\t\tthis.updateType = updateType;\n\t\tthis.update = callback.bind( this );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `FRAME`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonFrameUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.FRAME );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `RENDER`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonRenderUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.RENDER );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `OBJECT`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonObjectUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.OBJECT );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#updateReference}.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonReference( callback ) {\n\n\t\tthis.updateReference = callback.bind( this );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Nodes might refer to other objects like materials. This method allows to dynamically update the reference\n\t * to such objects based on a given state (e.g. the current node frame or builder).\n\t *\n\t * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.\n\t * @return {any} The updated reference.\n\t */\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * By default this method returns the value of the {@link Node#global} flag. This method\n\t * can be overwritten in derived classes if an analytical way is required to determine the\n\t * global cache referring to the current shader-stage.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {boolean} Whether this node is global or not.\n\t */\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn this.global;\n\n\t}\n\n\t/**\n\t * Generator function that can be used to iterate over the child nodes.\n\t *\n\t * @generator\n\t * @yields {Node} A child node.\n\t */\n\t* getChildren() {\n\n\t\tfor ( const { childNode } of getNodeChildren( this ) ) {\n\n\t\t\tyield childNode;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calling this method dispatches the `dispose` event. This event can be used\n\t * to register event listeners for clean up tasks.\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\t/**\n\t * Callback for {@link Node#traverse}.\n\t *\n\t * @callback traverseCallback\n\t * @param {Node} node - The current node.\n\t */\n\n\t/**\n\t * Can be used to traverse through the node's hierarchy.\n\t *\n\t * @param {traverseCallback} callback - A callback that is executed per node.\n\t */\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tchildNode.traverse( callback );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the cache key for this node.\n\t *\n\t * @param {boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.\n\t * @return {number} The cache key of the node.\n\t */\n\tgetCacheKey( force = false ) {\n\n\t\tforce = force || this.version !== this._cacheKeyVersion;\n\n\t\tif ( force === true || this._cacheKey === null ) {\n\n\t\t\tthis._cacheKey = hash( getCacheKey( this, force ), this.customCacheKey() );\n\t\t\tthis._cacheKeyVersion = this.version;\n\n\t\t}\n\n\t\treturn this._cacheKey;\n\n\t}\n\n\t/**\n\t * Generate a custom cache key for this node.\n\t *\n\t * @return {number} The cache key of the node.\n\t */\n\tcustomCacheKey() {\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Returns the references to this node which is by default `this`.\n\t *\n\t * @return {Node} A reference to this node.\n\t */\n\tgetScope() {\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the hash of the node which is used to identify the node. By default it's\n\t * the {@link Node#uuid} however derived node classes might have to overwrite this method\n\t * depending on their implementation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The hash.\n\t */\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#update}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateType() {\n\n\t\treturn this.updateType;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#updateBefore}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateBeforeType() {\n\n\t\treturn this.updateBeforeType;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#updateAfter}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateAfterType() {\n\n\t\treturn this.updateAfterType;\n\n\t}\n\n\t/**\n\t * Certain types are composed of multiple elements. For example a `vec3`\n\t * is composed of three `float` values. This method returns the type of\n\t * these elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The type of the node.\n\t */\n\tgetElementType( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst elementType = builder.getElementType( type );\n\n\t\treturn elementType;\n\n\t}\n\n\t/**\n\t * Returns the node member type for the given name.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} name - The name of the member.\n\t * @return {string} The type of the node.\n\t */\n\tgetMemberType( /*builder, name*/ ) {\n\n\t\treturn 'void';\n\n\t}\n\n\t/**\n\t * Returns the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The type of the node.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tif ( nodeProperties.outputNode ) {\n\n\t\t\treturn nodeProperties.outputNode.getNodeType( builder );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * This method is used during the build process of a node and ensures\n\t * equal nodes are not built multiple times but just once. For example if\n\t * `attribute( 'uv' )` is used multiple times by the user, the build\n\t * process makes sure to process just the first node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The shared node if possible. Otherwise `this` is returned.\n\t */\n\tgetShared( builder ) {\n\n\t\tconst hash = this.getHash( builder );\n\t\tconst nodeFromHash = builder.getNodeFromHash( hash );\n\n\t\treturn nodeFromHash || this;\n\n\t}\n\n\t/**\n\t * Returns the number of elements in the node array.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {?number} The number of elements in the node array.\n\t */\n\tgetArrayCount( /*builder*/ ) {\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.\n\t * This method is often overwritten in derived modules to prepare the node which is used as a node's output/result.\n\t * If an output node is prepared, then it must be returned in the `return` statement of the derived module's setup function.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {?Node} The output node.\n\t */\n\tsetup( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tlet index = 0;\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tnodeProperties[ 'node' + index ++ ] = childNode;\n\n\t\t}\n\n\t\t// return a outputNode if exists or null\n\n\t\treturn nodeProperties.outputNode || null;\n\n\t}\n\n\t/**\n\t * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.\n\t * This stage analyzes the node hierarchy and ensures descendent nodes are built.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {?Node} output - The target output node.\n\t */\n\tanalyze( builder, output = null ) {\n\n\t\tconst usageCount = builder.increaseUsage( this );\n\n\t\tif ( this.parents === true ) {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this, 'any' );\n\t\t\tnodeData.stages = nodeData.stages || {};\n\t\t\tnodeData.stages[ builder.shaderStage ] = nodeData.stages[ builder.shaderStage ] || [];\n\t\t\tnodeData.stages[ builder.shaderStage ].push( output );\n\n\t\t}\n\n\t\tif ( usageCount === 1 ) {\n\n\t\t\t// node flow children\n\n\t\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\t\tfor ( const childNode of Object.values( nodeProperties ) ) {\n\n\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\tchildNode.build( builder, this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.\n\t * This state builds the output node and returns the resulting shader string.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {?string} [output] - Can be used to define the output type.\n\t * @return {?string} The generated shader string.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tconst { outputNode } = builder.getNodeProperties( this );\n\n\t\tif ( outputNode && outputNode.isNode === true ) {\n\n\t\t\treturn outputNode.build( builder, output );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state before it is used to render an object.\n\t * The {@link Node#updateBeforeType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdateBefore( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state after it was used to render an object.\n\t * The {@link Node#updateAfterType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdateAfter( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state when it is used to render an object.\n\t * The {@link Node#updateType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * This method performs the build of a node. The behavior and return value depend on the current build stage:\n\t * - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.\n\t * - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.\n\t * - **generate**: Generates the shader code for the node. Returns the generated shader string.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {?(string|Node)} [output=null] - Can be used to define the output type.\n\t * @return {?(Node|string)} The result of the build process, depending on the build stage.\n\t */\n\tbuild( builder, output = null ) {\n\n\t\tconst refNode = this.getShared( builder );\n\n\t\tif ( this !== refNode ) {\n\n\t\t\treturn refNode.build( builder, output );\n\n\t\t}\n\n\t\t//\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\t\tnodeData.buildStages = nodeData.buildStages || {};\n\t\tnodeData.buildStages[ builder.buildStage ] = true;\n\n\t\tconst parentBuildStage = _parentBuildStage[ builder.buildStage ];\n\n\t\tif ( parentBuildStage && nodeData.buildStages[ parentBuildStage ] !== true ) {\n\n\t\t\t// force parent build stage (setup or analyze)\n\n\t\t\tconst previousBuildStage = builder.getBuildStage();\n\n\t\t\tbuilder.setBuildStage( parentBuildStage );\n\n\t\t\tthis.build( builder );\n\n\t\t\tbuilder.setBuildStage( previousBuildStage );\n\n\t\t}\n\n\t\t//\n\n\t\tbuilder.addNode( this );\n\t\tbuilder.addChain( this );\n\n\t\t/* Build stages expected results:\n\t\t\t- \"setup\"\t\t-> Node\n\t\t\t- \"analyze\"\t\t-> null\n\t\t\t- \"generate\"\t-> String\n\t\t*/\n\t\tlet result = null;\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'setup' ) {\n\n\t\t\tthis.updateReference( builder );\n\n\t\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t\tif ( properties.initialized !== true ) {\n\n\t\t\t\t//const stackNodesBeforeSetup = builder.stack.nodes.length;\n\n\t\t\t\tproperties.initialized = true;\n\t\t\t\tproperties.outputNode = this.setup( builder ) || properties.outputNode || null;\n\n\t\t\t\t/*if ( isNodeOutput && builder.stack.nodes.length !== stackNodesBeforeSetup ) {\n\n\t\t\t\t\t// !! no outputNode !!\n\t\t\t\t\t//outputNode = builder.stack;\n\n\t\t\t\t}*/\n\n\t\t\t\tfor ( const childNode of Object.values( properties ) ) {\n\n\t\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\t\tif ( childNode.parents === true ) {\n\n\t\t\t\t\t\t\tconst childProperties = builder.getNodeProperties( childNode );\n\t\t\t\t\t\t\tchildProperties.parents = childProperties.parents || [];\n\t\t\t\t\t\t\tchildProperties.parents.push( this );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tchildNode.build( builder );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tresult = properties.outputNode;\n\n\t\t} else if ( buildStage === 'analyze' ) {\n\n\t\t\tthis.analyze( builder, output );\n\n\t\t} else if ( buildStage === 'generate' ) {\n\n\t\t\tconst isGenerateOnce = this.generate.length === 1;\n\n\t\t\tif ( isGenerateOnce ) {\n\n\t\t\t\tconst type = this.getNodeType( builder );\n\t\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\t\tresult = nodeData.snippet;\n\n\t\t\t\tif ( result === undefined ) {\n\n\t\t\t\t\tif ( nodeData.generated === undefined ) {\n\n\t\t\t\t\t\tnodeData.generated = true;\n\n\t\t\t\t\t\tresult = this.generate( builder ) || '';\n\n\t\t\t\t\t\tnodeData.snippet = result;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.Node: Recursion detected.', this );\n\n\t\t\t\t\t\tresult = '/* Recursion detected. */';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined ) {\n\n\t\t\t\t\tbuilder.addFlowCodeHierarchy( this, builder.context.nodeBlock );\n\n\t\t\t\t}\n\n\t\t\t\tresult = builder.format( result, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tresult = this.generate( builder, output ) || '';\n\n\t\t\t}\n\n\t\t\tif ( result === '' && output !== null && output !== 'void' && output !== 'OutputType' ) {\n\n\t\t\t\t// if no snippet is generated, return a default value\n\n\t\t\t\tconsole.error( `THREE.TSL: Invalid generated code, expected a \"${ output }\".` );\n\n\t\t\t\tresult = builder.generateConst( output );\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeChain( this );\n\t\tbuilder.addSequentialNode( this );\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns the child nodes as a JSON object.\n\t *\n\t * @return {Generator<Object>} An iterable list of serialized child objects as JSON.\n\t */\n\tgetSerializeChildren() {\n\n\t\treturn getNodeChildren( this );\n\n\t}\n\n\t/**\n\t * Serializes the node to JSON.\n\t *\n\t * @param {Object} json - The output JSON object.\n\t */\n\tserialize( json ) {\n\n\t\tconst nodeChildren = this.getSerializeChildren();\n\n\t\tconst inputNodes = {};\n\n\t\tfor ( const { property, index, childNode } of nodeChildren ) {\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tif ( inputNodes[ property ] === undefined ) {\n\n\t\t\t\t\tinputNodes[ property ] = Number.isInteger( index ) ? [] : {};\n\n\t\t\t\t}\n\n\t\t\t\tinputNodes[ property ][ index ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t} else {\n\n\t\t\t\tinputNodes[ property ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( inputNodes ).length > 0 ) {\n\n\t\t\tjson.inputNodes = inputNodes;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Deserializes the node from the given JSON.\n\t *\n\t * @param {Object} json - The JSON object.\n\t */\n\tdeserialize( json ) {\n\n\t\tif ( json.inputNodes !== undefined ) {\n\n\t\t\tconst nodes = json.meta.nodes;\n\n\t\t\tfor ( const property in json.inputNodes ) {\n\n\t\t\t\tif ( Array.isArray( json.inputNodes[ property ] ) ) {\n\n\t\t\t\t\tconst inputArray = [];\n\n\t\t\t\t\tfor ( const uuid of json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tinputArray.push( nodes[ uuid ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputArray;\n\n\t\t\t\t} else if ( typeof json.inputNodes[ property ] === 'object' ) {\n\n\t\t\t\t\tconst inputObject = {};\n\n\t\t\t\t\tfor ( const subProperty in json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tconst uuid = json.inputNodes[ property ][ subProperty ];\n\n\t\t\t\t\t\tinputObject[ subProperty ] = nodes[ uuid ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputObject;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst uuid = json.inputNodes[ property ];\n\n\t\t\t\t\tthis[ property ] = nodes[ uuid ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Serializes the node into the three.js JSON Object/Scene format.\n\t *\n\t * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.\n\t * @return {Object} The serialized node.\n\t */\n\ttoJSON( meta ) {\n\n\t\tconst { uuid, type } = this;\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\t// serialize\n\n\t\tlet data = meta.nodes[ uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = {\n\t\t\t\tuuid,\n\t\t\t\ttype,\n\t\t\t\tmeta,\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.7,\n\t\t\t\t\ttype: 'Node',\n\t\t\t\t\tgenerator: 'Node.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif ( isRoot !== true ) meta.nodes[ data.uuid ] = data;\n\n\t\t\tthis.serialize( data );\n\n\t\t\tdelete data.meta;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nexport default Node;\n", "import Node from './Node.js';\n\n/**\n * This module uses cache management to create temporary variables\n * if the node is used more than once to prevent duplicate calculations.\n *\n * The class acts as a base class for many other nodes types.\n *\n * @augments Node\n */\nclass TempNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TempNode';\n\n\t}\n\n\t/**\n\t * Constructs a temp node.\n\t *\n\t * @param {?string} nodeType - The node type.\n\t */\n\tconstructor( nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTempNode = true;\n\n\t}\n\n\t/**\n\t * Whether this node is used more than once in context of other nodes.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t * @return {boolean} A flag that indicates if there is more than one dependency to other nodes.\n\t */\n\thasDependencies( builder ) {\n\n\t\treturn builder.getDataFromNode( this ).usageCount > 1;\n\n\t}\n\n\tbuild( builder, output ) {\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'generate' ) {\n\n\t\t\tconst type = builder.getVectorType( this.getNodeType( builder, output ) );\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tif ( nodeData.propertyName !== undefined ) {\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t} else if ( type !== 'void' && output !== 'void' && this.hasDependencies( builder ) ) {\n\n\t\t\t\tconst snippet = super.build( builder, type );\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, null, type );\n\t\t\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tbuilder.addLineFlowCode( `${ propertyName } = ${ snippet }`, this );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.build( builder, output );\n\n\t}\n\n}\n\nexport default TempNode;\n", "import Node from './Node.js';\nimport { getValueType, getValueFromType, arrayBufferToBase64 } from './NodeUtils.js';\n\n/**\n * Base class for representing data input nodes.\n *\n * @augments Node\n */\nclass InputNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'InputNode';\n\n\t}\n\n\t/**\n\t * Constructs a new input node.\n\t *\n\t * @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).\n\t * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isInputNode = true;\n\n\t\t/**\n\t\t * The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).\n\t\t *\n\t\t * @type {any}\n\t\t */\n\t\tthis.value = value;\n\n\t\t/**\n\t\t * The precision of the value in the shader.\n\t\t *\n\t\t * @type {?('low'|'medium'|'high')}\n\t\t * @default null\n\t\t */\n\t\tthis.precision = null;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.nodeType === null ) {\n\n\t\t\treturn getValueType( this.value );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * Returns the input type of the node which is by default the node type. Derived modules\n\t * might overwrite this method and use a fixed type or compute one analytically.\n\t *\n\t * A typical example for different input and node types are textures. The input type of a\n\t * normal RGBA texture is `texture` whereas its node type is `vec4`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Sets the precision to the given value. The method can be\n\t * overwritten in derived classes if the final precision must be computed\n\t * analytically.\n\t *\n\t * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.\n\t * @return {InputNode} A reference to this node.\n\t */\n\tsetPrecision( precision ) {\n\n\t\tthis.precision = precision;\n\n\t\treturn this;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value;\n\n\t\tif ( this.value && this.value.toArray ) data.value = this.value.toArray();\n\n\t\tdata.valueType = getValueType( this.value );\n\t\tdata.nodeType = this.nodeType;\n\n\t\tif ( data.valueType === 'ArrayBuffer' ) data.value = arrayBufferToBase64( data.value );\n\n\t\tdata.precision = this.precision;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.nodeType = data.nodeType;\n\t\tthis.value = Array.isArray( data.value ) ? getValueFromType( data.valueType, ...data.value ) : data.value;\n\n\t\tthis.precision = data.precision || null;\n\n\t\tif ( this.value && this.value.fromArray ) this.value = this.value.fromArray( data.value );\n\n\t}\n\n\tgenerate( /*builder, output*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nexport default InputNode;\n", "import Node from './Node.js';\n\n/**\n * This node can be used to group single instances of {@link UniformNode}\n * and manage them as a uniform buffer.\n *\n * In most cases, the predefined nodes `objectGroup`, `renderGroup` and `frameGroup`\n * will be used when defining the {@link UniformNode#groupNode} property.\n *\n * - `objectGroup`: Uniform buffer per object.\n * - `renderGroup`: Shared uniform buffer, updated once per render call.\n * - `frameGroup`: Shared uniform buffer, updated once per frame.\n *\n * @augments Node\n */\nclass UniformGroupNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'UniformGroupNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform group node.\n\t *\n\t * @param {string} name - The name of the uniform group node.\n\t * @param {boolean} [shared=false] - Whether this uniform group node is shared or not.\n\t * @param {number} [order=1] - Influences the internal sorting.\n\t */\n\tconstructor( name, shared = false, order = 1 ) {\n\n\t\tsuper( 'string' );\n\n\t\t/**\n\t\t * The name of the uniform group node.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Whether this uniform group node is shared or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.shared = shared;\n\n\t\t/**\n\t\t * Influences the internal sorting.\n\t\t * TODO: Add details when this property should be changed.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.order = order;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformGroup = true;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.name = this.name;\n\t\tdata.version = this.version;\n\t\tdata.shared = this.shared;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.name = data.name;\n\t\tthis.version = data.version;\n\t\tthis.shared = data.shared;\n\n\t}\n\n}\n\nexport default UniformGroupNode;\n\n/**\n * TSL function for creating a uniform group node with the given name.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the uniform group node.\n * @returns {UniformGroupNode}\n */\nexport const uniformGroup = ( name ) => new UniformGroupNode( name );\n\n/**\n * TSL function for creating a shared uniform group node with the given name and order.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the uniform group node.\n * @param {number} [order=0] - Influences the internal sorting.\n * @returns {UniformGroupNode}\n */\nexport const sharedUniformGroup = ( name, order = 0 ) => new UniformGroupNode( name, true, order );\n\n/**\n * TSL object that represents a shared uniform group node which is updated once per frame.\n *\n * @tsl\n * @type {UniformGroupNode}\n */\nexport const frameGroup = /*@__PURE__*/ sharedUniformGroup( 'frame' );\n\n/**\n * TSL object that represents a shared uniform group node which is updated once per render.\n *\n * @tsl\n * @type {UniformGroupNode}\n */\nexport const renderGroup = /*@__PURE__*/ sharedUniformGroup( 'render' );\n\n/**\n * TSL object that represents a uniform group node which is updated once per object.\n *\n * @tsl\n * @type {UniformGroupNode}\n */\nexport const objectGroup = /*@__PURE__*/ uniformGroup( 'object' );\n", "import Node from '../core/Node.js';\n\n/**\n * Base class for representing element access on an array-like\n * node data structures.\n *\n * @augments Node\n */\nclass ArrayElementNode extends Node { // @TODO: If extending from TempNode it breaks webgpu_compute\n\n\tstatic get type() {\n\n\t\treturn 'ArrayElementNode';\n\n\t}\n\n\t/**\n\t * Constructs an array element node.\n\t *\n\t * @param {Node} node - The array-like node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( node, indexNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The array-like node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The index node that defines the element access.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.indexNode = indexNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayElementNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the array-like node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getElementType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst indexType = this.indexNode.getNodeType( builder );\n\n\t\tconst nodeSnippet = this.node.build( builder );\n\t\tconst indexSnippet = this.indexNode.build( builder, ! builder.isVector( indexType ) && builder.isInteger( indexType ) ? indexType : 'uint' );\n\n\t\treturn `${ nodeSnippet }[ ${ indexSnippet } ]`;\n\n\t}\n\n}\n\nexport default ArrayElementNode;\n", "import Node from '../core/Node.js';\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a convert operation during the shader generation process\n * meaning it converts the data type of a node to a target data type.\n *\n * @augments Node\n */\nclass ConvertNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ConvertNode';\n\n\t}\n\n\t/**\n\t * Constructs a new convert node.\n\t *\n\t * @param {Node} node - The node which type should be converted.\n\t * @param {string} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.\n\t */\n\tconstructor( node, convertTo ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node which type should be converted.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The target node type. Multiple types can be defined by separating them with a `|` sign.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.convertTo = convertTo;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the implementation tries to infer the best\n\t * matching type from the {@link ConvertNode#convertTo} property.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst requestType = this.node.getNodeType( builder );\n\n\t\tlet convertTo = null;\n\n\t\tfor ( const overloadingType of this.convertTo.split( '|' ) ) {\n\n\t\t\tif ( convertTo === null || builder.getTypeLength( requestType ) === builder.getTypeLength( overloadingType ) ) {\n\n\t\t\t\tconvertTo = overloadingType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn convertTo;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.convertTo = this.convertTo;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.convertTo = data.convertTo;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst snippet = node.build( builder, type );\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\nexport default ConvertNode;\n", "import TempNode from '../core/TempNode.js';\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a join operation during the shader generation process.\n * For example in can compose/join two single floats into a `vec2` type.\n *\n * @augments TempNode\n */\nclass JoinNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'JoinNode';\n\n\t}\n\n\t/**\n\t * Constructs a new join node.\n\t *\n\t * @param {Array<Node>} nodes - An array of nodes that should be joined.\n\t * @param {?string} [nodeType=null] - The node type.\n\t */\n\tconstructor( nodes = [], nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * An array of nodes that should be joined.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type must be inferred from the\n\t * joined data length if not explicitly defined.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.nodeType !== null ) {\n\n\t\t\treturn builder.getVectorType( this.nodeType );\n\n\t\t}\n\n\t\treturn builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst maxLength = builder.getTypeLength( type );\n\n\t\tconst nodes = this.nodes;\n\n\t\tconst primitiveType = builder.getComponentType( type );\n\n\t\tconst snippetValues = [];\n\n\t\tlet length = 0;\n\n\t\tfor ( const input of nodes ) {\n\n\t\t\tif ( length >= maxLength ) {\n\n\t\t\t\tconsole.error( `THREE.TSL: Length of parameters exceeds maximum length of function '${ type }()' type.` );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlet inputType = input.getNodeType( builder );\n\t\t\tlet inputTypeLength = builder.getTypeLength( inputType );\n\t\t\tlet inputSnippet;\n\n\t\t\tif ( length + inputTypeLength > maxLength ) {\n\n\t\t\t\tconsole.error( `THREE.TSL: Length of '${ type }()' data exceeds maximum length of output type.` );\n\n\t\t\t\tinputTypeLength = maxLength - length;\n\t\t\t\tinputType = builder.getTypeFromLength( inputTypeLength );\n\n\t\t\t}\n\n\t\t\tlength += inputTypeLength;\n\t\t\tinputSnippet = input.build( builder, inputType );\n\n\t\t\tconst inputPrimitiveType = builder.getComponentType( inputType );\n\n\t\t\tif ( inputPrimitiveType !== primitiveType ) {\n\n\t\t\t\tconst targetType = builder.getTypeFromLength( inputTypeLength, primitiveType );\n\n\t\t\t\tinputSnippet = builder.format( inputSnippet, inputType, targetType );\n\n\t\t\t}\n\n\t\t\tsnippetValues.push( inputSnippet );\n\n\t\t}\n\n\t\tconst snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\nexport default JoinNode;\n", "import Node from '../core/Node.js';\nimport { vectorComponents } from '../core/constants.js';\n\nconst _stringVectorComponents = vectorComponents.join( '' );\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * `SplitNode` represents a property access operation which means it is\n * used to implement any `.xyzw`, `.rgba` and `stpq` usage on node objects.\n * For example:\n * ```js\n * const redValue = color.r;\n * ```\n *\n * @augments Node\n */\nclass SplitNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SplitNode';\n\n\t}\n\n\t/**\n\t * Constructs a new split node.\n\t *\n\t * @param {Node} node - The node that should be accessed.\n\t * @param {string} [components='x'] - The components that should be accessed.\n\t */\n\tconstructor( node, components = 'x' ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be accessed.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The components that should be accessed.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.components = components;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSplitNode = true;\n\n\t}\n\n\t/**\n\t * Returns the vector length which is computed based on the requested components.\n\t *\n\t * @return {number} The vector length.\n\t */\n\tgetVectorLength() {\n\n\t\tlet vectorLength = this.components.length;\n\n\t\tfor ( const c of this.components ) {\n\n\t\t\tvectorLength = Math.max( vectorComponents.indexOf( c ) + 1, vectorLength );\n\n\t\t}\n\n\t\treturn vectorLength;\n\n\t}\n\n\t/**\n\t * Returns the component type of the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The component type.\n\t */\n\tgetComponentType( builder ) {\n\n\t\treturn builder.getComponentType( this.node.getNodeType( builder ) );\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from requested components.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn builder.getTypeFromLength( this.components.length, this.getComponentType( builder ) );\n\n\t}\n\n\t/**\n\t * Returns the scope of the node.\n\t *\n\t * @return {Node} The scope of the node.\n\t */\n\tgetScope() {\n\n\t\treturn this.node.getScope();\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );\n\n\t\tlet snippet = null;\n\n\t\tif ( nodeTypeLength > 1 ) {\n\n\t\t\tlet type = null;\n\n\t\t\tconst componentsLength = this.getVectorLength();\n\n\t\t\tif ( componentsLength >= nodeTypeLength ) {\n\n\t\t\t\t// needed expand the input node\n\n\t\t\t\ttype = builder.getTypeFromLength( this.getVectorLength(), this.getComponentType( builder ) );\n\n\t\t\t}\n\n\t\t\tconst nodeSnippet = node.build( builder, type );\n\n\t\t\tif ( this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice( 0, this.components.length ) ) {\n\n\t\t\t\t// unnecessary swizzle\n\n\t\t\t\tsnippet = builder.format( nodeSnippet, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// ignore .components if .node returns float/integer\n\n\t\t\tsnippet = node.build( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.components = this.components;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.components = data.components;\n\n\t}\n\n}\n\nexport default SplitNode;\n", "import TempNode from '../core/TempNode.js';\nimport { vectorComponents } from '../core/constants.js';\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * `SetNode` represents a set operation which means it is used to implement any\n * `setXYZW()`, `setRGBA()` and `setSTPQ()` method invocations on node objects.\n * For example:\n * ```js\n * materialLine.colorNode = color( 0, 0, 0 ).setR( float( 1 ) );\n * ```\n *\n * @augments TempNode\n */\nclass SetNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'SetNode';\n\n\t}\n\n\t/**\n\t * Constructs a new set node.\n\t *\n\t * @param {Node} sourceNode - The node that should be updated.\n\t * @param {string} components - The components that should be updated.\n\t * @param {Node} targetNode - The value node.\n\t */\n\tconstructor( sourceNode, components, targetNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be updated.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * The components that should be updated.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.components = components;\n\n\t\t/**\n\t\t * The value node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.targetNode = targetNode;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.sourceNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { sourceNode, components, targetNode } = this;\n\n\t\tconst sourceType = this.getNodeType( builder );\n\n\t\tconst componentType = builder.getComponentType( targetNode.getNodeType( builder ) );\n\t\tconst targetType = builder.getTypeFromLength( components.length, componentType );\n\n\t\tconst targetSnippet = targetNode.build( builder, targetType );\n\t\tconst sourceSnippet = sourceNode.build( builder, sourceType );\n\n\t\tconst length = builder.getTypeLength( sourceType );\n\t\tconst snippetValues = [];\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst component = vectorComponents[ i ];\n\n\t\t\tif ( component === components[ 0 ] ) {\n\n\t\t\t\tsnippetValues.push( targetSnippet );\n\n\t\t\t\ti += components.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tsnippetValues.push( sourceSnippet + '.' + component );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\nexport default SetNode;\n", "import TempNode from '../core/TempNode.js';\nimport { vectorComponents } from '../core/constants.js';\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a flip operation during the shader generation process\n * meaning it flips normalized values with the following formula:\n * ```\n * x = 1 - x;\n * ```\n * `FlipNode` is internally used to implement any `flipXYZW()`, `flipRGBA()` and\n * `flipSTPQ()` method invocations on node objects. For example:\n * ```js\n * uvNode = uvNode.flipY();\n * ```\n *\n * @augments TempNode\n */\nclass FlipNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FlipNode';\n\n\t}\n\n\t/**\n\t * Constructs a new flip node.\n\t *\n\t * @param {Node} sourceNode - The node which component(s) should be flipped.\n\t * @param {string} components - The components that should be flipped e.g. `'x'` or `'xy'`.\n\t */\n\tconstructor( sourceNode, components ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node which component(s) should be flipped.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * The components that should be flipped e.g. `'x'` or `'xy'`.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.components = components;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the source node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.sourceNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { components, sourceNode } = this;\n\n\t\tconst sourceType = this.getNodeType( builder );\n\t\tconst sourceSnippet = sourceNode.build( builder );\n\n\t\tconst sourceCache = builder.getVarFromNode( this );\n\t\tconst sourceProperty = builder.getPropertyName( sourceCache );\n\n\t\tbuilder.addLineFlowCode( sourceProperty + ' = ' + sourceSnippet, this );\n\n\t\tconst length = builder.getTypeLength( sourceType );\n\t\tconst snippetValues = [];\n\n\t\tlet componentIndex = 0;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst component = vectorComponents[ i ];\n\n\t\t\tif ( component === components[ componentIndex ] ) {\n\n\t\t\t\tsnippetValues.push( '1.0 - ' + ( sourceProperty + '.' + component ) );\n\n\t\t\t\tcomponentIndex ++;\n\n\t\t\t} else {\n\n\t\t\t\tsnippetValues.push( sourceProperty + '.' + component );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\nexport default FlipNode;\n", "import InputNode from './InputNode.js';\n\nconst _regNum = /float|u?int/;\n\n/**\n * Class for representing a constant value in the shader.\n *\n * @augments InputNode\n */\nclass ConstNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'ConstNode';\n\n\t}\n\n\t/**\n\t * Constructs a new input node.\n\t *\n\t * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).\n\t * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isConstNode = true;\n\n\t}\n\n\t/**\n\t * Generates the shader string of the value with the current node builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The generated value as a shader string.\n\t */\n\tgenerateConst( builder ) {\n\n\t\treturn builder.generateConst( this.getNodeType( builder ), this.value );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tif ( _regNum.test( type ) && _regNum.test( output ) ) {\n\n\t\t\treturn builder.generateConst( output, this.value );\n\n\t\t}\n\n\t\treturn builder.format( this.generateConst( builder ), type, output );\n\n\t}\n\n}\n\nexport default ConstNode;\n", "import Node from '../core/Node.js';\n\n/**\n * Base class for representing member access on an object-like\n * node data structures.\n *\n * @augments Node\n */\nclass MemberNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MemberNode';\n\n\t}\n\n\t/**\n\t * Constructs a member node.\n\t *\n\t * @param {Node} structNode - The struct node.\n\t * @param {string} property - The property name.\n\t */\n\tconstructor( structNode, property ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The struct node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.structNode = structNode;\n\n\t\t/**\n\t\t * The property name.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMemberNode = true;\n\n\t}\n\n\thasMember( builder ) {\n\n\t\tif ( this.structNode.isMemberNode ) {\n\n\t\t\tif ( this.structNode.hasMember( builder ) === false ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this.structNode.getMemberType( builder, this.property ) !== 'void';\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.hasMember( builder ) === false ) {\n\n\t\t\t// default type if member does not exist\n\n\t\t\treturn 'float';\n\n\t\t}\n\n\t\treturn this.structNode.getMemberType( builder, this.property );\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\tif ( this.hasMember( builder ) === false ) {\n\n\t\t\t// default type if member does not exist\n\n\t\t\treturn 'float';\n\n\t\t}\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst struct = builder.getStructTypeNode( type );\n\n\t\treturn struct.getMemberType( builder, name );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tif ( this.hasMember( builder ) === false ) {\n\n\t\t\tconsole.warn( `THREE.TSL: Member \"${ this.property }\" does not exist in struct.` );\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\treturn builder.generateConst( type );\n\n\t\t}\n\n\t\tconst propertyName = this.structNode.build( builder );\n\n\t\treturn propertyName + '.' + this.property;\n\n\t}\n\n}\n\nexport default MemberNode;\n", "import Node from '../core/Node.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport SetNode from '../utils/SetNode.js';\nimport FlipNode from '../utils/FlipNode.js';\nimport ConstNode from '../core/ConstNode.js';\nimport MemberNode from '../utils/MemberNode.js';\nimport { getValueFromType, getValueType } from '../core/NodeUtils.js';\n\nlet currentStack = null;\n\nconst NodeElements = new Map();\n\n// Extend Node Class for TSL using prototype\n\nexport function addMethodChaining( name, nodeElement ) {\n\n\tif ( NodeElements.has( name ) ) {\n\n\t\tconsole.warn( `THREE.TSL: Redefinition of method chaining '${ name }'.` );\n\t\treturn;\n\n\t}\n\n\tif ( typeof nodeElement !== 'function' ) throw new Error( `THREE.TSL: Node element ${ name } is not a function` );\n\n\tNodeElements.set( name, nodeElement );\n\n\tif ( name !== 'assign' ) {\n\n\t\t// Changing Node prototype to add method chaining\n\n\t\tNode.prototype[ name ] = function ( ...params ) {\n\n\t\t\t//if ( name === 'toVarIntent' ) return this;\n\n\t\t\treturn this.isStackNode ? this.add( nodeElement( ...params ) ) : nodeElement( this, ...params );\n\n\t\t};\n\n\t\t// Adding assign method chaining\n\n\t\tNode.prototype[ name + 'Assign' ] = function ( ...params ) {\n\n\t\t\treturn this.isStackNode ? this.assign( params[ 0 ], nodeElement( ...params ) ) : this.assign( nodeElement( this, ...params ) );\n\n\t\t};\n\n\t}\n\n}\n\nconst parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );\nconst parseSwizzleAndSort = ( props ) => parseSwizzle( props ).split( '' ).sort().join( '' );\n\nNode.prototype.assign = function ( ...params ) {\n\n\tif ( this.isStackNode !== true ) {\n\n\t\tif ( currentStack !== null ) {\n\n\t\t\tcurrentStack.assign( this, ...params );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.TSL: No stack defined for assign operation. Make sure the assign is inside a Fn().' );\n\n\t\t}\n\n\t\treturn this;\n\n\t} else {\n\n\t\tconst nodeElement = NodeElements.get( 'assign' );\n\n\t\treturn this.add( nodeElement( ...params ) );\n\n\t}\n\n};\n\nNode.prototype.toVarIntent = function () {\n\n\treturn this;\n\n};\n\nNode.prototype.get = function ( value ) {\n\n\treturn new MemberNode( this, value );\n\n};\n\n// Cache prototype for TSL\n\nconst proto = {};\n\n// Set swizzle properties for xyzw, rgba, and stpq.\n\nfunction setProtoSwizzle( property, altA, altB ) {\n\n\t// swizzle properties\n\n\tproto[ property ] = proto[ altA ] = proto[ altB ] = {\n\n\t\tget() {\n\n\t\t\tthis._cache = this._cache || {};\n\n\t\t\t//\n\n\t\t\tlet split = this._cache[ property ];\n\n\t\t\tif ( split === undefined ) {\n\n\t\t\t\tsplit = new SplitNode( this, property );\n\n\t\t\t\tthis._cache[ property ] = split;\n\n\t\t\t}\n\n\t\t\treturn split;\n\n\t\t},\n\n\t\tset( value ) {\n\n\t\t\tthis[ property ].assign( nodeObject( value ) );\n\n\t\t}\n\n\t};\n\n\t// set properties ( swizzle ) and sort to xyzw sequence\n\n\tconst propUpper = property.toUpperCase();\n\tconst altAUpper = altA.toUpperCase();\n\tconst altBUpper = altB.toUpperCase();\n\n\t// Set methods for swizzle properties\n\n\tNode.prototype[ 'set' + propUpper ] = Node.prototype[ 'set' + altAUpper ] = Node.prototype[ 'set' + altBUpper ] = function ( value ) {\n\n\t\tconst swizzle = parseSwizzleAndSort( property );\n\n\t\treturn new SetNode( this, swizzle, nodeObject( value ) );\n\n\t};\n\n\t// Set methods for flip properties\n\n\tNode.prototype[ 'flip' + propUpper ] = Node.prototype[ 'flip' + altAUpper ] = Node.prototype[ 'flip' + altBUpper ] = function () {\n\n\t\tconst swizzle = parseSwizzleAndSort( property );\n\n\t\treturn new FlipNode( this, swizzle );\n\n\t};\n\n}\n\nconst swizzleA = [ 'x', 'y', 'z', 'w' ];\nconst swizzleB = [ 'r', 'g', 'b', 'a' ];\nconst swizzleC = [ 's', 't', 'p', 'q' ];\n\nfor ( let a = 0; a < 4; a ++ ) {\n\n\tlet prop = swizzleA[ a ];\n\tlet altA = swizzleB[ a ];\n\tlet altB = swizzleC[ a ];\n\n\tsetProtoSwizzle( prop, altA, altB );\n\n\tfor ( let b = 0; b < 4; b ++ ) {\n\n\t\tprop = swizzleA[ a ] + swizzleA[ b ];\n\t\taltA = swizzleB[ a ] + swizzleB[ b ];\n\t\taltB = swizzleC[ a ] + swizzleC[ b ];\n\n\t\tsetProtoSwizzle( prop, altA, altB );\n\n\t\tfor ( let c = 0; c < 4; c ++ ) {\n\n\t\t\tprop = swizzleA[ a ] + swizzleA[ b ] + swizzleA[ c ];\n\t\t\taltA = swizzleB[ a ] + swizzleB[ b ] + swizzleB[ c ];\n\t\t\taltB = swizzleC[ a ] + swizzleC[ b ] + swizzleC[ c ];\n\n\t\t\tsetProtoSwizzle( prop, altA, altB );\n\n\t\t\tfor ( let d = 0; d < 4; d ++ ) {\n\n\t\t\t\tprop = swizzleA[ a ] + swizzleA[ b ] + swizzleA[ c ] + swizzleA[ d ];\n\t\t\t\taltA = swizzleB[ a ] + swizzleB[ b ] + swizzleB[ c ] + swizzleB[ d ];\n\t\t\t\taltB = swizzleC[ a ] + swizzleC[ b ] + swizzleC[ c ] + swizzleC[ d ];\n\n\t\t\t\tsetProtoSwizzle( prop, altA, altB );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// Set/get static properties for array elements (0-31).\n\nfor ( let i = 0; i < 32; i ++ ) {\n\n\tproto[ i ] = {\n\n\t\tget() {\n\n\t\t\tthis._cache = this._cache || {};\n\n\t\t\t//\n\n\t\t\tlet element = this._cache[ i ];\n\n\t\t\tif ( element === undefined ) {\n\n\t\t\t\telement = new ArrayElementNode( this, new ConstNode( i, 'uint' ) );\n\n\t\t\t\tthis._cache[ i ] = element;\n\n\t\t\t}\n\n\t\t\treturn element;\n\n\t\t},\n\n\t\tset( value ) {\n\n\t\t\tthis[ i ].assign( nodeObject( value ) );\n\n\t\t}\n\n\t};\n\n}\n\n/*\n// Set properties for width, height, and depth.\n\nfunction setProtoProperty( property, target ) {\n\n\tproto[ property ] = {\n\n\t\tget() {\n\n\t\t\tthis._cache = this._cache || {};\n\n\t\t\t//\n\n\t\t\tlet split = this._cache[ target ];\n\n\t\t\tif ( split === undefined ) {\n\n\t\t\t\tsplit = new SplitNode( this, target );\n\n\t\t\t\tthis._cache[ target ] = split;\n\n\t\t\t}\n\n\t\t\treturn split;\n\n\t\t},\n\n\t\tset( value ) {\n\n\t\t\tthis[ target ].assign( nodeObject( value ) );\n\n\t\t}\n\n\t};\n\n}\n\nsetProtoProperty( 'width', 'x' );\nsetProtoProperty( 'height', 'y' );\nsetProtoProperty( 'depth', 'z' );\n*/\n\nObject.defineProperties( Node.prototype, proto );\n\n// --- FINISH ---\n\nconst nodeBuilderFunctionsCacheMap = new WeakMap();\n\nconst ShaderNodeObject = function ( obj, altType = null ) {\n\n\tconst type = getValueType( obj );\n\n\tif ( type === 'node' ) {\n\n\t\treturn obj;\n\n\t} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {\n\n\t\treturn nodeObject( getConstNode( obj, altType ) );\n\n\t} else if ( type === 'shader' ) {\n\n\t\treturn obj.isFn ? obj : Fn( obj );\n\n\t}\n\n\treturn obj;\n\n};\n\nconst ShaderNodeObjects = function ( objects, altType = null ) {\n\n\tfor ( const name in objects ) {\n\n\t\tobjects[ name ] = nodeObject( objects[ name ], altType );\n\n\t}\n\n\treturn objects;\n\n};\n\nconst ShaderNodeArray = function ( array, altType = null ) {\n\n\tconst len = array.length;\n\n\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\tarray[ i ] = nodeObject( array[ i ], altType );\n\n\t}\n\n\treturn array;\n\n};\n\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {\n\n\tfunction assignNode( node ) {\n\n\t\tif ( settings !== null ) {\n\n\t\t\tnode = nodeObject( Object.assign( node, settings ) );\n\n\t\t\tif ( settings.intent === true ) {\n\n\t\t\t\tnode = node.toVarIntent();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tnode = nodeObject( node );\n\n\t\t}\n\n\t\treturn node;\n\n\n\t}\n\n\tlet fn, name = scope, minParams, maxParams;\n\n\tfunction verifyParamsLimit( params ) {\n\n\t\tlet tslName;\n\n\t\tif ( name ) tslName = /[a-z]/i.test( name ) ? name + '()' : name;\n\t\telse tslName = NodeClass.type;\n\n\t\tif ( minParams !== undefined && params.length < minParams ) {\n\n\t\t\tconsole.error( `THREE.TSL: \"${ tslName }\" parameter length is less than minimum required.` );\n\n\t\t\treturn params.concat( new Array( minParams - params.length ).fill( 0 ) );\n\n\t\t} else if ( maxParams !== undefined && params.length > maxParams ) {\n\n\t\t\tconsole.error( `THREE.TSL: \"${ tslName }\" parameter length exceeds limit.` );\n\n\t\t\treturn params.slice( 0, maxParams );\n\n\t\t}\n\n\t\treturn params;\n\n\t}\n\n\tif ( scope === null ) {\n\n\t\tfn = ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( ...nodeArray( verifyParamsLimit( params ) ) ) );\n\n\t\t};\n\n\t} else if ( factor !== null ) {\n\n\t\tfactor = nodeObject( factor );\n\n\t\tfn = ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( verifyParamsLimit( params ) ), factor ) );\n\n\t\t};\n\n\t} else {\n\n\t\tfn = ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( verifyParamsLimit( params ) ) ) );\n\n\t\t};\n\n\t}\n\n\tfn.setParameterLength = ( ...params ) => {\n\n\t\tif ( params.length === 1 ) minParams = maxParams = params[ 0 ];\n\t\telse if ( params.length === 2 ) [ minParams, maxParams ] = params;\n\n\t\treturn fn;\n\n\t};\n\n\tfn.setName = ( value ) => {\n\n\t\tname = value;\n\n\t\treturn fn;\n\n\t};\n\n\treturn fn;\n\n};\n\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\n\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\n\n};\n\nclass ShaderCallNodeInternal extends Node {\n\n\tconstructor( shaderNode, rawInputs ) {\n\n\t\tsuper();\n\n\t\tthis.shaderNode = shaderNode;\n\t\tthis.rawInputs = rawInputs;\n\n\t\tthis.isShaderCallNodeInternal = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.shaderNode.nodeType || this.getOutputNode( builder ).getNodeType( builder );\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.getOutputNode( builder ).getMemberType( builder, name );\n\n\t}\n\n\tcall( builder ) {\n\n\t\tconst { shaderNode, rawInputs } = this;\n\n\t\tconst properties = builder.getNodeProperties( shaderNode );\n\n\t\tconst subBuild = builder.getClosestSubBuild( shaderNode.subBuilds ) || '';\n\t\tconst subBuildProperty = subBuild || 'default';\n\n\t\tif ( properties[ subBuildProperty ] ) {\n\n\t\t\treturn properties[ subBuildProperty ];\n\n\t\t}\n\n\t\t//\n\n\t\tconst previousSubBuildFn = builder.subBuildFn;\n\n\t\tbuilder.subBuildFn = subBuild;\n\n\t\tlet result = null;\n\n\t\tif ( shaderNode.layout ) {\n\n\t\t\tlet functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get( builder.constructor );\n\n\t\t\tif ( functionNodesCacheMap === undefined ) {\n\n\t\t\t\tfunctionNodesCacheMap = new WeakMap();\n\n\t\t\t\tnodeBuilderFunctionsCacheMap.set( builder.constructor, functionNodesCacheMap );\n\n\t\t\t}\n\n\t\t\tlet functionNode = functionNodesCacheMap.get( shaderNode );\n\n\t\t\tif ( functionNode === undefined ) {\n\n\t\t\t\tfunctionNode = nodeObject( builder.buildFunctionNode( shaderNode ) );\n\n\t\t\t\tfunctionNodesCacheMap.set( shaderNode, functionNode );\n\n\t\t\t}\n\n\t\t\tbuilder.addInclude( functionNode );\n\n\t\t\t//\n\n\t\t\tconst inputs = rawInputs ? getLayoutParameters( rawInputs ) : null;\n\n\t\t\tresult = nodeObject( functionNode.call( inputs ) );\n\n\t\t} else {\n\n\t\t\tconst secureNodeBuilder = new Proxy( builder, {\n\n\t\t\t\tget: ( target, property, receiver ) => {\n\n\t\t\t\t\tlet value;\n\n\t\t\t\t\tif ( Symbol.iterator === property ) {\n\n\t\t\t\t\t\tvalue = function* () {\n\n\t\t\t\t\t\t\tyield undefined;\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvalue = Reflect.get( target, property, receiver );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t//\n\n\t\t\tconst inputs = rawInputs ? getProxyParameters( rawInputs ) : null;\n\n\t\t\tconst hasParameters = Array.isArray( rawInputs ) ? rawInputs.length > 0 : rawInputs !== null;\n\n\t\t\tconst jsFunc = shaderNode.jsFunc;\n\t\t\tconst outputNode = hasParameters || jsFunc.length > 1 ? jsFunc( inputs, secureNodeBuilder ) : jsFunc( secureNodeBuilder );\n\n\t\t\tresult = nodeObject( outputNode );\n\n\t\t}\n\n\t\tbuilder.subBuildFn = previousSubBuildFn;\n\n\t\tif ( shaderNode.once ) {\n\n\t\t\tproperties[ subBuildProperty ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tsetupOutput( builder ) {\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.call( builder );\n\n\t\treturn builder.removeStack();\n\n\t}\n\n\tgetOutputNode( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst subBuildOutput = builder.getSubBuildOutput( this );\n\n\t\tproperties[ subBuildOutput ] = properties[ subBuildOutput ] || this.setupOutput( builder );\n\t\tproperties[ subBuildOutput ].subBuild = builder.getClosestSubBuild( this );\n\n\t\treturn properties[ subBuildOutput ];\n\n\t}\n\n\tbuild( builder, output = null ) {\n\n\t\tlet result = null;\n\n\t\tconst buildStage = builder.getBuildStage();\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst subBuildOutput = builder.getSubBuildOutput( this );\n\t\tconst outputNode = this.getOutputNode( builder );\n\n\t\tif ( buildStage === 'setup' ) {\n\n\t\t\tconst subBuildInitialized = builder.getSubBuildProperty( 'initialized', this );\n\n\t\t\tif ( properties[ subBuildInitialized ] !== true ) {\n\n\t\t\t\tproperties[ subBuildInitialized ] = true;\n\n\t\t\t\tproperties[ subBuildOutput ] = this.getOutputNode( builder );\n\t\t\t\tproperties[ subBuildOutput ].build( builder );\n\n\t\t\t\t// If the shaderNode has subBuilds, add them to the chaining nodes\n\t\t\t\t// so they can be built later in the build process.\n\n\t\t\t\tif ( this.shaderNode.subBuilds ) {\n\n\t\t\t\t\tfor ( const node of builder.chaining ) {\n\n\t\t\t\t\t\tconst nodeData = builder.getDataFromNode( node, 'any' );\n\t\t\t\t\t\tnodeData.subBuilds = nodeData.subBuilds || new Set();\n\n\t\t\t\t\t\tfor ( const subBuild of this.shaderNode.subBuilds ) {\n\n\t\t\t\t\t\t\tnodeData.subBuilds.add( subBuild );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//builder.getDataFromNode( node ).subBuilds = nodeData.subBuilds;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tresult = properties[ subBuildOutput ];\n\n\t\t} else if ( buildStage === 'analyze' ) {\n\n\t\t\toutputNode.build( builder, output );\n\n\t\t} else if ( buildStage === 'generate' ) {\n\n\t\t\tresult = outputNode.build( builder, output ) || '';\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nfunction getLayoutParameters( params ) {\n\n\tlet output;\n\n\tnodeObjects( params );\n\n\tconst isArrayAsParameter = params[ 0 ] && ( params[ 0 ].isNode || Object.getPrototypeOf( params[ 0 ] ) !== Object.prototype );\n\n\tif ( isArrayAsParameter ) {\n\n\t\toutput = [ ...params ];\n\n\t} else {\n\n\t\toutput = params[ 0 ];\n\n\t}\n\n\treturn output;\n\n}\n\nfunction getProxyParameters( params ) {\n\n\tlet index = 0;\n\n\tnodeObjects( params );\n\n\treturn new Proxy( params, {\n\n\t\tget: ( target, property, receiver ) => {\n\n\t\t\tlet value;\n\n\t\t\tif ( property === 'length' ) {\n\n\t\t\t\tvalue = params.length;\n\n\t\t\t\treturn value;\n\n\t\t\t}\n\n\t\t\tif ( Symbol.iterator === property ) {\n\n\t\t\t\tvalue = function* () {\n\n\t\t\t\t\tfor ( const inputNode of params ) {\n\n\t\t\t\t\t\tyield nodeObject( inputNode );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tif ( params.length > 0 ) {\n\n\t\t\t\t\tif ( Object.getPrototypeOf( params[ 0 ] ) === Object.prototype ) {\n\n\t\t\t\t\t\tconst objectTarget = params[ 0 ];\n\n\t\t\t\t\t\tif ( objectTarget[ property ] === undefined ) {\n\n\t\t\t\t\t\t\tvalue = objectTarget[ index ++ ];\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvalue = Reflect.get( objectTarget, property, receiver );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( params[ 0 ] instanceof Node ) {\n\n\t\t\t\t\t\tif ( params[ property ] === undefined ) {\n\n\t\t\t\t\t\t\tvalue = params[ index ++ ];\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvalue = Reflect.get( params, property, receiver );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalue = Reflect.get( target, property, receiver );\n\n\t\t\t\t}\n\n\t\t\t\tvalue = nodeObject( value );\n\n\t\t\t}\n\n\t\t\treturn value;\n\n\t\t}\n\n\t} );\n\n}\n\nclass ShaderNodeInternal extends Node {\n\n\tconstructor( jsFunc, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.jsFunc = jsFunc;\n\t\tthis.layout = null;\n\n\t\tthis.global = true;\n\n\t\tthis.once = false;\n\n\t}\n\n\tsetLayout( layout ) {\n\n\t\tthis.layout = layout;\n\n\t\treturn this;\n\n\t}\n\n\tcall( rawInputs = null ) {\n\n\t\treturn nodeObject( new ShaderCallNodeInternal( this, rawInputs ) );\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.call();\n\n\t}\n\n}\n\nconst bools = [ false, true ];\nconst uints = [ 0, 1, 2, 3 ];\nconst ints = [ - 1, - 2 ];\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\n\nconst boolsCacheMap = new Map();\nfor ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\n\nconst uintsCacheMap = new Map();\nfor ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\n\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\nfor ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\n\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\nfor ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\nfor ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\n\nconst cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\n\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\n\nconst getConstNode = ( value, type ) => {\n\n\tif ( constNodesCacheMap.has( value ) ) {\n\n\t\treturn constNodesCacheMap.get( value );\n\n\t} else if ( value.isNode === true ) {\n\n\t\treturn value;\n\n\t} else {\n\n\t\treturn new ConstNode( value, type );\n\n\t}\n\n};\n\nconst ConvertType = function ( type, cacheMap = null ) {\n\n\treturn ( ...params ) => {\n\n\t\tfor ( const param of params ) {\n\n\t\t\tif ( param === undefined ) {\n\n\t\t\t\tconsole.error( `THREE.TSL: Invalid parameter for the type \"${ type }\".` );\n\n\t\t\t\treturn nodeObject( new ConstNode( 0, type ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => {\n\n\t\t\tconst paramType = typeof param;\n\n\t\t\treturn paramType !== 'object' && paramType !== 'function';\n\n\t\t} ) ) ) {\n\n\t\t\tparams = [ getValueFromType( type, ...params ) ];\n\n\t\t}\n\n\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\n\n\t\t\treturn nodeObjectIntent( cacheMap.get( params[ 0 ] ) );\n\n\t\t}\n\n\t\tif ( params.length === 1 ) {\n\n\t\t\tconst node = getConstNode( params[ 0 ], type );\n\t\t\tif ( node.nodeType === type ) return nodeObjectIntent( node );\n\t\t\treturn nodeObjectIntent( new ConvertNode( node, type ) );\n\n\t\t}\n\n\t\tconst nodes = params.map( param => getConstNode( param ) );\n\t\treturn nodeObjectIntent( new JoinNode( nodes, type ) );\n\n\t};\n\n};\n\n// exports\n\nexport const defined = ( v ) => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function\n\n// utils\n\nexport const getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;\n\n// shader node base\n\nexport function ShaderNode( jsFunc, nodeType ) {\n\n\treturn new ShaderNodeInternal( jsFunc, nodeType );\n\n}\n\nexport const nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );\nexport const nodeObjectIntent = ( val, altType = null ) => /* new */ nodeObject( val, altType ).toVarIntent();\nexport const nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );\nexport const nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );\nexport const nodeProxy = ( NodeClass, scope = null, factor = null, settings = null ) => new ShaderNodeProxy( NodeClass, scope, factor, settings );\nexport const nodeImmutable = ( NodeClass, ...params ) => new ShaderNodeImmutable( NodeClass, ...params );\nexport const nodeProxyIntent = ( NodeClass, scope = null, factor = null, settings = {} ) => new ShaderNodeProxy( NodeClass, scope, factor, { intent: true, ...settings } );\n\nlet fnId = 0;\n\nclass FnNode extends Node {\n\n\tconstructor( jsFunc, layout = null ) {\n\n\t\tsuper();\n\n\t\tlet nodeType = null;\n\n\t\tif ( layout !== null ) {\n\n\t\t\tif ( typeof layout === 'object' ) {\n\n\t\t\t\tnodeType = layout.return;\n\n\t\t\t} else {\n\n\t\t\t\tif ( typeof layout === 'string' ) {\n\n\t\t\t\t\tnodeType = layout;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.TSL: Invalid layout type.' );\n\n\t\t\t\t}\n\n\t\t\t\tlayout = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.shaderNode = new ShaderNode( jsFunc, nodeType );\n\n\t\tif ( layout !== null ) {\n\n\t\t\tthis.setLayout( layout );\n\n\t\t}\n\n\t\tthis.isFn = true;\n\n\t}\n\n\tsetLayout( layout ) {\n\n\t\tconst nodeType = this.shaderNode.nodeType;\n\n\t\tif ( typeof layout.inputs !== 'object' ) {\n\n\t\t\tconst fullLayout = {\n\t\t\t\tname: 'fn' + fnId ++,\n\t\t\t\ttype: nodeType,\n\t\t\t\tinputs: []\n\t\t\t};\n\n\t\t\tfor ( const name in layout ) {\n\n\t\t\t\tif ( name === 'return' ) continue;\n\n\t\t\t\tfullLayout.inputs.push( {\n\t\t\t\t\tname: name,\n\t\t\t\t\ttype: layout[ name ]\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tlayout = fullLayout;\n\n\t\t}\n\n\t\tthis.shaderNode.setLayout( layout );\n\n\t\treturn this;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.shaderNode.getNodeType( builder ) || 'float';\n\n\t}\n\n\tcall( ...params ) {\n\n\t\tconst fnCall = this.shaderNode.call( params );\n\n\t\tif ( this.shaderNode.nodeType === 'void' ) fnCall.toStack();\n\n\t\treturn fnCall.toVarIntent();\n\n\t}\n\n\tonce( subBuilds = null ) {\n\n\t\tthis.shaderNode.once = true;\n\t\tthis.shaderNode.subBuilds = subBuilds;\n\n\t\treturn this;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconsole.error( 'THREE.TSL: \"Fn()\" was declared but not invoked. Try calling it like \"Fn()( ...params )\".' );\n\n\t\treturn builder.generateConst( type );\n\n\t}\n\n}\n\nexport function Fn( jsFunc, layout = null ) {\n\n\tconst instance = new FnNode( jsFunc, layout );\n\n\treturn new Proxy( () => {}, {\n\n\t\tapply( target, thisArg, params ) {\n\n\t\t\treturn instance.call( ...params );\n\n\t\t},\n\n\t\tget( target, prop, receiver ) {\n\n\t\t\treturn Reflect.get( instance, prop, receiver );\n\n\t\t},\n\n\t\tset( target, prop, value, receiver ) {\n\n\t\t\treturn Reflect.set( instance, prop, value, receiver );\n\n\t\t}\n\n\t} );\n\n}\n\n//\n\nexport const setCurrentStack = ( stack ) => {\n\n\tif ( currentStack === stack ) {\n\n\t\t//throw new Error( 'Stack already defined.' );\n\n\t}\n\n\tcurrentStack = stack;\n\n};\n\nexport const getCurrentStack = () => currentStack;\n\n/**\n * Represent a conditional node using if/else statements.\n *\n * ```js\n * If( condition, function )\n * \t.ElseIf( condition, function )\n * \t.Else( function )\n * ```\n * @tsl\n * @function\n * @param {...any} params - The parameters for the conditional node.\n * @returns {StackNode} The conditional node.\n */\nexport const If = ( ...params ) => currentStack.If( ...params );\n\n/**\n * Represent a conditional node using switch/case statements.\n *\n * ```js\n * Switch( value )\n * \t.Case( 1, function )\n * \t.Case( 2, 3, 4, function )\n * \t.Default( function )\n * ```\n * @tsl\n * @function\n * @param {...any} params - The parameters for the conditional node.\n * @returns {StackNode} The conditional node.\n */\nexport const Switch = ( ...params ) => currentStack.Switch( ...params );\n\n/**\n * Add the given node to the current stack.\n *\n * @param {Node} node - The node to add.\n * @returns {Node} The node that was added to the stack.\n */\nexport function Stack( node ) {\n\n\tif ( currentStack ) currentStack.add( node );\n\n\treturn node;\n\n}\n\naddMethodChaining( 'toStack', Stack );\n\n// types\n\nexport const color = new ConvertType( 'color' );\n\nexport const float = new ConvertType( 'float', cacheMaps.float );\nexport const int = new ConvertType( 'int', cacheMaps.ints );\nexport const uint = new ConvertType( 'uint', cacheMaps.uint );\nexport const bool = new ConvertType( 'bool', cacheMaps.bool );\n\nexport const vec2 = new ConvertType( 'vec2' );\nexport const ivec2 = new ConvertType( 'ivec2' );\nexport const uvec2 = new ConvertType( 'uvec2' );\nexport const bvec2 = new ConvertType( 'bvec2' );\n\nexport const vec3 = new ConvertType( 'vec3' );\nexport const ivec3 = new ConvertType( 'ivec3' );\nexport const uvec3 = new ConvertType( 'uvec3' );\nexport const bvec3 = new ConvertType( 'bvec3' );\n\nexport const vec4 = new ConvertType( 'vec4' );\nexport const ivec4 = new ConvertType( 'ivec4' );\nexport const uvec4 = new ConvertType( 'uvec4' );\nexport const bvec4 = new ConvertType( 'bvec4' );\n\nexport const mat2 = new ConvertType( 'mat2' );\nexport const mat3 = new ConvertType( 'mat3' );\nexport const mat4 = new ConvertType( 'mat4' );\n\nexport const string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );\nexport const arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );\n\naddMethodChaining( 'toColor', color );\naddMethodChaining( 'toFloat', float );\naddMethodChaining( 'toInt', int );\naddMethodChaining( 'toUint', uint );\naddMethodChaining( 'toBool', bool );\naddMethodChaining( 'toVec2', vec2 );\naddMethodChaining( 'toIVec2', ivec2 );\naddMethodChaining( 'toUVec2', uvec2 );\naddMethodChaining( 'toBVec2', bvec2 );\naddMethodChaining( 'toVec3', vec3 );\naddMethodChaining( 'toIVec3', ivec3 );\naddMethodChaining( 'toUVec3', uvec3 );\naddMethodChaining( 'toBVec3', bvec3 );\naddMethodChaining( 'toVec4', vec4 );\naddMethodChaining( 'toIVec4', ivec4 );\naddMethodChaining( 'toUVec4', uvec4 );\naddMethodChaining( 'toBVec4', bvec4 );\naddMethodChaining( 'toMat2', mat2 );\naddMethodChaining( 'toMat3', mat3 );\naddMethodChaining( 'toMat4', mat4 );\n\n// basic nodes\n\nexport const element = /*@__PURE__*/ nodeProxy( ArrayElementNode ).setParameterLength( 2 );\nexport const convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );\nexport const split = ( node, channels ) => nodeObject( new SplitNode( nodeObject( node ), channels ) );\n\naddMethodChaining( 'element', element );\naddMethodChaining( 'convert', convert );\n\n// deprecated\n\n/**\n * @tsl\n * @function\n * @deprecated since r176. Use {@link Stack} instead.\n *\n * @param {Node} node - The node to add.\n * @returns {Function}\n */\nexport const append = ( node ) => { // @deprecated, r176\n\n\tconsole.warn( 'THREE.TSL: append() has been renamed to Stack().' );\n\treturn Stack( node );\n\n};\n\naddMethodChaining( 'append', ( node ) => { // @deprecated, r176\n\n\tconsole.warn( 'THREE.TSL: .append() has been renamed to .toStack().' );\n\treturn Stack( node );\n\n} );\n\n", "import InputNode from './InputNode.js';\nimport { objectGroup } from './UniformGroupNode.js';\nimport { nodeObject, getConstNodeType } from '../tsl/TSLCore.js';\nimport { getValueFromType } from './NodeUtils.js';\n\n/**\n * Class for representing a uniform.\n *\n * @augments InputNode\n */\nclass UniformNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform node.\n\t *\n\t * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).\n\t * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformNode = true;\n\n\t\t/**\n\t\t * The name or label of the uniform.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = '';\n\n\t\t/**\n\t\t * The uniform group of this uniform. By default, uniforms are\n\t\t * managed per object but they might belong to a shared group\n\t\t * which is updated per frame or render call.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = objectGroup;\n\n\t}\n\n\t/**\n\t * Sets the {@link UniformNode#name} property.\n\t *\n\t * @param {string} name - The name of the uniform.\n\t * @return {UniformNode} A reference to this node.\n\t */\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the {@link UniformNode#name} property.\n\t *\n\t * @deprecated\n\t * @param {string} name - The name of the uniform.\n\t * @return {UniformNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\tconsole.warn( 'THREE.TSL: \"label()\" has been deprecated. Use \"setName()\" instead.' ); // @deprecated r179\n\n\t\treturn this.setName( name );\n\n\t}\n\n\t/**\n\t * Sets the {@link UniformNode#groupNode} property.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group.\n\t * @return {UniformNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.groupNode = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the {@link UniformNode#groupNode}.\n\t *\n\t * @return {UniformGroupNode} The uniform group.\n\t */\n\tgetGroup() {\n\n\t\treturn this.groupNode;\n\n\t}\n\n\t/**\n\t * By default, this method returns the result of {@link Node#getHash} but derived\n\t * classes might overwrite this method with a different implementation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The uniform hash.\n\t */\n\tgetUniformHash( builder ) {\n\n\t\treturn this.getHash( builder );\n\n\t}\n\n\tonUpdate( callback, updateType ) {\n\n\t\tcallback = callback.bind( this );\n\n\t\treturn super.onUpdate( ( frame ) => {\n\n\t\t\tconst value = callback( frame, this );\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\tthis.value = value;\n\n\t\t\t}\n\n\t \t}, updateType );\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\tlet type = super.getInputType( builder );\n\n\t\tif ( type === 'bool' ) {\n\n\t\t\ttype = 'uint';\n\n\t\t}\n\n\t\treturn type;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst hash = this.getUniformHash( builder );\n\n\t\tlet sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode === undefined ) {\n\n\t\t\tbuilder.setHashNode( this, hash );\n\n\t\t\tsharedNode = this;\n\n\t\t}\n\n\t\tconst sharedNodeType = sharedNode.getInputType( builder );\n\n\t\tconst nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.nodeName );\n\t\tconst uniformName = builder.getPropertyName( nodeUniform );\n\n\t\tif ( builder.context.nodeName !== undefined ) delete builder.context.nodeName;\n\n\t\t//\n\n\t\tlet snippet = uniformName;\n\n\t\tif ( type === 'bool' ) {\n\n\t\t\t// cache to variable\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, null, 'bool' );\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\tsnippet = builder.format( uniformName, sharedNodeType, type );\n\n\t\t\t\tbuilder.addLineFlowCode( `${ propertyName } = ${ snippet }`, this );\n\n\t\t\t}\n\n\t\t\tsnippet = propertyName;\n\n\t\t}\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\nexport default UniformNode;\n\n/**\n * TSL function for creating a uniform node.\n *\n * @tsl\n * @function\n * @param {any|string} value - The value of this uniform or your type. Usually a JS primitive or three.js object (vector, matrix, color, texture).\n * @param {string} [type] - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n * @returns {UniformNode}\n */\nexport const uniform = ( value, type ) => {\n\n\tconst nodeType = getConstNodeType( type || value );\n\n\tif ( nodeType === value ) {\n\n\t\t// if the value is a type but no having a value\n\n\t\tvalue = getValueFromType( nodeType );\n\n\t}\n\n\t// @TODO: get ConstNode from .traverse() in the future\n\tvalue = ( value && value.isNode === true ) ? ( value.node && value.node.value ) || value.value : value;\n\n\treturn nodeObject( new UniformNode( value, nodeType ) );\n\n};\n", "import TempNode from './TempNode.js';\nimport { addMethodChaining, nodeObject } from '../tsl/TSLCore.js';\n\n/**\n * ArrayNode represents a collection of nodes, typically created using the {@link array} function.\n * ```js\n * const colors = array( [\n * \tvec3( 1, 0, 0 ),\n * \tvec3( 0, 1, 0 ),\n * \tvec3( 0, 0, 1 )\n * ] );\n *\n * const redColor = tintColors.element( 0 );\n *\n * @augments TempNode\n */\nclass ArrayNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ArrayNode';\n\n\t}\n\n\t/**\n\t * Constructs a new array node.\n\t *\n\t * @param {?string} nodeType - The data type of the elements.\n\t * @param {number} count - Size of the array.\n\t * @param {?Array<Node>} [values=null] - Array default values.\n\t */\n\tconstructor( nodeType, count, values = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * Array size.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * Array default values.\n\t\t *\n\t\t * @type {?Array<Node>}\n\t\t */\n\t\tthis.values = values;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayNode = true;\n\n\t}\n\n\t/**\n\t * Returns the number of elements in the node array.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {number} The number of elements in the node array.\n\t */\n\tgetArrayCount( /*builder*/ ) {\n\n\t\treturn this.count;\n\n\t}\n\n\t/**\n\t * Returns the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The type of the node.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.nodeType === null ) {\n\n\t\t\tthis.nodeType = this.values[ 0 ].getNodeType( builder );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * Returns the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The type of the node.\n\t */\n\tgetElementType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * This method builds the output node and returns the resulting array as a shader string.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The generated shader string.\n\t */\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\treturn builder.generateArray( type, this.count, this.values );\n\n\t}\n\n}\n\nexport default ArrayNode;\n\n/**\n * TSL function for creating an array node.\n *\n * @tsl\n * @function\n * @param {string|Array<Node>} nodeTypeOrValues - A string representing the element type (e.g., 'vec3')\n * or an array containing the default values (e.g., [ vec3() ]).\n * @param {?number} [count] - Size of the array.\n * @returns {ArrayNode}\n */\nexport const array = ( ...params ) => {\n\n\tlet node;\n\n\tif ( params.length === 1 ) {\n\n\t\tconst values = params[ 0 ];\n\n\t\tnode = new ArrayNode( null, values.length, values );\n\n\t} else {\n\n\t\tconst nodeType = params[ 0 ];\n\t\tconst count = params[ 1 ];\n\n\t\tnode = new ArrayNode( nodeType, count );\n\n\t}\n\n\treturn nodeObject( node );\n\n};\n\naddMethodChaining( 'toArray', ( node, count ) => array( Array( count ).fill( node ) ) );\n", "import Node from './Node.js';\nimport { nodeImmutable, nodeObject } from '../tsl/TSLCore.js';\n\n/**\n * This class represents a shader property. It can be used\n * to explicitly define a property and assign a value to it.\n *\n * ```js\n * const threshold = property( 'float', 'threshold' ).assign( THRESHOLD );\n *```\n * `PropertyNode` is used by the engine to predefined common material properties\n * for TSL code.\n *\n * @augments Node\n */\nclass PropertyNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'PropertyNode';\n\n\t}\n\n\t/**\n\t * Constructs a new property node.\n\t *\n\t * @param {string} nodeType - The type of the node.\n\t * @param {?string} [name=null] - The name of the property in the shader.\n\t * @param {boolean} [varying=false] - Whether this property is a varying or not.\n\t */\n\tconstructor( nodeType, name = null, varying = false ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The name of the property in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Whether this property is a varying or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.varying = varying;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPropertyNode = true;\n\n\t\t/**\n\t\t * This flag is used for global cache.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tlet nodeVar;\n\n\t\tif ( this.varying === true ) {\n\n\t\t\tnodeVar = builder.getVaryingFromNode( this, this.name );\n\t\t\tnodeVar.needsInterpolation = true;\n\n\t\t} else {\n\n\t\t\tnodeVar = builder.getVarFromNode( this, this.name );\n\n\t\t}\n\n\t\treturn builder.getPropertyName( nodeVar );\n\n\t}\n\n}\n\nexport default PropertyNode;\n\n/**\n * TSL function for creating a property node.\n *\n * @tsl\n * @function\n * @param {string} type - The type of the node.\n * @param {?string} [name=null] - The name of the property in the shader.\n * @returns {PropertyNode}\n */\nexport const property = ( type, name ) => nodeObject( new PropertyNode( type, name ) );\n\n/**\n * TSL function for creating a varying property node.\n *\n * @tsl\n * @function\n * @param {string} type - The type of the node.\n * @param {?string} [name=null] - The name of the varying in the shader.\n * @returns {PropertyNode}\n */\nexport const varyingProperty = ( type, name ) => nodeObject( new PropertyNode( type, name, true ) );\n\n/**\n * TSL object that represents the shader variable `DiffuseColor`.\n *\n * @tsl\n * @type {PropertyNode<vec4>}\n */\nexport const diffuseColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'DiffuseColor' );\n\n/**\n * TSL object that represents the shader variable `EmissiveColor`.\n *\n * @tsl\n * @type {PropertyNode<vec3>}\n */\nexport const emissive = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'EmissiveColor' );\n\n/**\n * TSL object that represents the shader variable `Roughness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const roughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Roughness' );\n\n/**\n * TSL object that represents the shader variable `Metalness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const metalness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Metalness' );\n\n/**\n * TSL object that represents the shader variable `Clearcoat`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const clearcoat = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Clearcoat' );\n\n/**\n * TSL object that represents the shader variable `ClearcoatRoughness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const clearcoatRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'ClearcoatRoughness' );\n\n/**\n * TSL object that represents the shader variable `Sheen`.\n *\n * @tsl\n * @type {PropertyNode<vec3>}\n */\nexport const sheen = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'Sheen' );\n\n/**\n * TSL object that represents the shader variable `SheenRoughness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const sheenRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SheenRoughness' );\n\n/**\n * TSL object that represents the shader variable `Iridescence`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const iridescence = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Iridescence' );\n\n/**\n * TSL object that represents the shader variable `IridescenceIOR`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const iridescenceIOR = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceIOR' );\n\n/**\n * TSL object that represents the shader variable `IridescenceThickness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const iridescenceThickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceThickness' );\n\n/**\n * TSL object that represents the shader variable `AlphaT`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const alphaT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AlphaT' );\n\n/**\n * TSL object that represents the shader variable `Anisotropy`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const anisotropy = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Anisotropy' );\n\n/**\n * TSL object that represents the shader variable `AnisotropyT`.\n *\n * @tsl\n * @type {PropertyNode<vec3>}\n */\nexport const anisotropyT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyT' );\n\n/**\n * TSL object that represents the shader variable `AnisotropyB`.\n *\n * @tsl\n * @type {PropertyNode<vec3>}\n */\nexport const anisotropyB = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyB' );\n\n/**\n * TSL object that represents the shader variable `SpecularColor`.\n *\n * @tsl\n * @type {PropertyNode<color>}\n */\nexport const specularColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'SpecularColor' );\n\n/**\n * TSL object that represents the shader variable `SpecularF90`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const specularF90 = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SpecularF90' );\n\n/**\n * TSL object that represents the shader variable `Shininess`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const shininess = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Shininess' );\n\n/**\n * TSL object that represents the shader variable `Output`.\n *\n * @tsl\n * @type {PropertyNode<vec4>}\n */\nexport const output = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'Output' );\n\n/**\n * TSL object that represents the shader variable `dashSize`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const dashSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'dashSize' );\n\n/**\n * TSL object that represents the shader variable `gapSize`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const gapSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'gapSize' );\n\n/**\n * TSL object that represents the shader variable `pointWidth`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const pointWidth = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'pointWidth' );\n\n/**\n * TSL object that represents the shader variable `IOR`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const ior = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IOR' );\n\n/**\n * TSL object that represents the shader variable `Transmission`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const transmission = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Transmission' );\n\n/**\n * TSL object that represents the shader variable `Thickness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const thickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Thickness' );\n\n/**\n * TSL object that represents the shader variable `AttenuationDistance`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const attenuationDistance = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AttenuationDistance' );\n\n/**\n * TSL object that represents the shader variable `AttenuationColor`.\n *\n * @tsl\n * @type {PropertyNode<color>}\n */\nexport const attenuationColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'AttenuationColor' );\n\n/**\n * TSL object that represents the shader variable `Dispersion`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nexport const dispersion = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Dispersion' );\n", "import TempNode from '../core/TempNode.js';\nimport { addMethodChaining, nodeProxy } from '../tsl/TSLCore.js';\nimport { vectorComponents } from '../core/constants.js';\n\n/**\n * These node represents an assign operation. Meaning a node is assigned\n * to another node.\n *\n * @augments TempNode\n */\nclass AssignNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'AssignNode';\n\n\t}\n\n\t/**\n\t * Constructs a new assign node.\n\t *\n\t * @param {Node} targetNode - The target node.\n\t * @param {Node} sourceNode - The source type.\n\t */\n\tconstructor( targetNode, sourceNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The target node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.targetNode = targetNode;\n\n\t\t/**\n\t\t * The source node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isAssignNode = true;\n\n\t}\n\n\t/**\n\t * Whether this node is used more than once in context of other nodes. This method\n\t * is overwritten since it always returns `false` (assigns are unique).\n\t *\n\t * @return {boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.\n\t */\n\thasDependencies() {\n\n\t\treturn false;\n\n\t}\n\n\tgetNodeType( builder, output ) {\n\n\t\treturn output !== 'void' ? this.targetNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\t/**\n\t * Whether a split is required when assigning source to target. This can happen when the component length of\n\t * target and source data type does not match.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {boolean} Whether a split is required when assigning source to target.\n\t */\n\tneedsSplitAssign( builder ) {\n\n\t\tconst { targetNode } = this;\n\n\t\tif ( builder.isAvailable( 'swizzleAssign' ) === false && targetNode.isSplitNode && targetNode.components.length > 1 ) {\n\n\t\t\tconst targetLength = builder.getTypeLength( targetNode.node.getNodeType( builder ) );\n\t\t\tconst assignDifferentVector = vectorComponents.join( '' ).slice( 0, targetLength ) !== targetNode.components;\n\n\t\t\treturn assignDifferentVector;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { targetNode, sourceNode } = this;\n\n\t\tconst scope = targetNode.getScope();\n\n\t\tconst targetProperties = builder.getNodeProperties( scope );\n\t\ttargetProperties.assign = true;\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.sourceNode = sourceNode;\n\t\tproperties.targetNode = targetNode.context( { assign: true } );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { targetNode, sourceNode } = builder.getNodeProperties( this );\n\n\t\tconst needsSplitAssign = this.needsSplitAssign( builder );\n\n\t\tconst target = targetNode.build( builder );\n\t\tconst targetType = targetNode.getNodeType( builder );\n\n\t\tconst source = sourceNode.build( builder, targetType );\n\t\tconst sourceType = sourceNode.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t//\n\n\t\tlet snippet;\n\n\t\tif ( nodeData.initialized === true ) {\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else if ( needsSplitAssign ) {\n\n\t\t\tconst sourceVar = builder.getVarFromNode( this, null, targetType );\n\t\t\tconst sourceProperty = builder.getPropertyName( sourceVar );\n\n\t\t\tbuilder.addLineFlowCode( `${ sourceProperty } = ${ source }`, this );\n\n\t\t\tconst splitNode = targetNode.node;\n\t\t\tconst splitTargetNode = splitNode.node.context( { assign: true } );\n\n\t\t\tconst targetRoot = splitTargetNode.build( builder );\n\n\t\t\tfor ( let i = 0; i < splitNode.components.length; i ++ ) {\n\n\t\t\t\tconst component = splitNode.components[ i ];\n\n\t\t\t\tbuilder.addLineFlowCode( `${ targetRoot }.${ component } = ${ sourceProperty }[ ${ i } ]`, this );\n\n\t\t\t}\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsnippet = `${ target } = ${ source }`;\n\n\t\t\tif ( output === 'void' || sourceType === 'void' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\t\tsnippet = target;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tnodeData.initialized = true;\n\n\t\treturn builder.format( snippet, targetType, output );\n\n\t}\n\n}\n\nexport default AssignNode;\n\n/**\n * TSL function for creating an assign node.\n *\n * @tsl\n * @function\n * @param {Node} targetNode - The target node.\n * @param {Node} sourceNode - The source type.\n * @returns {AssignNode}\n */\nexport const assign = /*@__PURE__*/ nodeProxy( AssignNode ).setParameterLength( 2 );\n\naddMethodChaining( 'assign', assign );\n", "import TempNode from '../core/TempNode.js';\nimport { addMethodChaining, nodeArray, nodeObject, nodeObjects, float } from '../tsl/TSLCore.js';\n\n/**\n * This module represents the call of a {@link FunctionNode}. Developers are usually not confronted\n * with this module since they use the predefined TSL syntax `wgslFn` and `glslFn` which encapsulate\n * this logic.\n *\n * @augments TempNode\n */\nclass FunctionCallNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionCallNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function call node.\n\t *\n\t * @param {?FunctionNode} functionNode - The function node.\n\t * @param {Object<string, Node>} [parameters={}] - The parameters for the function call.\n\t */\n\tconstructor( functionNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The function node.\n\t\t *\n\t\t * @type {?FunctionNode}\n\t\t * @default null\n\t\t */\n\t\tthis.functionNode = functionNode;\n\n\t\t/**\n\t\t * The parameters of the function call.\n\t\t *\n\t\t * @type {Object<string, Node>}\n\t\t * @default {}\n\t\t */\n\t\tthis.parameters = parameters;\n\n\t}\n\n\t/**\n\t * Sets the parameters of the function call node.\n\t *\n\t * @param {Object<string, Node>} parameters - The parameters to set.\n\t * @return {FunctionCallNode} A reference to this node.\n\t */\n\tsetParameters( parameters ) {\n\n\t\tthis.parameters = parameters;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the parameters of the function call node.\n\t *\n\t * @return {Object<string, Node>} The parameters of this node.\n\t */\n\tgetParameters() {\n\n\t\treturn this.parameters;\n\n\t}\n\n\t/**\n\t * Returns the type of this function call node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @returns {string} The type of this node.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.functionNode.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Returns the function node of this function call node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} [name] - The name of the member.\n\t * @returns {string} The type of the member.\n\t */\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.functionNode.getMemberType( builder, name );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst params = [];\n\n\t\tconst functionNode = this.functionNode;\n\n\t\tconst inputs = functionNode.getInputs( builder );\n\t\tconst parameters = this.parameters;\n\n\t\tconst generateInput = ( node, inputNode ) => {\n\n\t\t\tconst type = inputNode.type;\n\t\t\tconst pointer = type === 'pointer';\n\n\t\t\tlet output;\n\n\t\t\tif ( pointer ) output = '&' + node.build( builder );\n\t\t\telse output = node.build( builder, type );\n\n\t\t\treturn output;\n\n\t\t};\n\n\t\tif ( Array.isArray( parameters ) ) {\n\n\t\t\tif ( parameters.length > inputs.length ) {\n\n\t\t\t\tconsole.error( 'THREE.TSL: The number of provided parameters exceeds the expected number of inputs in \\'Fn()\\'.' );\n\n\t\t\t\tparameters.length = inputs.length;\n\n\t\t\t} else if ( parameters.length < inputs.length ) {\n\n\t\t\t\tconsole.error( 'THREE.TSL: The number of provided parameters is less than the expected number of inputs in \\'Fn()\\'.' );\n\n\t\t\t\twhile ( parameters.length < inputs.length ) {\n\n\t\t\t\t\tparameters.push( float( 0 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < parameters.length; i ++ ) {\n\n\t\t\t\tparams.push( generateInput( parameters[ i ], inputs[ i ] ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const inputNode of inputs ) {\n\n\t\t\t\tconst node = parameters[ inputNode.name ];\n\n\t\t\t\tif ( node !== undefined ) {\n\n\t\t\t\t\tparams.push( generateInput( node, inputNode ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( `THREE.TSL: Input '${ inputNode.name }' not found in \\'Fn()\\'.` );\n\n\t\t\t\t\tparams.push( generateInput( float( 0 ), inputNode ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst functionName = functionNode.build( builder, 'property' );\n\n\t\treturn `${ functionName }( ${ params.join( ', ' ) } )`;\n\n\t}\n\n}\n\nexport default FunctionCallNode;\n\nexport const call = ( func, ...params ) => {\n\n\tparams = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );\n\n\treturn nodeObject( new FunctionCallNode( nodeObject( func ), params ) );\n\n};\n\naddMethodChaining( 'call', call );\n", "import { WebGLCoordinateSystem } from '../../constants.js';\nimport TempNode from '../core/TempNode.js';\nimport { addMethodChaining, Fn, int, nodeProxyIntent } from '../tsl/TSLCore.js';\n\nconst _vectorOperators = {\n\t'==': 'equal',\n\t'!=': 'notEqual',\n\t'<': 'lessThan',\n\t'>': 'greaterThan',\n\t'<=': 'lessThanEqual',\n\t'>=': 'greaterThanEqual',\n\t'%': 'mod'\n};\n\n/**\n * This node represents basic mathematical and logical operations like addition,\n * subtraction or comparisons (e.g. `equal()`).\n *\n * @augments TempNode\n */\nclass OperatorNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'OperatorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new operator node.\n\t *\n\t * @param {string} op - The operator.\n\t * @param {Node} aNode - The first input.\n\t * @param {Node} bNode - The second input.\n\t * @param {...Node} params - Additional input parameters.\n\t */\n\tconstructor( op, aNode, bNode, ...params ) {\n\n\t\tsuper();\n\n\t\tif ( params.length > 0 ) {\n\n\t\t\tlet finalOp = new OperatorNode( op, aNode, bNode );\n\n\t\t\tfor ( let i = 0; i < params.length - 1; i ++ ) {\n\n\t\t\t\tfinalOp = new OperatorNode( op, finalOp, params[ i ] );\n\n\t\t\t}\n\n\t\t\taNode = finalOp;\n\t\t\tbNode = params[ params.length - 1 ];\n\n\t\t}\n\n\t\t/**\n\t\t * The operator.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.op = op;\n\n\t\t/**\n\t\t * The first input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.aNode = aNode;\n\n\t\t/**\n\t\t * The second input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.bNode = bNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isOperatorNode = true;\n\n\t}\n\n\t/**\n\t * Returns the operator method name.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} output - The output type.\n\t * @returns {string} The operator method name.\n\t */\n\tgetOperatorMethod( builder, output ) {\n\n\t\treturn builder.getMethod( _vectorOperators[ this.op ], output );\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the operator\n\t * and the input node types.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {?string} [output=null] - The output type.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder, output = null ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst typeA = aNode.getNodeType( builder );\n\t\tconst typeB = bNode ? bNode.getNodeType( builder ) : null;\n\n\t\tif ( typeA === 'void' || typeB === 'void' ) {\n\n\t\t\treturn output || 'void';\n\n\t\t} else if ( op === '%' ) {\n\n\t\t\treturn typeA;\n\n\t\t} else if ( op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {\n\n\t\t\treturn builder.getIntegerType( typeA );\n\n\t\t} else if ( op === '!' || op === '&&' || op === '||' || op === '^^' ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\tconst typeLength = Math.max( builder.getTypeLength( typeA ), builder.getTypeLength( typeB ) );\n\n\t\t\treturn typeLength > 1 ? `bvec${ typeLength }` : 'bool';\n\n\t\t} else {\n\n\t\t\t// Handle matrix operations\n\n\t\t\tif ( builder.isMatrix( typeA ) ) {\n\n\t\t\t\tif ( typeB === 'float' ) {\n\n\t\t\t\t\treturn typeA; // matrix * scalar = matrix\n\n\t\t\t\t} else if ( builder.isVector( typeB ) ) {\n\n\t\t\t\t\treturn builder.getVectorFromMatrix( typeA ); // matrix * vector\n\n\t\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\t\treturn typeA; // matrix * matrix\n\n\t\t\t\t}\n\n\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\tif ( typeA === 'float' ) {\n\n\t\t\t\t\treturn typeB; // scalar * matrix = matrix\n\n\t\t\t\t} else if ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\treturn builder.getVectorFromMatrix( typeB ); // vector * matrix\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Handle non-matrix cases\n\n\t\t\tif ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {\n\n\t\t\t\t// anytype x anytype: use the greater length vector\n\n\t\t\t\treturn typeB;\n\n\t\t\t}\n\n\t\t\treturn typeA;\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst { aNode, bNode } = this;\n\n\t\tconst type = this.getNodeType( builder, output );\n\n\t\tlet typeA = null;\n\t\tlet typeB = null;\n\n\t\tif ( type !== 'void' ) {\n\n\t\t\ttypeA = aNode.getNodeType( builder );\n\t\t\ttypeB = bNode ? bNode.getNodeType( builder ) : null;\n\n\t\t\tif ( op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' || op === '!=' ) {\n\n\t\t\t\tif ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\ttypeB = typeA;\n\n\t\t\t\t} else if ( builder.isVector( typeB ) ) {\n\n\t\t\t\t\ttypeA = typeB;\n\n\t\t\t\t} else if ( typeA !== typeB ) {\n\n\t\t\t\t\ttypeA = typeB = 'float';\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>>' || op === '<<' ) {\n\n\t\t\t\ttypeA = type;\n\t\t\t\ttypeB = builder.changeComponentType( typeB, 'uint' );\n\n\t\t\t} else if ( op === '%' ) {\n\n\t\t\t\ttypeA = type;\n\t\t\t\ttypeB = builder.isInteger( typeA ) && builder.isInteger( typeB ) ? typeB : typeA;\n\n\t\t\t} else if ( builder.isMatrix( typeA ) ) {\n\n\t\t\t\tif ( typeB === 'float' ) {\n\n\t\t\t\t\t// Keep matrix type for typeA, but ensure typeB stays float\n\n\t\t\t\t\ttypeB = 'float';\n\n\t\t\t\t} else if ( builder.isVector( typeB ) ) {\n\n\t\t\t\t\t// matrix x vector\n\t\t\t\t\ttypeB = builder.getVectorFromMatrix( typeA );\n\n\t\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\t\t// matrix x matrix - keep both types\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttypeA = typeB = type;\n\n\t\t\t\t}\n\n\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\tif ( typeA === 'float' ) {\n\n\t\t\t\t\t// Keep matrix type for typeB, but ensure typeA stays float\n\n\t\t\t\t\ttypeA = 'float';\n\n\t\t\t\t} else if ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\t// vector x matrix\n\n\t\t\t\t\ttypeA = builder.getVectorFromMatrix( typeB );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttypeA = typeB = type;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// anytype x anytype\n\n\t\t\t\ttypeA = typeB = type;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttypeA = typeB = type;\n\n\t\t}\n\n\t\tconst a = aNode.build( builder, typeA );\n\t\tconst b = bNode ? bNode.build( builder, typeB ) : null;\n\n\t\tconst fnOpSnippet = builder.getFunctionOperator( op );\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\tconst isGLSL = builder.renderer.coordinateSystem === WebGLCoordinateSystem;\n\n\t\t\tif ( op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\t\tif ( isGLSL ) {\n\n\t\t\t\t\tif ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\t\treturn builder.format( `${ this.getOperatorMethod( builder, output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn builder.format( `( ${ a } ${ op } ${ b } )`, type, output );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// WGSL\n\n\t\t\t\t\treturn builder.format( `( ${ a } ${ op } ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '%' ) {\n\n\t\t\t\tif ( builder.isInteger( typeB ) ) {\n\n\t\t\t\t\treturn builder.format( `( ${ a } % ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `${ this.getOperatorMethod( builder, type ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '!' || op === '~' ) {\n\n\t\t\t\treturn builder.format( `(${op}${a})`, typeA, output );\n\n\t\t\t} else if ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\t// Handle matrix operations\n\n\t\t\t\tif ( builder.isMatrix( typeA ) && typeB === 'float' ) {\n\n\t\t\t\t\treturn builder.format( `( ${ b } ${ op } ${ a } )`, type, output );\n\n\t\t\t\t} else if ( typeA === 'float' && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t\treturn builder.format( `${ a } ${ op } ${ b }`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlet snippet = `( ${ a } ${ op } ${ b } )`;\n\n\t\t\t\t\tif ( ! isGLSL && type === 'bool' && builder.isVector( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t\t\tsnippet = `all${ snippet }`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn builder.format( snippet, type, output );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( typeA !== 'void' ) {\n\n\t\t\tif ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tif ( builder.isMatrix( typeA ) && typeB === 'float' ) {\n\n\t\t\t\t\treturn builder.format( `${ b } ${ op } ${ a }`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `${ a } ${ op } ${ b }`, type, output );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.op = this.op;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.op = data.op;\n\n\t}\n\n}\n\nexport default OperatorNode;\n\n/**\n * Returns the addition of two or more value.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nexport const add = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '+' ).setParameterLength( 2, Infinity ).setName( 'add' );\n\n/**\n * Returns the subtraction of two or more value.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nexport const sub = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '-' ).setParameterLength( 2, Infinity ).setName( 'sub' );\n\n/**\n * Returns the multiplication of two or more value.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nexport const mul = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '*' ).setParameterLength( 2, Infinity ).setName( 'mul' );\n\n/**\n * Returns the division of two or more value.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nexport const div = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '/' ).setParameterLength( 2, Infinity ).setName( 'div' );\n\n/**\n * Computes the remainder of dividing the first node by the second one.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const mod = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '%' ).setParameterLength( 2 ).setName( 'mod' );\n\n/**\n * Checks if two nodes are equal.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const equal = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '==' ).setParameterLength( 2 ).setName( 'equal' );\n\n/**\n * Checks if two nodes are not equal.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const notEqual = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '!=' ).setParameterLength( 2 ).setName( 'notEqual' );\n\n/**\n * Checks if the first node is less than the second.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const lessThan = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '<' ).setParameterLength( 2 ).setName( 'lessThan' );\n\n/**\n * Checks if the first node is greater than the second.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const greaterThan = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '>' ).setParameterLength( 2 ).setName( 'greaterThan' );\n\n/**\n * Checks if the first node is less than or equal to the second.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const lessThanEqual = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '<=' ).setParameterLength( 2 ).setName( 'lessThanEqual' );\n\n/**\n * Checks if the first node is greater than or equal to the second.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const greaterThanEqual = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '>=' ).setParameterLength( 2 ).setName( 'greaterThanEqual' );\n\n/**\n * Performs a logical AND operation on multiple nodes.\n *\n * @tsl\n * @function\n * @param {...Node} nodes - The input nodes to be combined using AND.\n * @returns {OperatorNode}\n */\nexport const and = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '&&' ).setParameterLength( 2, Infinity ).setName( 'and' );\n\n/**\n * Performs a logical OR operation on multiple nodes.\n *\n * @tsl\n * @function\n * @param {...Node} nodes - The input nodes to be combined using OR.\n * @returns {OperatorNode}\n */\nexport const or = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '||' ).setParameterLength( 2, Infinity ).setName( 'or' );\n\n/**\n * Performs logical NOT on a node.\n *\n * @tsl\n * @function\n * @param {Node} value - The value.\n * @returns {OperatorNode}\n */\nexport const not = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '!' ).setParameterLength( 1 ).setName( 'not' );\n\n/**\n * Performs logical XOR on two nodes.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const xor = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '^^' ).setParameterLength( 2 ).setName( 'xor' );\n\n/**\n * Performs bitwise AND on two nodes.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const bitAnd = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '&' ).setParameterLength( 2 ).setName( 'bitAnd' );\n\n/**\n * Performs bitwise NOT on a node.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const bitNot = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '~' ).setParameterLength( 2 ).setName( 'bitNot' );\n\n/**\n * Performs bitwise OR on two nodes.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const bitOr = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '|' ).setParameterLength( 2 ).setName( 'bitOr' );\n\n/**\n * Performs bitwise XOR on two nodes.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const bitXor = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '^' ).setParameterLength( 2 ).setName( 'bitXor' );\n\n/**\n * Shifts a node to the left.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to shift.\n * @param {Node} b - The value to shift.\n * @returns {OperatorNode}\n */\nexport const shiftLeft = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '<<' ).setParameterLength( 2 ).setName( 'shiftLeft' );\n\n/**\n * Shifts a node to the right.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to shift.\n * @param {Node} b - The value to shift.\n * @returns {OperatorNode}\n */\nexport const shiftRight = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '>>' ).setParameterLength( 2 ).setName( 'shiftRight' );\n\n/**\n * Increments a node by 1.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to increment.\n * @returns {OperatorNode}\n */\nexport const incrementBefore = Fn( ( [ a ] ) => {\n\n\ta.addAssign( 1 );\n\treturn a;\n\n} );\n\n/**\n * Decrements a node by 1.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to decrement.\n * @returns {OperatorNode}\n */\nexport const decrementBefore = Fn( ( [ a ] ) => {\n\n\ta.subAssign( 1 );\n\treturn a;\n\n} );\n\n/**\n * Increments a node by 1 and returns the previous value.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to increment.\n * @returns {OperatorNode}\n */\nexport const increment = /*@__PURE__*/ Fn( ( [ a ] ) => {\n\n\tconst temp = int( a ).toConst();\n\ta.addAssign( 1 );\n\treturn temp;\n\n} );\n\n/**\n * Decrements a node by 1 and returns the previous value.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to decrement.\n * @returns {OperatorNode}\n */\nexport const decrement = /*@__PURE__*/ Fn( ( [ a ] ) => {\n\n\tconst temp = int( a ).toConst();\n\ta.subAssign( 1 );\n\treturn temp;\n\n} );\n\naddMethodChaining( 'add', add );\naddMethodChaining( 'sub', sub );\naddMethodChaining( 'mul', mul );\naddMethodChaining( 'div', div );\naddMethodChaining( 'mod', mod );\naddMethodChaining( 'equal', equal );\naddMethodChaining( 'notEqual', notEqual );\naddMethodChaining( 'lessThan', lessThan );\naddMethodChaining( 'greaterThan', greaterThan );\naddMethodChaining( 'lessThanEqual', lessThanEqual );\naddMethodChaining( 'greaterThanEqual', greaterThanEqual );\naddMethodChaining( 'and', and );\naddMethodChaining( 'or', or );\naddMethodChaining( 'not', not );\naddMethodChaining( 'xor', xor );\naddMethodChaining( 'bitAnd', bitAnd );\naddMethodChaining( 'bitNot', bitNot );\naddMethodChaining( 'bitOr', bitOr );\naddMethodChaining( 'bitXor', bitXor );\naddMethodChaining( 'shiftLeft', shiftLeft );\naddMethodChaining( 'shiftRight', shiftRight );\n\naddMethodChaining( 'incrementBefore', incrementBefore );\naddMethodChaining( 'decrementBefore', decrementBefore );\naddMethodChaining( 'increment', increment );\naddMethodChaining( 'decrement', decrement );\n\n/**\n * @tsl\n * @function\n * @deprecated since r175. Use {@link mod} instead.\n *\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nexport const modInt = ( a, b ) => { // @deprecated, r175\n\n\tconsole.warn( 'THREE.TSL: \"modInt()\" is deprecated. Use \"mod( int( ... ) )\" instead.' );\n\treturn mod( int( a ), int( b ) );\n\n};\n\naddMethodChaining( 'modInt', modInt );\n", "import TempNode from '../core/TempNode.js';\nimport { sub, mul, div, mod, equal } from './OperatorNode.js';\nimport { addMethodChaining, nodeObject, nodeProxyIntent, float, vec2, vec3, vec4, Fn } from '../tsl/TSLCore.js';\nimport { WebGLCoordinateSystem, WebGPUCoordinateSystem } from '../../constants.js';\n\n/**\n * This node represents a variety of mathematical methods available in shaders.\n * They are divided into three categories:\n *\n * - Methods with one input like `sin`, `cos` or `normalize`.\n * - Methods with two inputs like `dot`, `cross` or `pow`.\n * - Methods with three inputs like `mix`, `clamp` or `smoothstep`.\n *\n * @augments TempNode\n */\nclass MathNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'MathNode';\n\n\t}\n\n\t/**\n\t * Constructs a new math node.\n\t *\n\t * @param {string} method - The method name.\n\t * @param {Node} aNode - The first input.\n\t * @param {?Node} [bNode=null] - The second input.\n\t * @param {?Node} [cNode=null] - The third input.\n\t */\n\tconstructor( method, aNode, bNode = null, cNode = null ) {\n\n\t\tsuper();\n\n\t\t// Allow the max() and min() functions to take an arbitrary number of arguments.\n\n\t\tif ( ( method === MathNode.MAX || method === MathNode.MIN ) && arguments.length > 3 ) {\n\n\t\t\tlet finalOp = new MathNode( method, aNode, bNode );\n\n\t\t\tfor ( let i = 2; i < arguments.length - 1; i ++ ) {\n\n\t\t\t\tfinalOp = new MathNode( method, finalOp, arguments[ i ] );\n\n\t\t\t}\n\n\t\t\taNode = finalOp;\n\t\t\tbNode = arguments[ arguments.length - 1 ];\n\t\t\tcNode = null;\n\n\t\t}\n\n\t\t/**\n\t\t * The method name.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.method = method;\n\n\t\t/**\n\t\t * The first input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.aNode = aNode;\n\n\t\t/**\n\t\t * The second input.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.bNode = bNode;\n\n\t\t/**\n\t\t * The third input.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.cNode = cNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMathNode = true;\n\n\t}\n\n\t/**\n\t * The input type is inferred from the node types of the input nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\tconst aType = this.aNode.getNodeType( builder );\n\t\tconst bType = this.bNode ? this.bNode.getNodeType( builder ) : null;\n\t\tconst cType = this.cNode ? this.cNode.getNodeType( builder ) : null;\n\n\t\tconst aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );\n\t\tconst bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );\n\t\tconst cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );\n\n\t\tif ( aLen > bLen && aLen > cLen ) {\n\n\t\t\treturn aType;\n\n\t\t} else if ( bLen > cLen ) {\n\n\t\t\treturn bType;\n\n\t\t} else if ( cLen > aLen ) {\n\n\t\t\treturn cType;\n\n\t\t}\n\n\t\treturn aType;\n\n\t}\n\n\t/**\n\t * The selected method as well as the input type determine the node type of this node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tif ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {\n\n\t\t\treturn 'float';\n\n\t\t} else if ( method === MathNode.CROSS ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else if ( method === MathNode.ALL || method === MathNode.ANY ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( method === MathNode.EQUALS ) {\n\n\t\t\treturn builder.changeComponentType( this.aNode.getNodeType( builder ), 'bool' );\n\n\t\t} else {\n\n\t\t\treturn this.getInputType( builder );\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { aNode, bNode, method } = this;\n\n\t\tlet outputNode = null;\n\n\t\tif ( method === MathNode.ONE_MINUS ) {\n\n\t\t\toutputNode = sub( 1.0, aNode );\n\n\t\t} else if ( method === MathNode.RECIPROCAL ) {\n\n\t\t\toutputNode = div( 1.0, aNode );\n\n\t\t} else if ( method === MathNode.DIFFERENCE ) {\n\n\t\t\toutputNode = abs( sub( aNode, bNode ) );\n\n\t\t} else if ( method === MathNode.TRANSFORM_DIRECTION ) {\n\n\t\t\t// dir can be either a direction vector or a normal vector\n\t\t\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\t\t\tlet tA = aNode;\n\t\t\tlet tB = bNode;\n\n\t\t\tif ( builder.isMatrix( tA.getNodeType( builder ) ) ) {\n\n\t\t\t\ttB = vec4( vec3( tB ), 0.0 );\n\n\t\t\t} else {\n\n\t\t\t\ttA = vec4( vec3( tA ), 0.0 );\n\n\t\t\t}\n\n\t\t\tconst mulNode = mul( tA, tB ).xyz;\n\n\t\t\toutputNode = normalize( mulNode );\n\n\t\t}\n\n\t\tif ( outputNode !== null ) {\n\n\t\t\treturn outputNode;\n\n\t\t} else {\n\n\t\t\treturn super.setup( builder );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.outputNode ) {\n\n\t\t\treturn super.generate( builder, output );\n\n\t\t}\n\n\t\tlet method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.aNode;\n\t\tconst b = this.bNode;\n\t\tconst c = this.cNode;\n\n\t\tconst coordinateSystem = builder.renderer.coordinateSystem;\n\n\t\tif ( method === MathNode.NEGATE ) {\n\n\t\t\treturn builder.format( '( - ' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else {\n\n\t\t\tconst params = [];\n\n\t\t\tif ( method === MathNode.CROSS ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, type ),\n\t\t\t\t\tb.build( builder, type )\n\t\t\t\t);\n\n\t\t\t} else if ( coordinateSystem === WebGLCoordinateSystem && method === MathNode.STEP ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),\n\t\t\t\t\tb.build( builder, inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( coordinateSystem === WebGLCoordinateSystem && ( method === MathNode.MIN || method === MathNode.MAX ) ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.REFRACT ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, 'float' )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.MIX ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tif ( coordinateSystem === WebGPUCoordinateSystem && method === MathNode.ATAN && b !== null ) {\n\n\t\t\t\t\tmethod = 'atan2';\n\n\t\t\t\t}\n\n\t\t\t\tif ( builder.shaderStage !== 'fragment' && ( method === MathNode.DFDX || method === MathNode.DFDY ) ) {\n\n\t\t\t\t\tconsole.warn( `THREE.TSL: '${ method }' is not supported in the ${ builder.shaderStage } stage.` );\n\n\t\t\t\t\tmethod = '/*' + method + '*/';\n\n\t\t\t\t}\n\n\t\t\t\tparams.push( a.build( builder, inputType ) );\n\t\t\t\tif ( b !== null ) params.push( b.build( builder, inputType ) );\n\t\t\t\tif ( c !== null ) params.push( c.build( builder, inputType ) );\n\n\t\t\t}\n\n\t\t\treturn builder.format( `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`, type, output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.method = this.method;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.method = data.method;\n\n\t}\n\n}\n\n// 1 input\n\nMathNode.ALL = 'all';\nMathNode.ANY = 'any';\n\nMathNode.RADIANS = 'radians';\nMathNode.DEGREES = 'degrees';\nMathNode.EXP = 'exp';\nMathNode.EXP2 = 'exp2';\nMathNode.LOG = 'log';\nMathNode.LOG2 = 'log2';\nMathNode.SQRT = 'sqrt';\nMathNode.INVERSE_SQRT = 'inversesqrt';\nMathNode.FLOOR = 'floor';\nMathNode.CEIL = 'ceil';\nMathNode.NORMALIZE = 'normalize';\nMathNode.FRACT = 'fract';\nMathNode.SIN = 'sin';\nMathNode.COS = 'cos';\nMathNode.TAN = 'tan';\nMathNode.ASIN = 'asin';\nMathNode.ACOS = 'acos';\nMathNode.ATAN = 'atan';\nMathNode.ABS = 'abs';\nMathNode.SIGN = 'sign';\nMathNode.LENGTH = 'length';\nMathNode.NEGATE = 'negate';\nMathNode.ONE_MINUS = 'oneMinus';\nMathNode.DFDX = 'dFdx';\nMathNode.DFDY = 'dFdy';\nMathNode.ROUND = 'round';\nMathNode.RECIPROCAL = 'reciprocal';\nMathNode.TRUNC = 'trunc';\nMathNode.FWIDTH = 'fwidth';\nMathNode.TRANSPOSE = 'transpose';\nMathNode.DETERMINANT = 'determinant';\nMathNode.INVERSE = 'inverse';\n\n// 2 inputs\n\nMathNode.EQUALS = 'equals';\nMathNode.MIN = 'min';\nMathNode.MAX = 'max';\nMathNode.STEP = 'step';\nMathNode.REFLECT = 'reflect';\nMathNode.DISTANCE = 'distance';\nMathNode.DIFFERENCE = 'difference';\nMathNode.DOT = 'dot';\nMathNode.CROSS = 'cross';\nMathNode.POW = 'pow';\nMathNode.TRANSFORM_DIRECTION = 'transformDirection';\n\n// 3 inputs\n\nMathNode.MIX = 'mix';\nMathNode.CLAMP = 'clamp';\nMathNode.REFRACT = 'refract';\nMathNode.SMOOTHSTEP = 'smoothstep';\nMathNode.FACEFORWARD = 'faceforward';\n\nexport default MathNode;\n\n// 1 inputs\n\n/**\n * A small value used to handle floating-point precision errors.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const EPSILON = /*@__PURE__*/ float( 1e-6 );\n\n/**\n * Represents infinity.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const INFINITY = /*@__PURE__*/ float( 1e6 );\n\n/**\n * Represents PI.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const PI = /*@__PURE__*/ float( Math.PI );\n\n/**\n * Represents PI * 2.\n *\n * @tsl\n * @type {Node<float>}\n */\nexport const PI2 = /*@__PURE__*/ float( Math.PI * 2 );\n\n/**\n * Returns `true` if all components of `x` are `true`.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node<bool>}\n */\nexport const all = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ALL ).setParameterLength( 1 );\n\n/**\n * Returns `true` if any components of `x` are `true`.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node<bool>}\n */\nexport const any = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ANY ).setParameterLength( 1 );\n\n/**\n * Converts a quantity in degrees to radians.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The input in degrees.\n * @returns {Node}\n */\nexport const radians = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.RADIANS ).setParameterLength( 1 );\n\n/**\n * Convert a quantity in radians to degrees.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The input in radians.\n * @returns {Node}\n */\nexport const degrees = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DEGREES ).setParameterLength( 1 );\n\n/**\n * Returns the natural exponentiation of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const exp = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.EXP ).setParameterLength( 1 );\n\n/**\n * Returns 2 raised to the power of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const exp2 = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.EXP2 ).setParameterLength( 1 );\n\n/**\n * Returns the natural logarithm of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const log = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.LOG ).setParameterLength( 1 );\n\n/**\n * Returns the base 2 logarithm of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const log2 = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.LOG2 ).setParameterLength( 1 );\n\n/**\n * Returns the square root of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const sqrt = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.SQRT ).setParameterLength( 1 );\n\n/**\n * Returns the inverse of the square root of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const inverseSqrt = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.INVERSE_SQRT ).setParameterLength( 1 );\n\n/**\n * Finds the nearest integer less than or equal to the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const floor = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.FLOOR ).setParameterLength( 1 );\n\n/**\n * Finds the nearest integer that is greater than or equal to the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const ceil = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.CEIL ).setParameterLength( 1 );\n\n/**\n * Calculates the unit vector in the same direction as the original vector.\n *\n * @tsl\n * @function\n * @param {Node} x - The input vector.\n * @returns {Node}\n */\nexport const normalize = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.NORMALIZE ).setParameterLength( 1 );\n\n/**\n * Computes the fractional part of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const fract = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.FRACT ).setParameterLength( 1 );\n\n/**\n * Returns the sine of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const sin = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.SIN ).setParameterLength( 1 );\n\n/**\n * Returns the cosine of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const cos = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.COS ).setParameterLength( 1 );\n\n/**\n * Returns the tangent of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const tan = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.TAN ).setParameterLength( 1 );\n\n/**\n * Returns the arcsine of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const asin = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ASIN ).setParameterLength( 1 );\n\n/**\n * Returns the arccosine of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const acos = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ACOS ).setParameterLength( 1 );\n\n/**\n * Returns the arc-tangent of the parameter.\n * If two parameters are provided, the result is `atan2(y/x)`.\n *\n * @tsl\n * @function\n * @param {Node | number} y - The y parameter.\n * @param {?(Node | number)} x - The x parameter.\n * @returns {Node}\n */\nexport const atan = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ATAN ).setParameterLength( 1, 2 );\n\n/**\n * Returns the absolute value of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const abs = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ABS ).setParameterLength( 1 );\n\n/**\n * Extracts the sign of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const sign = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.SIGN ).setParameterLength( 1 );\n\n/**\n * Calculates the length of a vector.\n *\n * @tsl\n * @function\n * @param {Node} x - The parameter.\n * @returns {Node<float>}\n */\nexport const length = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.LENGTH ).setParameterLength( 1 );\n\n/**\n * Negates the value of the parameter (-x).\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const negate = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.NEGATE ).setParameterLength( 1 );\n\n/**\n * Return `1` minus the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const oneMinus = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ONE_MINUS ).setParameterLength( 1 );\n\n/**\n * Returns the partial derivative of the parameter with respect to x.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const dFdx = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DFDX ).setParameterLength( 1 );\n\n/**\n * Returns the partial derivative of the parameter with respect to y.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const dFdy = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DFDY ).setParameterLength( 1 );\n\n/**\n * Rounds the parameter to the nearest integer.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const round = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ROUND ).setParameterLength( 1 );\n\n/**\n * Returns the reciprocal of the parameter `(1/x)`.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const reciprocal = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.RECIPROCAL ).setParameterLength( 1 );\n\n/**\n * Truncates the parameter, removing the fractional part.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const trunc = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.TRUNC ).setParameterLength( 1 );\n\n/**\n * Returns the sum of the absolute derivatives in x and y.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nexport const fwidth = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.FWIDTH ).setParameterLength( 1 );\n\n/**\n * Returns the transpose of a matrix.\n *\n * @tsl\n * @function\n * @param {Node<mat2|mat3|mat4>} x - The parameter.\n * @returns {Node}\n */\nexport const transpose = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.TRANSPOSE ).setParameterLength( 1 );\n\n/**\n * Returns the determinant of a matrix.\n *\n * @tsl\n * @function\n * @param {Node<mat2|mat3|mat4>} x - The parameter.\n * @returns {Node<float>}\n */\nexport const determinant = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DETERMINANT ).setParameterLength( 1 );\n\n/**\n * Returns the inverse of a matrix.\n *\n * @tsl\n * @function\n * @param {Node<mat2|mat3|mat4>} x - The parameter.\n * @returns {Node<mat2|mat3|mat4>}\n */\nexport const inverse = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.INVERSE ).setParameterLength( 1 );\n\n// 2 inputs\n\n/**\n * Returns `true` if `x` equals `y`.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @param {Node | number} y - The second parameter.\n * @deprecated since r175. Use {@link equal} instead.\n * @returns {Node<bool>}\n */\nexport const equals = ( x, y ) => { // @deprecated, r172\n\n\tconsole.warn( 'THREE.TSL: \"equals\" is deprecated. Use \"equal\" inside a vector instead, like: \"bvec*( equal( ... ) )\"' );\n\treturn equal( x, y );\n\n};\n\n/**\n * Returns the least of the given values.\n *\n * @tsl\n * @function\n * @param {...(Node | number)} values - The values to compare.\n * @returns {Node}\n */\nexport const min = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.MIN ).setParameterLength( 2, Infinity );\n\n/**\n * Returns the greatest of the given values.\n *\n * @tsl\n * @function\n * @param {...(Node | number)} values - The values to compare.\n * @returns {Node}\n */\nexport const max = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.MAX ).setParameterLength( 2, Infinity );\n\n/**\n * Generate a step function by comparing two values.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The y parameter.\n * @param {Node | number} y - The x parameter.\n * @returns {Node}\n */\nexport const step = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.STEP ).setParameterLength( 2 );\n\n/**\n * Calculates the reflection direction for an incident vector.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} N - The normal vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nexport const reflect = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.REFLECT ).setParameterLength( 2 );\n\n/**\n * Calculates the distance between two points.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first point.\n * @param {Node<vec2|vec3|vec4>} y - The second point.\n * @returns {Node<float>}\n */\nexport const distance = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DISTANCE ).setParameterLength( 2 );\n\n/**\n * Calculates the absolute difference between two values.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @param {Node | number} y - The second parameter.\n * @returns {Node}\n */\nexport const difference = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DIFFERENCE ).setParameterLength( 2 );\n\n/**\n * Calculates the dot product of two vectors.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first vector.\n * @param {Node<vec2|vec3|vec4>} y - The second vector.\n * @returns {Node<float>}\n */\nexport const dot = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DOT ).setParameterLength( 2 );\n\n/**\n * Calculates the cross product of two vectors.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3>} x - The first vector.\n * @param {Node<vec2|vec3>} y - The second vector.\n * @returns {Node<float|vec3>}\n */\nexport const cross = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.CROSS ).setParameterLength( 2 );\n\n/**\n * Return the value of the first parameter raised to the power of the second one.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @param {Node | number} y - The second parameter.\n * @returns {Node}\n */\nexport const pow = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.POW ).setParameterLength( 2 );\n\n/**\n * Returns the square of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @returns {Node}\n */\nexport const pow2 = ( x ) => mul( x, x );\n\n/**\n * Returns the cube of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @returns {Node}\n */\nexport const pow3 = ( x ) => mul( x, x, x );\n\n/**\n * Returns the fourth power of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @returns {Node}\n */\nexport const pow4 = ( x ) => mul( x, x, x, x );\n\n/**\n * Transforms the direction of a vector by a matrix and then normalizes the result.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} direction - The direction vector.\n * @param {Node<mat2|mat3|mat4>} matrix - The transformation matrix.\n * @returns {Node}\n */\nexport const transformDirection = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.TRANSFORM_DIRECTION ).setParameterLength( 2 );\n\n/**\n * Returns the cube root of a number.\n *\n * @tsl\n * @function\n * @param {Node | number} a - The first parameter.\n * @returns {Node}\n */\nexport const cbrt = ( a ) => mul( sign( a ), pow( abs( a ), 1.0 / 3.0 ) );\n\n/**\n * Calculate the squared length of a vector.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} a - The vector.\n * @returns {Node<float>}\n */\nexport const lengthSq = ( a ) => dot( a, a );\n\n/**\n * Linearly interpolates between two values.\n *\n * @tsl\n * @function\n * @param {Node | number} a - The first parameter.\n * @param {Node | number} b - The second parameter.\n * @param {Node | number} t - The interpolation value.\n * @returns {Node}\n */\nexport const mix = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.MIX ).setParameterLength( 3 );\n\n/**\n * Constrains a value to lie between two further values.\n *\n * @tsl\n * @function\n * @param {Node | number} value - The value to constrain.\n * @param {Node | number} [low=0] - The lower bound.\n * @param {Node | number} [high=1] - The upper bound.\n * @returns {Node}\n */\nexport const clamp = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );\n\n/**\n * Constrains a value between `0` and `1`.\n *\n * @tsl\n * @function\n * @param {Node | number} value - The value to constrain.\n * @returns {Node}\n */\nexport const saturate = ( value ) => clamp( value );\n\n/**\n * Calculates the refraction direction for an incident vector.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} N - The normal vector.\n * @param {Node<float>} eta - The ratio of indices of refraction.\n * @returns {Node<vec2|vec3|vec4>}\n */\nexport const refract = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.REFRACT ).setParameterLength( 3 );\n\n/**\n * Performs a Hermite interpolation between two values.\n *\n * @tsl\n * @function\n * @param {Node | number} low - The value of the lower edge of the Hermite function.\n * @param {Node | number} high - The value of the upper edge of the Hermite function.\n * @param {Node | number} x - The source value for interpolation.\n * @returns {Node}\n */\nexport const smoothstep = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.SMOOTHSTEP ).setParameterLength( 3 );\n\n/**\n * Returns a vector pointing in the same direction as another.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} N - The vector to orient.\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} Nref - The reference vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nexport const faceForward = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.FACEFORWARD ).setParameterLength( 3 );\n\n/**\n * Returns a random value for the given uv.\n *\n * @tsl\n * @function\n * @param {Node<vec2>} uv - The uv node.\n * @returns {Node<float>}\n */\nexport const rand = /*@__PURE__*/ Fn( ( [ uv ] ) => {\n\n\tconst a = 12.9898, b = 78.233, c = 43758.5453;\n\tconst dt = dot( uv.xy, vec2( a, b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ).mul( c ) );\n\n} );\n\n/**\n * Alias for `mix()` with a different parameter order.\n *\n * @tsl\n * @function\n * @param {Node | number} t - The interpolation value.\n * @param {Node | number} e1 - The first parameter.\n * @param {Node | number} e2 - The second parameter.\n * @returns {Node}\n */\nexport const mixElement = ( t, e1, e2 ) => mix( e1, e2, t );\n\n/**\n * Alias for `smoothstep()` with a different parameter order.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The source value for interpolation.\n * @param {Node | number} low - The value of the lower edge of the Hermite function.\n * @param {Node | number} high - The value of the upper edge of the Hermite function.\n * @returns {Node}\n */\nexport const smoothstepElement = ( x, low, high ) => smoothstep( low, high, x );\n\n/**\n * Alias for `step()` with a different parameter order.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The source value for interpolation.\n * @param {Node | number} edge - The edge value.\n * @returns {Node}\n */\nexport const stepElement = ( x, edge ) => step( edge, x );\n\n/**\n * Returns the arc-tangent of the quotient of its parameters.\n *\n * @tsl\n * @function\n * @deprecated since r172. Use {@link atan} instead.\n *\n * @param {Node | number} y - The y parameter.\n * @param {Node | number} x - The x parameter.\n * @returns {Node}\n */\nexport const atan2 = ( y, x ) => { // @deprecated, r172\n\n\tconsole.warn( 'THREE.TSL: \"atan2\" is overloaded. Use \"atan\" instead.' );\n\treturn atan( y, x );\n\n};\n\n// GLSL alias function\n\nexport const faceforward = faceForward;\nexport const inversesqrt = inverseSqrt;\n\n// Method chaining\n\naddMethodChaining( 'all', all );\naddMethodChaining( 'any', any );\naddMethodChaining( 'equals', equals );\n\naddMethodChaining( 'radians', radians );\naddMethodChaining( 'degrees', degrees );\naddMethodChaining( 'exp', exp );\naddMethodChaining( 'exp2', exp2 );\naddMethodChaining( 'log', log );\naddMethodChaining( 'log2', log2 );\naddMethodChaining( 'sqrt', sqrt );\naddMethodChaining( 'inverseSqrt', inverseSqrt );\naddMethodChaining( 'floor', floor );\naddMethodChaining( 'ceil', ceil );\naddMethodChaining( 'normalize', normalize );\naddMethodChaining( 'fract', fract );\naddMethodChaining( 'sin', sin );\naddMethodChaining( 'cos', cos );\naddMethodChaining( 'tan', tan );\naddMethodChaining( 'asin', asin );\naddMethodChaining( 'acos', acos );\naddMethodChaining( 'atan', atan );\naddMethodChaining( 'abs', abs );\naddMethodChaining( 'sign', sign );\naddMethodChaining( 'length', length );\naddMethodChaining( 'lengthSq', lengthSq );\naddMethodChaining( 'negate', negate );\naddMethodChaining( 'oneMinus', oneMinus );\naddMethodChaining( 'dFdx', dFdx );\naddMethodChaining( 'dFdy', dFdy );\naddMethodChaining( 'round', round );\naddMethodChaining( 'reciprocal', reciprocal );\naddMethodChaining( 'trunc', trunc );\naddMethodChaining( 'fwidth', fwidth );\naddMethodChaining( 'atan2', atan2 );\naddMethodChaining( 'min', min );\naddMethodChaining( 'max', max );\naddMethodChaining( 'step', stepElement );\naddMethodChaining( 'reflect', reflect );\naddMethodChaining( 'distance', distance );\naddMethodChaining( 'dot', dot );\naddMethodChaining( 'cross', cross );\naddMethodChaining( 'pow', pow );\naddMethodChaining( 'pow2', pow2 );\naddMethodChaining( 'pow3', pow3 );\naddMethodChaining( 'pow4', pow4 );\naddMethodChaining( 'transformDirection', transformDirection );\naddMethodChaining( 'mix', mixElement );\naddMethodChaining( 'clamp', clamp );\naddMethodChaining( 'refract', refract );\naddMethodChaining( 'smoothstep', smoothstepElement );\naddMethodChaining( 'faceForward', faceForward );\naddMethodChaining( 'difference', difference );\naddMethodChaining( 'saturate', saturate );\naddMethodChaining( 'cbrt', cbrt );\naddMethodChaining( 'transpose', transpose );\naddMethodChaining( 'determinant', determinant );\naddMethodChaining( 'inverse', inverse );\naddMethodChaining( 'rand', rand );\n", "import Node from '../core/Node.js';\nimport { property } from '../core/PropertyNode.js';\nimport { addMethodChaining, nodeProxy } from '../tsl/TSLCore.js';\n\n/**\n * Represents a logical `if/else` statement. Can be used as an alternative\n * to the `If()`/`Else()` syntax.\n *\n * The corresponding TSL `select()` looks like so:\n * ```js\n * velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );\n * ```\n * The `select()` method is called in a chaining fashion on a condition. The parameter nodes of `select()`\n * determine the outcome of the entire statement.\n *\n * @augments Node\n */\nclass ConditionalNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ConditionalNode';\n\n\t}\n\n\t/**\n\t * Constructs a new conditional node.\n\t *\n\t * @param {Node} condNode - The node that defines the condition.\n\t * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.\n\t * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.\n\t */\n\tconstructor( condNode, ifNode, elseNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that defines the condition.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.condNode = condNode;\n\n\t\t/**\n\t\t * The node that is evaluate when the condition ends up `true`.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.ifNode = ifNode;\n\n\t\t/**\n\t\t * The node that is evaluate when the condition ends up `false`.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.elseNode = elseNode;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the if/else\n\t * nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst { ifNode, elseNode } = builder.getNodeProperties( this );\n\n\t\tif ( ifNode === undefined ) {\n\n\t\t\t// fallback setup\n\n\t\t\tbuilder.flowBuildStage( this, 'setup' );\n\n\t\t\treturn this.getNodeType( builder );\n\n\t\t}\n\n\t\tconst ifType = ifNode.getNodeType( builder );\n\n\t\tif ( elseNode !== null ) {\n\n\t\t\tconst elseType = elseNode.getNodeType( builder );\n\n\t\t\tif ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {\n\n\t\t\t\treturn elseType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ifType;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst condNode = this.condNode.cache();\n\t\tconst ifNode = this.ifNode.cache();\n\t\tconst elseNode = this.elseNode ? this.elseNode.cache() : null;\n\n\t\t//\n\n\t\tconst currentNodeBlock = builder.context.nodeBlock;\n\n\t\tbuilder.getDataFromNode( ifNode ).parentNodeBlock = currentNodeBlock;\n\t\tif ( elseNode !== null ) builder.getDataFromNode( elseNode ).parentNodeBlock = currentNodeBlock;\n\n\t\t//\n\n\t\tconst isUniformFlow = builder.context.uniformFlow;\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.condNode = condNode;\n\t\tproperties.ifNode = isUniformFlow ? ifNode : ifNode.context( { nodeBlock: ifNode } );\n\t\tproperties.elseNode = elseNode ? ( isUniformFlow ? elseNode : elseNode.context( { nodeBlock: elseNode } ) ) : null;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tif ( nodeData.nodeProperty !== undefined ) {\n\n\t\t\treturn nodeData.nodeProperty;\n\n\t\t}\n\n\t\tconst { condNode, ifNode, elseNode } = builder.getNodeProperties( this );\n\n\t\tconst functionNode = builder.currentFunctionNode;\n\t\tconst needsOutput = output !== 'void';\n\t\tconst nodeProperty = needsOutput ? property( type ).build( builder ) : '';\n\n\t\tnodeData.nodeProperty = nodeProperty;\n\n\t\tconst nodeSnippet = condNode.build( builder, 'bool' );\n\t\tconst isUniformFlow = builder.context.uniformFlow;\n\n\t\tif ( isUniformFlow && elseNode !== null ) {\n\n\t\t\tconst ifSnippet = ifNode.build( builder, type );\n\t\t\tconst elseSnippet = elseNode.build( builder, type );\n\n\t\t\tconst mathSnippet = builder.getTernary( nodeSnippet, ifSnippet, elseSnippet );\n\n\t\t\t// TODO: If node property already exists return something else\n\n\t\t\treturn builder.format( mathSnippet, type, output );\n\n\t\t}\n\n\t\tbuilder.addFlowCode( `\\n${ builder.tab }if ( ${ nodeSnippet } ) {\\n\\n` ).addFlowTab();\n\n\t\tlet ifSnippet = ifNode.build( builder, type );\n\n\t\tif ( ifSnippet ) {\n\n\t\t\tif ( needsOutput ) {\n\n\t\t\t\tifSnippet = nodeProperty + ' = ' + ifSnippet + ';';\n\n\t\t\t} else {\n\n\t\t\t\tifSnippet = 'return ' + ifSnippet + ';';\n\n\t\t\t\tif ( functionNode === null ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.TSL: Return statement used in an inline \\'Fn()\\'. Define a layout struct to allow return values.' );\n\n\t\t\t\t\tifSnippet = '// ' + ifSnippet;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + ifSnippet + '\\n\\n' + builder.tab + '}' );\n\n\t\tif ( elseNode !== null ) {\n\n\t\t\tbuilder.addFlowCode( ' else {\\n\\n' ).addFlowTab();\n\n\t\t\tlet elseSnippet = elseNode.build( builder, type );\n\n\t\t\tif ( elseSnippet ) {\n\n\t\t\t\tif ( needsOutput ) {\n\n\t\t\t\t\telseSnippet = nodeProperty + ' = ' + elseSnippet + ';';\n\n\t\t\t\t} else {\n\n\t\t\t\t\telseSnippet = 'return ' + elseSnippet + ';';\n\n\t\t\t\t\tif ( functionNode === null ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.TSL: Return statement used in an inline \\'Fn()\\'. Define a layout struct to allow return values.' );\n\n\t\t\t\t\t\telseSnippet = '// ' + elseSnippet;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + elseSnippet + '\\n\\n' + builder.tab + '}\\n\\n' );\n\n\t\t} else {\n\n\t\t\tbuilder.addFlowCode( '\\n\\n' );\n\n\t\t}\n\n\t\treturn builder.format( nodeProperty, type, output );\n\n\t}\n\n}\n\nexport default ConditionalNode;\n\n/**\n * TSL function for creating a conditional node.\n *\n * @tsl\n * @function\n * @param {Node} condNode - The node that defines the condition.\n * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.\n * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.\n * @returns {ConditionalNode}\n */\nexport const select = /*@__PURE__*/ nodeProxy( ConditionalNode ).setParameterLength( 2, 3 );\n\naddMethodChaining( 'select', select );\n", "import Node from './Node.js';\nimport { addMethodChaining, nodeProxy } from '../tsl/TSLCore.js';\n\n/**\n * This node can be used as a context management component for another node.\n * {@link NodeBuilder} performs its node building process in a specific context and\n * this node allows the modify the context. A typical use case is to overwrite `getUV()` e.g.:\n *\n * ```js\n *node.context( { getUV: () => customCoord } );\n *```\n * @augments Node\n */\nclass ContextNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ContextNode';\n\n\t}\n\n\t/**\n\t * Constructs a new context node.\n\t *\n\t * @param {Node} node - The node whose context should be modified.\n\t * @param {Object} [value={}] - The modified context data.\n\t */\n\tconstructor( node, value = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isContextNode = true;\n\n\t\t/**\n\t\t * The node whose context should be modified.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The modified context data.\n\t\t *\n\t\t * @type {Object}\n\t\t * @default {}\n\t\t */\n\t\tthis.value = value;\n\n\t}\n\n\t/**\n\t * This method is overwritten to ensure it returns the reference to {@link ContextNode#node}.\n\t *\n\t * @return {Node} A reference to {@link ContextNode#node}.\n\t */\n\tgetScope() {\n\n\t\treturn this.node.getScope();\n\n\t}\n\n\t/**\n\t * This method is overwritten to ensure it returns the type of {@link ContextNode#node}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * This method is overwritten to ensure it returns the member type of {@link ContextNode#node}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} name - The member name.\n\t * @returns {string} The member type.\n\t */\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.node.getMemberType( builder, name );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.value } );\n\n\t\tthis.node.build( builder );\n\n\t\tbuilder.setContext( previousContext );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.value } );\n\n\t\tthis.node.build( builder );\n\n\t\tbuilder.setContext( previousContext );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.value } );\n\n\t\tconst snippet = this.node.build( builder, output );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn snippet;\n\n\t}\n\n}\n\nexport default ContextNode;\n\n/**\n * TSL function for creating a context node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node whose context should be modified.\n * @param {Object} [value={}] - The modified context data.\n * @returns {ContextNode}\n */\nexport const context = /*@__PURE__*/ nodeProxy( ContextNode ).setParameterLength( 1, 2 );\n\n/**\n * TSL function for defining a uniformFlow context value for a given node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node whose dependencies should all execute within a uniform control-flow path.\n * @returns {ContextNode}\n */\nexport const uniformFlow = ( node ) => context( node, { uniformFlow: true } );\n\n/**\n * TSL function for defining a name for the context value for a given node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node whose context should be modified.\n * @param {string} name - The name to set.\n * @returns {ContextNode}\n */\nexport const setName = ( node, name ) => context( node, { nodeName: name } );\n\n/**\n * TSL function for defining a label context value for a given node.\n *\n * @tsl\n * @function\n * @deprecated\n * @param {Node} node - The node whose context should be modified.\n * @param {string} name - The name/label to set.\n * @returns {ContextNode}\n */\nexport function label( node, name ) {\n\n\tconsole.warn( 'THREE.TSL: \"label()\" has been deprecated. Use \"setName()\" instead.' ); // @deprecated r179\n\n\treturn setName( node, name );\n\n}\n\naddMethodChaining( 'context', context );\naddMethodChaining( 'label', label );\naddMethodChaining( 'uniformFlow', uniformFlow );\naddMethodChaining( 'setName', setName );\n", "import Node from './Node.js';\nimport { addMethodChaining, getCurrentStack, nodeProxy } from '../tsl/TSLCore.js';\n\n/**\n * Class for representing shader variables as nodes. Variables are created from\n * existing nodes like the following:\n *\n * ```js\n * const depth = sampleDepth( uvNode ).toVar( 'depth' );\n * ```\n *\n * @augments Node\n */\nclass VarNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VarNode';\n\n\t}\n\n\t/**\n\t * Constructs a new variable node.\n\t *\n\t * @param {Node} node - The node for which a variable should be created.\n\t * @param {?string} [name=null] - The name of the variable in the shader.\n\t * @param {boolean} [readOnly=false] - The read-only flag.\n\t */\n\tconstructor( node, name = null, readOnly = false ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node for which a variable should be created.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The name of the variable in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * `VarNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVarNode = true;\n\n\t\t/**\n\t\t *\n\t\t * The read-only flag.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.readOnly = readOnly;\n\n\t\t/**\n\t\t *\n\t\t * Add this flag to the node system to indicate that this node require parents.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.parents = true;\n\n\t\t/**\n\t\t * This flag is used to indicate that this node is used for intent.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.intent = false;\n\n\t}\n\n\t/**\n\t * Sets the intent flag for this node.\n\t *\n\t * This flag is used to indicate that this node is used for intent\n\t * and should not be built directly. Instead, it is used to indicate that\n\t * the node should be treated as a variable intent.\n\t *\n\t * It's useful for assigning variables without needing creating a new variable node.\n\t *\n\t * @param {boolean} value - The value to set for the intent flag.\n\t * @returns {VarNode} This node.\n\t */\n\tsetIntent( value ) {\n\n\t\tthis.intent = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the intent flag of this node.\n\t *\n\t * @return {boolean} The intent flag.\n\t */\n\tgetIntent() {\n\n\t\treturn this.intent;\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.node.getMemberType( builder, name );\n\n\t}\n\n\tgetElementType( builder ) {\n\n\t\treturn this.node.getElementType( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgetArrayCount( builder ) {\n\n\t\treturn this.node.getArrayCount( builder );\n\n\t}\n\n\tbuild( ...params ) {\n\n\t\tif ( this.intent === true ) {\n\n\t\t\tconst builder = params[ 0 ];\n\t\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t\tif ( properties.assign !== true ) {\n\n\t\t\t\treturn this.node.build( ...params );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.build( ...params );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { node, name, readOnly } = this;\n\t\tconst { renderer } = builder;\n\n\t\tconst isWebGPUBackend = renderer.backend.isWebGPUBackend === true;\n\n\t\tlet isDeterministic = false;\n\t\tlet shouldTreatAsReadOnly = false;\n\n\t\tif ( readOnly ) {\n\n\t\t\tisDeterministic = builder.isDeterministic( node );\n\n\t\t\tshouldTreatAsReadOnly = isWebGPUBackend ? readOnly : isDeterministic;\n\n\t\t}\n\n\t\tconst vectorType = builder.getVectorType( this.getNodeType( builder ) );\n\t\tconst snippet = node.build( builder, vectorType );\n\n\t\tconst nodeVar = builder.getVarFromNode( this, name, vectorType, undefined, shouldTreatAsReadOnly );\n\n\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\tlet declarationPrefix = propertyName;\n\n\t\tif ( shouldTreatAsReadOnly ) {\n\n\t\t\tif ( isWebGPUBackend ) {\n\n\t\t\t\tdeclarationPrefix = isDeterministic\n\t\t\t\t\t? `const ${ propertyName }`\n\t\t\t\t\t: `let ${ propertyName }`;\n\n\t\t\t} else {\n\n\t\t\t\tconst count = node.getArrayCount( builder );\n\n\t\t\t\tdeclarationPrefix = `const ${ builder.getVar( nodeVar.type, propertyName, count ) }`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.addLineFlowCode( `${ declarationPrefix } = ${ snippet }`, this );\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\nexport default VarNode;\n\n/**\n * TSL function for creating a var node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a variable should be created.\n * @param {?string} name - The name of the variable in the shader.\n * @returns {VarNode}\n */\nconst createVar = /*@__PURE__*/ nodeProxy( VarNode );\n\n/**\n * TSL function for creating a var node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a variable should be created.\n * @param {?string} name - The name of the variable in the shader.\n * @returns {VarNode}\n */\nexport const Var = ( node, name = null ) => createVar( node, name ).toStack();\n\n/**\n * TSL function for creating a const node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a constant should be created.\n * @param {?string} name - The name of the constant in the shader.\n * @returns {VarNode}\n */\nexport const Const = ( node, name = null ) => createVar( node, name, true ).toStack();\n\n//\n//\n\n/**\n * TSL function for creating a var intent node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a variable should be created.\n * @param {?string} name - The name of the variable in the shader.\n * @returns {VarNode}\n */\nexport const VarIntent = ( node ) => {\n\n\tif ( getCurrentStack() === null ) {\n\n\t\treturn node;\n\n\t}\n\n\treturn createVar( node ).setIntent( true ).toStack();\n\n};\n\n// Method chaining\n\naddMethodChaining( 'toVar', Var );\naddMethodChaining( 'toConst', Const );\naddMethodChaining( 'toVarIntent', VarIntent );\n", "import Node from './Node.js';\nimport { nodeObject } from '../tsl/TSLCore.js';\n\n/**\n * This node is used to build a sub-build in the node system.\n *\n * @augments Node\n * @param {Node} node - The node to be built in the sub-build.\n * @param {string} name - The name of the sub-build.\n * @param {?string} [nodeType=null] - The type of the node, if known.\n */\nclass SubBuildNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SubBuild';\n\n\t}\n\n\tconstructor( node, name, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The node to be built in the sub-build.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The name of the sub-build.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSubBuildNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.nodeType !== null ) return this.nodeType;\n\n\t\tbuilder.addSubBuild( this.name );\n\n\t\tconst nodeType = this.node.getNodeType( builder );\n\n\t\tbuilder.removeSubBuild();\n\n\t\treturn nodeType;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tbuilder.addSubBuild( this.name );\n\n\t\tconst data = this.node.build( builder, ...params );\n\n\t\tbuilder.removeSubBuild();\n\n\t\treturn data;\n\n\t}\n\n}\n\nexport default SubBuildNode;\n\n/**\n * Creates a new sub-build node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node to be built in the sub-build.\n * @param {string} name - The name of the sub-build.\n * @param {?string} [type=null] - The type of the node, if known.\n * @returns {Node} A node object wrapping the SubBuildNode instance.\n */\nexport const subBuild = ( node, name, type = null ) => nodeObject( new SubBuildNode( nodeObject( node ), name, type ) );\n", "import Node from './Node.js';\nimport { NodeShaderStage } from './constants.js';\nimport { addMethodChaining, nodeProxy } from '../tsl/TSLCore.js';\nimport { subBuild } from './SubBuildNode.js';\n\n/**\n * Class for representing shader varyings as nodes. Varyings are create from\n * existing nodes like the following:\n *\n * ```js\n * const positionLocal = positionGeometry.toVarying( 'vPositionLocal' );\n * ```\n *\n * @augments Node\n */\nclass VaryingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VaryingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new varying node.\n\t *\n\t * @param {Node} node - The node for which a varying should be created.\n\t * @param {?string} name - The name of the varying in the shader.\n\t */\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node for which a varying should be created.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The name of the varying in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVaryingNode = true;\n\n\t\t/**\n\t\t * The interpolation type of the varying data.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.interpolationType = null;\n\n\t\t/**\n\t\t * The interpolation sampling type of varying data.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.interpolationSampling = null;\n\n\t\t/**\n\t\t * This flag is used for global cache.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\t/**\n\t * Defines the interpolation type of the varying.\n\t *\n\t * @param {string} type - The interpolation type.\n\t * @param {?string} sampling - The interpolation sampling type\n\t * @return {VaryingNode} A reference to this node.\n\t */\n\tsetInterpolation( type, sampling = null ) {\n\n\t\tthis.interpolationType = type;\n\t\tthis.interpolationSampling = sampling;\n\n\t\treturn this;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\t// VaryingNode is auto type\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * This method performs the setup of a varying node with the current node builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {NodeVarying} The node varying from the node builder.\n\t */\n\tsetupVarying( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tlet varying = properties.varying;\n\n\t\tif ( varying === undefined ) {\n\n\t\t\tconst name = this.name;\n\t\t\tconst type = this.getNodeType( builder );\n\t\t\tconst interpolationType = this.interpolationType;\n\t\t\tconst interpolationSampling = this.interpolationSampling;\n\n\t\t\tproperties.varying = varying = builder.getVaryingFromNode( this, name, type, interpolationType, interpolationSampling );\n\t\t\tproperties.node = subBuild( this.node, 'VERTEX' );\n\n\t\t}\n\n\t\t// this property can be used to check if the varying can be optimized for a variable\n\t\tvarying.needsInterpolation || ( varying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );\n\n\t\treturn varying;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst propertyKey = builder.getSubBuildProperty( 'property', builder.currentStack );\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst varying = this.setupVarying( builder );\n\n\t\tif ( properties[ propertyKey ] === undefined ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\t\t\tconst propertyName = builder.getPropertyName( varying, NodeShaderStage.VERTEX );\n\n\t\t\t// force node run in vertex stage\n\t\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, properties.node, type, propertyName );\n\n\t\t\tproperties[ propertyKey ] = propertyName;\n\n\t\t}\n\n\t\treturn builder.getPropertyName( varying );\n\n\t}\n\n}\n\nexport default VaryingNode;\n\n/**\n * TSL function for creating a varying node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a varying should be created.\n * @param {?string} name - The name of the varying in the shader.\n * @returns {VaryingNode}\n */\nexport const varying = /*@__PURE__*/ nodeProxy( VaryingNode ).setParameterLength( 1, 2 );\n\n/**\n * Computes a node in the vertex stage.\n *\n * @tsl\n * @function\n * @param {Node} node - The node which should be executed in the vertex stage.\n * @returns {VaryingNode}\n */\nexport const vertexStage = ( node ) => varying( node );\n\naddMethodChaining( 'toVarying', varying );\naddMethodChaining( 'toVertexStage', vertexStage );\n\n// Deprecated\n\naddMethodChaining( 'varying', ( ...params ) => { // @deprecated, r173\n\n\tconsole.warn( 'THREE.TSL: .varying() has been renamed to .toVarying().' );\n\treturn varying( ...params );\n\n} );\n\naddMethodChaining( 'vertexStage', ( ...params ) => { // @deprecated, r173\n\n\tconsole.warn( 'THREE.TSL: .vertexStage() has been renamed to .toVertexStage().' );\n\treturn varying( ...params );\n\n} );\n", "import { mix } from '../math/MathNode.js';\nimport { Fn } from '../tsl/TSLCore.js';\n\n/**\n * Converts the given color value from sRGB to linear-sRGB color space.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The sRGB color.\n * @return {Node<vec3>} The linear-sRGB color.\n */\nexport const sRGBTransferEOTF = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.mul( 0.9478672986 ).add( 0.0521327014 ).pow( 2.4 );\n\tconst b = color.mul( 0.0773993808 );\n\tconst factor = color.lessThanEqual( 0.04045 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn rgbResult;\n\n} ).setLayout( {\n\tname: 'sRGBTransferEOTF',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\n/**\n * Converts the given color value from linear-sRGB to sRGB color space.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The linear-sRGB color.\n * @return {Node<vec3>} The sRGB color.\n */\nexport const sRGBTransferOETF = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );\n\tconst b = color.mul( 12.92 );\n\tconst factor = color.lessThanEqual( 0.0031308 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn rgbResult;\n\n} ).setLayout( {\n\tname: 'sRGBTransferOETF',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n", "import TempNode from '../core/TempNode.js';\nimport { addMethodChaining, mat3, nodeObject, vec4 } from '../tsl/TSLCore.js';\n\nimport { SRGBTransfer } from '../../constants.js';\nimport { ColorManagement } from '../../math/ColorManagement.js';\nimport { sRGBTransferEOTF, sRGBTransferOETF } from './ColorSpaceFunctions.js';\nimport { Matrix3 } from '../../math/Matrix3.js';\n\nconst WORKING_COLOR_SPACE = 'WorkingColorSpace';\nconst OUTPUT_COLOR_SPACE = 'OutputColorSpace';\n\n/**\n * This node represents a color space conversion. Meaning it converts\n * a color value from a source to a target color space.\n *\n * @augments TempNode\n */\nclass ColorSpaceNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ColorSpaceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new color space node.\n\t *\n\t * @param {Node} colorNode - Represents the color to convert.\n\t * @param {string} source - The source color space.\n\t * @param {string} target - The target color space.\n\t */\n\tconstructor( colorNode, source, target ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * Represents the color to convert.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t\t/**\n\t\t * The source color space.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.source = source;\n\n\t\t/**\n\t\t * The target color space.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.target = target;\n\n\t}\n\n\t/**\n\t * This method resolves the constants `WORKING_COLOR_SPACE` and\n\t * `OUTPUT_COLOR_SPACE` based on the current configuration of the\n\t * color management and renderer.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} colorSpace - The color space to resolve.\n\t * @return {string} The resolved color space.\n\t */\n\tresolveColorSpace( builder, colorSpace ) {\n\n\t\tif ( colorSpace === WORKING_COLOR_SPACE ) {\n\n\t\t\treturn ColorManagement.workingColorSpace;\n\n\t\t} else if ( colorSpace === OUTPUT_COLOR_SPACE ) {\n\n\t\t\treturn builder.context.outputColorSpace || builder.renderer.outputColorSpace;\n\n\t\t}\n\n\t\treturn colorSpace;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { colorNode } = this;\n\n\t\tconst source = this.resolveColorSpace( builder, this.source );\n\t\tconst target = this.resolveColorSpace( builder, this.target );\n\n\t\tlet outputNode = colorNode;\n\n\t\tif ( ColorManagement.enabled === false || source === target || ! source || ! target ) {\n\n\t\t\treturn outputNode;\n\n\t\t}\n\n\t\tif ( ColorManagement.getTransfer( source ) === SRGBTransfer ) {\n\n\t\t\toutputNode = vec4( sRGBTransferEOTF( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\tif ( ColorManagement.getPrimaries( source ) !== ColorManagement.getPrimaries( target ) ) {\n\n\t\t\toutputNode = vec4(\n\t\t\t\tmat3( ColorManagement._getMatrix( new Matrix3(), source, target ) ).mul( outputNode.rgb ),\n\t\t\t\toutputNode.a\n\t\t\t);\n\n\t\t}\n\n\t\tif ( ColorManagement.getTransfer( target ) === SRGBTransfer ) {\n\n\t\t\toutputNode = vec4( sRGBTransferOETF( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default ColorSpaceNode;\n\n/**\n * TSL function for converting a given color node from the current working color space to the given color space.\n *\n * @tsl\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {string} targetColorSpace - The target color space.\n * @returns {ColorSpaceNode}\n */\nexport const workingToColorSpace = ( node, targetColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, targetColorSpace ) );\n\n/**\n * TSL function for converting a given color node from the given color space to the current working color space.\n *\n * @tsl\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {string} sourceColorSpace - The source color space.\n * @returns {ColorSpaceNode}\n */\nexport const colorSpaceToWorking = ( node, sourceColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), sourceColorSpace, WORKING_COLOR_SPACE ) );\n\n/**\n * TSL function for converting a given color node from one color space to another one.\n *\n * @tsl\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {string} sourceColorSpace - The source color space.\n * @param {string} targetColorSpace - The target color space.\n * @returns {ColorSpaceNode}\n */\nexport const convertColorSpace = ( node, sourceColorSpace, targetColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), sourceColorSpace, targetColorSpace ) );\n\naddMethodChaining( 'workingToColorSpace', workingToColorSpace );\naddMethodChaining( 'colorSpaceToWorking', colorSpaceToWorking );\n", "import Node from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { nodeObject } from '../tsl/TSLCore.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\n\n// TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode\n\n/**\n * This class is only relevant if the referenced property is array-like.\n * In this case, `ReferenceElementNode` allows to refer to a specific\n * element inside the data structure via an index.\n *\n * @augments ArrayElementNode\n */\nclass ReferenceElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference element node.\n\t *\n\t * @param {ReferenceBaseNode} referenceNode - The reference node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( referenceNode, indexNode ) {\n\n\t\tsuper( referenceNode, indexNode );\n\n\t\t/**\n\t\t * Similar to {@link ReferenceBaseNode#reference}, an additional\n\t\t * property references to the current node.\n\t\t *\n\t\t * @type {?ReferenceBaseNode}\n\t\t * @default null\n\t\t */\n\t\tthis.referenceNode = referenceNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isReferenceElementNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the uniform type of the reference node.\n\t *\n\t * @return {string} The node type.\n\t */\n\tgetNodeType() {\n\n\t\treturn this.referenceNode.uniformType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst arrayType = this.referenceNode.getNodeType();\n\t\tconst elementType = this.getNodeType();\n\n\t\treturn builder.format( snippet, arrayType, elementType );\n\n\t}\n\n}\n\n/**\n * Base class for nodes which establishes a reference to a property of another object.\n * In this way, the value of the node is automatically linked to the value of\n * referenced object. Reference nodes internally represent the linked value\n * as a uniform.\n *\n * @augments Node\n */\nclass ReferenceBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceBaseNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference base node.\n\t *\n\t * @param {string} property - The name of the property the node refers to.\n\t * @param {string} uniformType - The uniform type that should be used to represent the property value.\n\t * @param {?Object} [object=null] - The object the property belongs to.\n\t * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.\n\t */\n\tconstructor( property, uniformType, object = null, count = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the property the node refers to.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * The uniform type that should be used to represent the property value.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.uniformType = uniformType;\n\n\t\t/**\n\t\t * The object the property belongs to.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * When the linked property is an array, this parameter defines its length.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * The property name might have dots so nested properties can be referred.\n\t\t * The hierarchy of the names is stored inside this array.\n\t\t *\n\t\t * @type {Array<string>}\n\t\t */\n\t\tthis.properties = property.split( '.' );\n\n\t\t/**\n\t\t * Points to the current referred object. This property exists next to {@link ReferenceNode#object}\n\t\t * since the final reference might be updated from calling code.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.reference = object;\n\n\t\t/**\n\t\t * The uniform node that holds the value of the reference node.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t * @default null\n\t\t */\n\t\tthis.node = null;\n\n\t\t/**\n\t\t * The uniform group of the internal uniform.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t * @default null\n\t\t */\n\t\tthis.group = null;\n\n\t\t/**\n\t\t * Overwritten since reference nodes are updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\t/**\n\t * Sets the uniform group for this reference node.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group to set.\n\t * @return {ReferenceBaseNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.group = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * When the referred property is array-like, this method can be used\n\t * to access elements via an index node.\n\t *\n\t * @param {IndexNode} indexNode - indexNode.\n\t * @return {ReferenceElementNode} A reference to an element.\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new ReferenceElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n\t/**\n\t * Sets the node type which automatically defines the internal\n\t * uniform type.\n\t *\n\t * @param {string} uniformType - The type to set.\n\t */\n\tsetNodeType( uniformType ) {\n\n\t\tconst node = uniform( null, uniformType );\n\n\t\tif ( this.group !== null ) {\n\n\t\t\tnode.setGroup( this.group );\n\n\t\t}\n\n\t\tthis.node = node;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the type of the reference node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.node === null ) {\n\n\t\t\tthis.updateReference( builder );\n\t\t\tthis.updateValue();\n\n\t\t}\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Returns the property value from the given referred object.\n\t *\n\t * @param {Object} [object=this.reference] - The object to retrieve the property value from.\n\t * @return {any} The value.\n\t */\n\tgetValueFromReference( object = this.reference ) {\n\n\t\tconst { properties } = this;\n\n\t\tlet value = object[ properties[ 0 ] ];\n\n\t\tfor ( let i = 1; i < properties.length; i ++ ) {\n\n\t\t\tvalue = value[ properties[ i ] ];\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\t/**\n\t * Allows to update the reference based on the given state. The state is only\n\t * evaluated {@link ReferenceBaseNode#object} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.object !== null ? this.object : state.object;\n\n\t\treturn this.reference;\n\n\t}\n\n\t/**\n\t * The output of the reference node is the internal uniform node.\n\t *\n\t * @return {UniformNode} The output node.\n\t */\n\tsetup() {\n\n\t\tthis.updateValue();\n\n\t\treturn this.node;\n\n\t}\n\n\t/**\n\t * Overwritten to update the internal uniform value.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tthis.updateValue();\n\n\t}\n\n\t/**\n\t * Retrieves the value from the referred object property and uses it\n\t * to updated the internal uniform.\n\t */\n\tupdateValue() {\n\n\t\tif ( this.node === null ) this.setNodeType( this.uniformType );\n\n\t\tconst value = this.getValueFromReference();\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tthis.node.array = value;\n\n\t\t} else {\n\n\t\t\tthis.node.value = value;\n\n\t\t}\n\n\t}\n\n}\n\nexport default ReferenceBaseNode;\n\n/**\n * TSL function for creating a reference base node.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the property the node refers to.\n * @param {string} type - The uniform type that should be used to represent the property value.\n * @param {Object} object - The object the property belongs to.\n * @returns {ReferenceBaseNode}\n */\nexport const reference = ( name, type, object ) => nodeObject( new ReferenceBaseNode( name, type, object ) );\n\n/**\n * TSL function for creating a reference base node. Use this function if you want need a reference\n * to an array-like property that should be represented as a uniform buffer.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the property the node refers to.\n * @param {string} type - The uniform type that should be used to represent the property value.\n * @param {number} count - The number of value inside the array-like object.\n * @param {Object} [object] - An array-like object the property belongs to.\n * @returns {ReferenceBaseNode}\n */\nexport const referenceBuffer = ( name, type, count, object ) => nodeObject( new ReferenceBaseNode( name, type, object, count ) );\n", "import ReferenceBaseNode from './ReferenceBaseNode.js';\nimport { nodeObject } from '../tsl/TSLCore.js';\nimport { renderGroup } from '../core/UniformGroupNode.js';\n\n/**\n * This node is a special type of reference node which is intended\n * for linking renderer properties with node values.\n * ```js\n * const exposureNode = rendererReference( 'toneMappingExposure', 'float', renderer );\n * ```\n * When changing `renderer.toneMappingExposure`, the node value of `exposureNode` will\n * automatically be updated.\n *\n * @augments ReferenceBaseNode\n */\nclass RendererReferenceNode extends ReferenceBaseNode {\n\n\tstatic get type() {\n\n\t\treturn 'RendererReferenceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new renderer reference node.\n\t *\n\t * @param {string} property - The name of the property the node refers to.\n\t * @param {string} inputType - The uniform type that should be used to represent the property value.\n\t * @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,\n\t * the node refers to the renderer of the current state.\n\t */\n\tconstructor( property, inputType, renderer = null ) {\n\n\t\tsuper( property, inputType, renderer );\n\n\t\t/**\n\t\t * The renderer the property belongs to. When no renderer is set,\n\t\t * the node refers to the renderer of the current state.\n\t\t *\n\t\t * @type {?Renderer}\n\t\t * @default null\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\tthis.setGroup( renderGroup );\n\n\t}\n\n\t/**\n\t * Updates the reference based on the given state. The state is only evaluated\n\t * {@link RendererReferenceNode#renderer} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.renderer !== null ? this.renderer : state.renderer;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\nexport default RendererReferenceNode;\n\n/**\n * TSL function for creating a renderer reference node.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the property the node refers to.\n * @param {string} type - The uniform type that should be used to represent the property value.\n * @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,\n * the node refers to the renderer of the current state.\n * @returns {RendererReferenceNode}\n */\nexport const rendererReference = ( name, type, renderer = null ) => nodeObject( new RendererReferenceNode( name, type, renderer ) );\n", "import TempNode from '../core/TempNode.js';\nimport { addMethodChaining, nodeObject, vec4 } from '../tsl/TSLCore.js';\nimport { rendererReference } from '../accessors/RendererReferenceNode.js';\n\nimport { NoToneMapping } from '../../constants.js';\nimport { hash } from '../core/NodeUtils.js';\n\n/**\n * This node represents a tone mapping operation.\n *\n * @augments TempNode\n */\nclass ToneMappingNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ToneMappingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new tone mapping node.\n\t *\n\t * @param {number} toneMapping - The tone mapping type.\n\t * @param {Node} exposureNode - The tone mapping exposure.\n\t * @param {Node} [colorNode=null] - The color node to process.\n\t */\n\tconstructor( toneMapping, exposureNode = toneMappingExposure, colorNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * The tone mapping type.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.toneMapping = toneMapping;\n\n\t\t/**\n\t\t * The tone mapping exposure.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis.exposureNode = exposureNode;\n\n\t\t/**\n\t\t * Represents the color to process.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t}\n\n\t/**\n\t * Overwrites the default `customCacheKey()` implementation by including the tone\n\t * mapping type into the cache key.\n\t *\n\t * @return {number} The hash.\n\t */\n\tcustomCacheKey() {\n\n\t\treturn hash( this.toneMapping );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst colorNode = this.colorNode || builder.context.color;\n\t\tconst toneMapping = this.toneMapping;\n\n\t\tif ( toneMapping === NoToneMapping ) return colorNode;\n\n\t\tlet outputNode = null;\n\n\t\tconst toneMappingFn = builder.renderer.library.getToneMappingFunction( toneMapping );\n\n\t\tif ( toneMappingFn !== null ) {\n\n\t\t\toutputNode = vec4( toneMappingFn( colorNode.rgb, this.exposureNode ), colorNode.a );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping );\n\n\t\t\toutputNode = colorNode;\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default ToneMappingNode;\n\n/**\n * TSL function for creating a tone mapping node.\n *\n * @tsl\n * @function\n * @param {number} mapping - The tone mapping type.\n * @param {Node<float> | number} exposure - The tone mapping exposure.\n * @param {Node<vec3> | Color} color - The color node to process.\n * @returns {ToneMappingNode<vec3>}\n */\nexport const toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );\n\n/**\n * TSL object that represents the global tone mapping exposure of the renderer.\n *\n * @tsl\n * @type {RendererReferenceNode<vec3>}\n */\nexport const toneMappingExposure = /*@__PURE__*/ rendererReference( 'toneMappingExposure', 'float' );\n\naddMethodChaining( 'toneMapping', ( color, mapping, exposure ) => toneMapping( mapping, exposure, color ) );\n", "import { clamp } from '../math/MathUtils.js';\n\n// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst _tables = /*@__PURE__*/ _generateTables();\n\nfunction _generateTables() {\n\n\t// float32 to float16 helpers\n\n\tconst buffer = new ArrayBuffer( 4 );\n\tconst floatView = new Float32Array( buffer );\n\tconst uint32View = new Uint32Array( buffer );\n\n\tconst baseTable = new Uint32Array( 512 );\n\tconst shiftTable = new Uint32Array( 512 );\n\n\tfor ( let i = 0; i < 256; ++ i ) {\n\n\t\tconst e = i - 127;\n\n\t\t// very small number (0, -0)\n\n\t\tif ( e < - 27 ) {\n\n\t\t\tbaseTable[ i ] = 0x0000;\n\t\t\tbaseTable[ i | 0x100 ] = 0x8000;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// small number (denorm)\n\n\t\t} else if ( e < - 14 ) {\n\n\t\t\tbaseTable[ i ] = 0x0400 >> ( - e - 14 );\n\t\t\tbaseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;\n\t\t\tshiftTable[ i ] = - e - 1;\n\t\t\tshiftTable[ i | 0x100 ] = - e - 1;\n\n\t\t\t// normal number\n\n\t\t} else if ( e <= 15 ) {\n\n\t\t\tbaseTable[ i ] = ( e + 15 ) << 10;\n\t\t\tbaseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t\t// large number (Infinity, -Infinity)\n\n\t\t} else if ( e < 128 ) {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// stay (NaN, Infinity, -Infinity)\n\n\t\t} else {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t}\n\n\t}\n\n\t// float16 to float32 helpers\n\n\tconst mantissaTable = new Uint32Array( 2048 );\n\tconst exponentTable = new Uint32Array( 64 );\n\tconst offsetTable = new Uint32Array( 64 );\n\n\tfor ( let i = 1; i < 1024; ++ i ) {\n\n\t\tlet m = i << 13; // zero pad mantissa bits\n\t\tlet e = 0; // zero exponent\n\n\t\t// normalized\n\t\twhile ( ( m & 0x00800000 ) === 0 ) {\n\n\t\t\tm <<= 1;\n\t\t\te -= 0x00800000; // decrement exponent\n\n\t\t}\n\n\t\tm &= ~ 0x00800000; // clear leading 1 bit\n\t\te += 0x38800000; // adjust bias\n\n\t\tmantissaTable[ i ] = m | e;\n\n\t}\n\n\tfor ( let i = 1024; i < 2048; ++ i ) {\n\n\t\tmantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );\n\n\t}\n\n\tfor ( let i = 1; i < 31; ++ i ) {\n\n\t\texponentTable[ i ] = i << 23;\n\n\t}\n\n\texponentTable[ 31 ] = 0x47800000;\n\texponentTable[ 32 ] = 0x80000000;\n\n\tfor ( let i = 33; i < 63; ++ i ) {\n\n\t\texponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );\n\n\t}\n\n\texponentTable[ 63 ] = 0xc7800000;\n\n\tfor ( let i = 1; i < 64; ++ i ) {\n\n\t\tif ( i !== 32 ) {\n\n\t\t\toffsetTable[ i ] = 1024;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tfloatView: floatView,\n\t\tuint32View: uint32View,\n\t\tbaseTable: baseTable,\n\t\tshiftTable: shiftTable,\n\t\tmantissaTable: mantissaTable,\n\t\texponentTable: exponentTable,\n\t\toffsetTable: offsetTable\n\t};\n\n}\n\n/**\n * Returns a half precision floating point value (FP16) from the given single\n * precision floating point value (FP32).\n *\n * @param {number} val - A single precision floating point value.\n * @return {number} The FP16 value.\n */\nfunction toHalfFloat( val ) {\n\n\tif ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );\n\n\tval = clamp( val, - 65504, 65504 );\n\n\t_tables.floatView[ 0 ] = val;\n\tconst f = _tables.uint32View[ 0 ];\n\tconst e = ( f >> 23 ) & 0x1ff;\n\treturn _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );\n\n}\n\n/**\n * Returns a single precision floating point value (FP32) from the given half\n * precision floating point value (FP16).\n *\n * @param {number} val - A half precision floating point value.\n * @return {number} The FP32 value.\n */\nfunction fromHalfFloat( val ) {\n\n\tconst m = val >> 10;\n\t_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];\n\treturn _tables.floatView[ 0 ];\n\n}\n\n/**\n * A class containing utility functions for data.\n *\n * @hideconstructor\n */\nclass DataUtils {\n\n\t/**\n\t * Returns a half precision floating point value (FP16) from the given single\n\t * precision floating point value (FP32).\n\t *\n\t * @param {number} val - A single precision floating point value.\n\t * @return {number} The FP16 value.\n\t */\n\tstatic toHalfFloat( val ) {\n\n\t\treturn toHalfFloat( val );\n\n\t}\n\n\t/**\n\t * Returns a single precision floating point value (FP32) from the given half\n\t * precision floating point value (FP16).\n\t *\n\t * @param {number} val - A half precision floating point value.\n\t * @return {number} The FP32 value.\n\t */\n\tstatic fromHalfFloat( val ) {\n\n\t\treturn fromHalfFloat( val );\n\n\t}\n\n}\n\nexport {\n\ttoHalfFloat,\n\tfromHalfFloat,\n\tDataUtils\n};\n", "import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { denormalize, normalize } from '../math/MathUtils.js';\nimport { StaticDrawUsage, FloatType } from '../constants.js';\nimport { fromHalfFloat, toHalfFloat } from '../extras/DataUtils.js';\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector2();\n\nlet _id = 0;\n\n/**\n * This class stores data for an attribute (such as vertex positions, face\n * indices, normals, colors, UVs, and any custom attributes ) associated with\n * a geometry, which allows for more efficient passing of data to the GPU.\n *\n * When working with vector-like data, the `fromBufferAttribute( attribute, index )`\n * helper methods on vector and color class might be helpful. E.g. {@link Vector3#fromBufferAttribute}.\n */\nclass BufferAttribute {\n\n\t/**\n\t * Constructs a new buffer attribute.\n\t *\n\t * @param {TypedArray} array - The array holding the attribute data.\n\t * @param {number} itemSize - The item size.\n\t * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n\t */\n\tconstructor( array, itemSize, normalized = false ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferAttribute = true;\n\n\t\t/**\n\t\t * The ID of the buffer attribute.\n\t\t *\n\t\t * @name BufferAttribute#id\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\n\t\t * The name of the buffer attribute.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = '';\n\n\t\t/**\n\t\t * The array holding the attribute data. It should have `itemSize * numVertices`\n\t\t * elements, where `numVertices` is the number of vertices in the associated geometry.\n\t\t *\n\t\t * @type {TypedArray}\n\t\t */\n\t\tthis.array = array;\n\n\t\t/**\n\t\t * The number of values of the array that should be associated with a particular vertex.\n\t\t * For instance, if this attribute is storing a 3-component vector (such as a position,\n\t\t * normal, or color), then the value should be `3`.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.itemSize = itemSize;\n\n\t\t/**\n\t\t * Represents the number of items this buffer attribute stores. It is internally computed\n\t\t * by dividing the `array` length by the `itemSize`.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\n\t\t/**\n\t\t * Applies to integer data only. Indicates how the underlying data in the buffer maps to\n\t\t * the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,\n\t\t * and `normalized` is `true`, the values `0 - +65535` in the array data will be mapped to\n\t\t * `0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted\n\t\t * to floats unmodified, i.e. `65535` becomes `65535.0f`.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.normalized = normalized;\n\n\t\t/**\n\t\t * Defines the intended usage pattern of the data store for optimization purposes.\n\t\t *\n\t\t * Note: After the initial use of a buffer, its usage cannot be changed. Instead,\n\t\t * instantiate a new one and set the desired usage before the next render.\n\t\t *\n\t\t * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}\n\t\t * @default StaticDrawUsage\n\t\t */\n\t\tthis.usage = StaticDrawUsage;\n\n\t\t/**\n\t\t * This can be used to only update some components of stored vectors (for example, just the\n\t\t * component related to color). Use the `addUpdateRange()` function to add ranges to this array.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.updateRanges = [];\n\n\t\t/**\n\t\t * Configures the bound GPU type for use in shaders.\n\t\t *\n\t\t * Note: this only has an effect for integer arrays and is not configurable for float arrays.\n\t\t * For lower precision float types, use `Float16BufferAttribute`.\n\t\t *\n\t\t * @type {(FloatType|IntType)}\n\t\t * @default FloatType\n\t\t */\n\t\tthis.gpuType = FloatType;\n\n\t\t/**\n\t\t * A version number, incremented every time the `needsUpdate` is set to `true`.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.version = 0;\n\n\t}\n\n\t/**\n\t * A callback function that is executed after the renderer has transferred the attribute\n\t * array data to the GPU.\n\t */\n\tonUploadCallback() {}\n\n\t/**\n\t * Flag to indicate that this attribute has changed and should be re-sent to\n\t * the GPU. Set this to `true` when you modify the value of the array.\n\t *\n\t * @type {number}\n\t * @default false\n\t * @param {boolean} value\n\t */\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\t/**\n\t * Sets the usage of this buffer attribute.\n\t *\n\t * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.\n\t * @return {BufferAttribute} A reference to this buffer attribute.\n\t */\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a range of data in the data array to be updated on the GPU.\n\t *\n\t * @param {number} start - Position at which to start update.\n\t * @param {number} count - The number of components to update.\n\t */\n\taddUpdateRange( start, count ) {\n\n\t\tthis.updateRanges.push( { start, count } );\n\n\t}\n\n\t/**\n\t * Clears the update ranges.\n\t */\n\tclearUpdateRanges() {\n\n\t\tthis.updateRanges.length = 0;\n\n\t}\n\n\t/**\n\t * Copies the values of the given buffer attribute to this instance.\n\t *\n\t * @param {BufferAttribute} source - The buffer attribute to copy.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\t\tthis.count = source.count;\n\t\tthis.normalized = source.normalized;\n\n\t\tthis.usage = source.usage;\n\t\tthis.gpuType = source.gpuType;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies a vector from the given buffer attribute to this one. The start\n\t * and destination position in the attribute buffers are represented by the\n\t * given indices.\n\t *\n\t * @param {number} index1 - The destination index into this buffer attribute.\n\t * @param {BufferAttribute} attribute - The buffer attribute to copy from.\n\t * @param {number} index2 - The source index into the given buffer attribute.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( let i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the given array data into this buffer attribute.\n\t *\n\t * @param {(TypedArray|Array)} array - The array to copy.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tcopyArray( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Applies the given 3x3 matrix to the given attribute. Works with\n\t * item size `2` and `3`.\n\t *\n\t * @param {Matrix3} m - The matrix to apply.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tapplyMatrix3( m ) {\n\n\t\tif ( this.itemSize === 2 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector2.fromBufferAttribute( this, i );\n\t\t\t\t_vector2.applyMatrix3( m );\n\n\t\t\t\tthis.setXY( i, _vector2.x, _vector2.y );\n\n\t\t\t}\n\n\t\t} else if ( this.itemSize === 3 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( this, i );\n\t\t\t\t_vector.applyMatrix3( m );\n\n\t\t\t\tthis.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Applies the given 4x4 matrix to the given attribute. Only works with\n\t * item size `3`.\n\t *\n\t * @param {Matrix4} m - The matrix to apply.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( this, i );\n\n\t\t\t_vector.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Applies the given 3x3 normal matrix to the given attribute. Only works with\n\t * item size `3`.\n\t *\n\t * @param {Matrix3} m - The normal matrix to apply.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( this, i );\n\n\t\t\t_vector.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Applies the given 4x4 matrix to the given attribute. Only works with\n\t * item size `3` and with direction vectors.\n\t *\n\t * @param {Matrix4} m - The matrix to apply.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( this, i );\n\n\t\t\t_vector.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the given array data in the buffer attribute.\n\t *\n\t * @param {(TypedArray|Array)} value - The array data to set.\n\t * @param {number} [offset=0] - The offset in this buffer attribute's array.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tset( value, offset = 0 ) {\n\n\t\t// Matching BufferAttribute constructor, do not normalize the array.\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the given component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} component - The component index.\n\t * @return {number} The returned value.\n\t */\n\tgetComponent( index, component ) {\n\n\t\tlet value = this.array[ index * this.itemSize + component ];\n\n\t\tif ( this.normalized ) value = denormalize( value, this.array );\n\n\t\treturn value;\n\n\t}\n\n\t/**\n\t * Sets the given value to the given component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} component - The component index.\n\t * @param {number} value - The value to set.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tsetComponent( index, component, value ) {\n\n\t\tif ( this.normalized ) value = normalize( value, this.array );\n\n\t\tthis.array[ index * this.itemSize + component ] = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the x component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @return {number} The x component.\n\t */\n\tgetX( index ) {\n\n\t\tlet x = this.array[ index * this.itemSize ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\t/**\n\t * Sets the x component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} x - The value to set.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the y component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @return {number} The y component.\n\t */\n\tgetY( index ) {\n\n\t\tlet y = this.array[ index * this.itemSize + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\t/**\n\t * Sets the y component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} y - The value to set.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the z component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @return {number} The z component.\n\t */\n\tgetZ( index ) {\n\n\t\tlet z = this.array[ index * this.itemSize + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\t/**\n\t * Sets the z component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} z - The value to set.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the w component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @return {number} The w component.\n\t */\n\tgetW( index ) {\n\n\t\tlet w = this.array[ index * this.itemSize + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\t/**\n\t * Sets the w component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} w - The value to set.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the x and y component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} x - The value for the x component to set.\n\t * @param {number} y - The value for the y component to set.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the x, y and z component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} x - The value for the x component to set.\n\t * @param {number} y - The value for the y component to set.\n\t * @param {number} z - The value for the z component to set.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the x, y, z and w component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} x - The value for the x component to set.\n\t * @param {number} y - The value for the y component to set.\n\t * @param {number} z - The value for the z component to set.\n\t * @param {number} w - The value for the w component to set.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the given callback function that is executed after the Renderer has transferred\n\t * the attribute array data to the GPU. Can be used to perform clean-up operations after\n\t * the upload when attribute data are not needed anymore on the CPU side.\n\t *\n\t * @param {Function} callback - The `onUpload()` callback.\n\t * @return {BufferAttribute} A reference to this instance.\n\t */\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a new buffer attribute with copied values from this instance.\n\t *\n\t * @return {BufferAttribute} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\n\t}\n\n\t/**\n\t * Serializes the buffer attribute into JSON.\n\t *\n\t * @return {Object} A JSON object representing the serialized buffer attribute.\n\t */\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\titemSize: this.itemSize,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tarray: Array.from( this.array ),\n\t\t\tnormalized: this.normalized\n\t\t};\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( this.usage !== StaticDrawUsage ) data.usage = this.usage;\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Convenient class that can be used when creating a `Int8` buffer attribute with\n * a plain `Array` instance.\n *\n * @augments BufferAttribute\n */\nclass Int8BufferAttribute extends BufferAttribute {\n\n\t/**\n\t * Constructs a new buffer attribute.\n\t *\n\t * @param {(Array<number>|Int8Array)} array - The array holding the attribute data.\n\t * @param {number} itemSize - The item size.\n\t * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n\t */\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\n/**\n * Convenient class that can be used when creating a `UInt8` buffer attribute with\n * a plain `Array` instance.\n *\n * @augments BufferAttribute\n */\nclass Uint8BufferAttribute extends BufferAttribute {\n\n\t/**\n\t * Constructs a new buffer attribute.\n\t *\n\t * @param {(Array<number>|Uint8Array)} array - The array holding the attribute data.\n\t * @param {number} itemSize - The item size.\n\t * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n\t */\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\n/**\n * Convenient class that can be used when creating a `UInt8Clamped` buffer attribute with\n * a plain `Array` instance.\n *\n * @augments BufferAttribute\n */\nclass Uint8ClampedBufferAttribute extends BufferAttribute {\n\n\t/**\n\t * Constructs a new buffer attribute.\n\t *\n\t * @param {(Array<number>|Uint8ClampedArray)} array - The array holding the attribute data.\n\t * @param {number} itemSize - The item size.\n\t * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n\t */\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8ClampedArray( array ), itemSize, normalized );\n\n\t}\n\n}\n\n/**\n * Convenient class that can be used when creating a `Int16` buffer attribute with\n * a plain `Array` instance.\n *\n * @augments BufferAttribute\n */\nclass Int16BufferAttribute extends BufferAttribute {\n\n\t/**\n\t * Constructs a new buffer attribute.\n\t *\n\t * @param {(Array<number>|Int16Array)} array - The array holding the attribute data.\n\t * @param {number} itemSize - The item size.\n\t * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n\t */\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\n/**\n * Convenient class that can be used when creating a `UInt16` buffer attribute with\n * a plain `Array` instance.\n *\n * @augments BufferAttribute\n */\nclass Uint16BufferAttribute extends BufferAttribute {\n\n\t/**\n\t * Constructs a new buffer attribute.\n\t *\n\t * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.\n\t * @param {number} itemSize - The item size.\n\t * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n\t */\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\n/**\n * Convenient class that can be used when creating a `Int32` buffer attribute with\n * a plain `Array` instance.\n *\n * @augments BufferAttribute\n */\nclass Int32BufferAttribute extends BufferAttribute {\n\n\t/**\n\t * Constructs a new buffer attribute.\n\t *\n\t * @param {(Array<number>|Int32Array)} array - The array holding the attribute data.\n\t * @param {number} itemSize - The item size.\n\t * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n\t */\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\n/**\n * Convenient class that can be used when creating a `UInt32` buffer attribute with\n * a plain `Array` instance.\n *\n * @augments BufferAttribute\n */\nclass Uint32BufferAttribute extends BufferAttribute {\n\n\t/**\n\t * Constructs a new buffer attribute.\n\t *\n\t * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.\n\t * @param {number} itemSize - The item size.\n\t * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n\t */\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\n/**\n * Convenient class that can be used when creating a `Float16` buffer attribute with\n * a plain `Array` instance.\n *\n * This class automatically converts to and from FP16 via `Uint16Array` since `Float16Array`\n * browser support is still problematic.\n *\n * @augments BufferAttribute\n */\nclass Float16BufferAttribute extends BufferAttribute {\n\n\t/**\n\t * Constructs a new buffer attribute.\n\t *\n\t * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.\n\t * @param {number} itemSize - The item size.\n\t * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n\t */\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t\tthis.isFloat16BufferAttribute = true;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = fromHalfFloat( this.array[ index * this.itemSize ] );\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = toHalfFloat( x );\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\t\tthis.array[ index + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Convenient class that can be used when creating a `Float32` buffer attribute with\n * a plain `Array` instance.\n *\n * @augments BufferAttribute\n */\nclass Float32BufferAttribute extends BufferAttribute {\n\n\t/**\n\t * Constructs a new buffer attribute.\n\t *\n\t * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.\n\t * @param {number} itemSize - The item size.\n\t * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n\t */\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Float32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\n//\n\nexport {\n\tFloat32BufferAttribute,\n\tFloat16BufferAttribute,\n\tUint32BufferAttribute,\n\tInt32BufferAttribute,\n\tUint16BufferAttribute,\n\tInt16BufferAttribute,\n\tUint8ClampedBufferAttribute,\n\tUint8BufferAttribute,\n\tInt8BufferAttribute,\n\tBufferAttribute\n};\n", "import { Vector3 } from '../math/Vector3.js';\nimport { BufferAttribute } from './BufferAttribute.js';\nimport { denormalize, normalize } from '../math/MathUtils.js';\n\nconst _vector = /*@__PURE__*/ new Vector3();\n\n/**\n * An alternative version of a buffer attribute with interleaved data. Interleaved\n * attributes share a common interleaved data storage ({@link InterleavedBuffer}) and refer with\n * different offsets into the buffer.\n */\nclass InterleavedBufferAttribute {\n\n\t/**\n\t * Constructs a new interleaved buffer attribute.\n\t *\n\t * @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.\n\t * @param {number} itemSize - The item size.\n\t * @param {number} offset - The attribute offset into the buffer.\n\t * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n\t */\n\tconstructor( interleavedBuffer, itemSize, offset, normalized = false ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isInterleavedBufferAttribute = true;\n\n\t\t/**\n\t\t * The name of the buffer attribute.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = '';\n\n\t\t/**\n\t\t * The buffer holding the interleaved data.\n\t\t *\n\t\t * @type {InterleavedBuffer}\n\t\t */\n\t\tthis.data = interleavedBuffer;\n\n\t\t/**\n\t\t * The item size, see {@link BufferAttribute#itemSize}.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.itemSize = itemSize;\n\n\t\t/**\n\t\t * The attribute offset into the buffer.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.offset = offset;\n\n\t\t/**\n\t\t * Whether the data are normalized or not, see {@link BufferAttribute#normalized}\n\t\t *\n\t\t * @type {InterleavedBuffer}\n\t\t */\n\t\tthis.normalized = normalized;\n\n\t}\n\n\t/**\n\t * The item count of this buffer attribute.\n\t *\n\t * @type {number}\n\t * @readonly\n\t */\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t}\n\n\t/**\n\t * The array holding the interleaved buffer attribute data.\n\t *\n\t * @type {TypedArray}\n\t */\n\tget array() {\n\n\t\treturn this.data.array;\n\n\t}\n\n\t/**\n\t * Flag to indicate that this attribute has changed and should be re-sent to\n\t * the GPU. Set this to `true` when you modify the value of the array.\n\t *\n\t * @type {number}\n\t * @default false\n\t * @param {boolean} value\n\t */\n\tset needsUpdate( value ) {\n\n\t\tthis.data.needsUpdate = value;\n\n\t}\n\n\t/**\n\t * Applies the given 4x4 matrix to the given attribute. Only works with\n\t * item size `3`.\n\t *\n\t * @param {Matrix4} m - The matrix to apply.\n\t * @return {InterleavedBufferAttribute} A reference to this instance.\n\t */\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.data.count; i < l; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( this, i );\n\n\t\t\t_vector.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Applies the given 3x3 normal matrix to the given attribute. Only works with\n\t * item size `3`.\n\t *\n\t * @param {Matrix3} m - The normal matrix to apply.\n\t * @return {InterleavedBufferAttribute} A reference to this instance.\n\t */\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( this, i );\n\n\t\t\t_vector.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Applies the given 4x4 matrix to the given attribute. Only works with\n\t * item size `3` and with direction vectors.\n\t *\n\t * @param {Matrix4} m - The matrix to apply.\n\t * @return {InterleavedBufferAttribute} A reference to this instance.\n\t */\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( this, i );\n\n\t\t\t_vector.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the given component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} component - The component index.\n\t * @return {number} The returned value.\n\t */\n\tgetComponent( index, component ) {\n\n\t\tlet value = this.array[ index * this.data.stride + this.offset + component ];\n\n\t\tif ( this.normalized ) value = denormalize( value, this.array );\n\n\t\treturn value;\n\n\t}\n\n\t/**\n\t * Sets the given value to the given component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} component - The component index.\n\t * @param {number} value - The value to set.\n\t * @return {InterleavedBufferAttribute} A reference to this instance.\n\t */\n\tsetComponent( index, component, value ) {\n\n\t\tif ( this.normalized ) value = normalize( value, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + component ] = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the x component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} x - The value to set.\n\t * @return {InterleavedBufferAttribute} A reference to this instance.\n\t */\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the y component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} y - The value to set.\n\t * @return {InterleavedBufferAttribute} A reference to this instance.\n\t */\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the z component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} z - The value to set.\n\t * @return {InterleavedBufferAttribute} A reference to this instance.\n\t */\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the w component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} w - The value to set.\n\t * @return {InterleavedBufferAttribute} A reference to this instance.\n\t */\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the x component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @return {number} The x component.\n\t */\n\tgetX( index ) {\n\n\t\tlet x = this.data.array[ index * this.data.stride + this.offset ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\t/**\n\t * Returns the y component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @return {number} The y component.\n\t */\n\tgetY( index ) {\n\n\t\tlet y = this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\t/**\n\t * Returns the z component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @return {number} The z component.\n\t */\n\tgetZ( index ) {\n\n\t\tlet z = this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\t/**\n\t * Returns the w component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @return {number} The w component.\n\t */\n\tgetW( index ) {\n\n\t\tlet w = this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\t/**\n\t * Sets the x and y component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} x - The value for the x component to set.\n\t * @param {number} y - The value for the y component to set.\n\t * @return {InterleavedBufferAttribute} A reference to this instance.\n\t */\n\tsetXY( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the x, y and z component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} x - The value for the x component to set.\n\t * @param {number} y - The value for the y component to set.\n\t * @param {number} z - The value for the z component to set.\n\t * @return {InterleavedBufferAttribute} A reference to this instance.\n\t */\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the x, y, z and w component of the vector at the given index.\n\t *\n\t * @param {number} index - The index into the buffer attribute.\n\t * @param {number} x - The value for the x component to set.\n\t * @param {number} y - The value for the y component to set.\n\t * @param {number} z - The value for the z component to set.\n\t * @param {number} w - The value for the w component to set.\n\t * @return {InterleavedBufferAttribute} A reference to this instance.\n\t */\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a new buffer attribute with copied values from this instance.\n\t *\n\t * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.\n\t *\n\t * @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.\n\t * @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.\n\t */\n\tclone( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );\n\n\t\t} else {\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );\n\n\t\t\t}\n\n\t\t\treturn new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Serializes the buffer attribute into JSON.\n\t *\n\t * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.\n\t *\n\t * @param {Object} [data] - An optional value holding meta information about the serialization.\n\t * @return {Object} A JSON object representing the serialized buffer attribute.\n\t */\n\ttoJSON( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// de-interleave data and save it as an ordinary buffer attribute for now\n\n\t\t\treturn {\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t} else {\n\n\t\t\t// save as true interleaved attribute\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tisInterleavedBufferAttribute: true,\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\tdata: this.data.uuid,\n\t\t\t\toffset: this.offset,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { InterleavedBufferAttribute };\n", "import { generateUUID } from '../math/MathUtils.js';\nimport { StaticDrawUsage } from '../constants.js';\n\n/**\n * \"Interleaved\" means that multiple attributes, possibly of different types,\n * (e.g., position, normal, uv, color) are packed into a single array buffer.\n *\n * An introduction into interleaved arrays can be found here: [Interleaved array basics]{@link https://blog.tojicode.com/2011/05/interleaved-array-basics.html}\n */\nclass InterleavedBuffer {\n\n\t/**\n\t * Constructs a new interleaved buffer.\n\t *\n\t * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.\n\t * @param {number} stride - The number of typed-array elements per vertex.\n\t */\n\tconstructor( array, stride ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isInterleavedBuffer = true;\n\n\t\t/**\n\t\t * A typed array with a shared buffer storing attribute data.\n\t\t *\n\t\t * @type {TypedArray}\n\t\t */\n\t\tthis.array = array;\n\n\t\t/**\n\t\t * The number of typed-array elements per vertex.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.stride = stride;\n\n\t\t/**\n\t\t * The total number of elements in the array\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\t/**\n\t\t * Defines the intended usage pattern of the data store for optimization purposes.\n\t\t *\n\t\t * Note: After the initial use of a buffer, its usage cannot be changed. Instead,\n\t\t * instantiate a new one and set the desired usage before the next render.\n\t\t *\n\t\t * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}\n\t\t * @default StaticDrawUsage\n\t\t */\n\t\tthis.usage = StaticDrawUsage;\n\n\t\t/**\n\t\t * This can be used to only update some components of stored vectors (for example, just the\n\t\t * component related to color). Use the `addUpdateRange()` function to add ranges to this array.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.updateRanges = [];\n\n\t\t/**\n\t\t * A version number, incremented every time the `needsUpdate` is set to `true`.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * The UUID of the interleaved buffer.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = generateUUID();\n\n\t}\n\n\t/**\n\t * A callback function that is executed after the renderer has transferred the attribute array\n\t * data to the GPU.\n\t */\n\tonUploadCallback() {}\n\n\t/**\n\t * Flag to indicate that this attribute has changed and should be re-sent to\n\t * the GPU. Set this to `true` when you modify the value of the array.\n\t *\n\t * @type {number}\n\t * @default false\n\t * @param {boolean} value\n\t */\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\t/**\n\t * Sets the usage of this interleaved buffer.\n\t *\n\t * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.\n\t * @return {InterleavedBuffer} A reference to this interleaved buffer.\n\t */\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a range of data in the data array to be updated on the GPU.\n\t *\n\t * @param {number} start - Position at which to start update.\n\t * @param {number} count - The number of components to update.\n\t */\n\taddUpdateRange( start, count ) {\n\n\t\tthis.updateRanges.push( { start, count } );\n\n\t}\n\n\t/**\n\t * Clears the update ranges.\n\t */\n\tclearUpdateRanges() {\n\n\t\tthis.updateRanges.length = 0;\n\n\t}\n\n\t/**\n\t * Copies the values of the given interleaved buffer to this instance.\n\t *\n\t * @param {InterleavedBuffer} source - The interleaved buffer to copy.\n\t * @return {InterleavedBuffer} A reference to this instance.\n\t */\n\tcopy( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.count = source.count;\n\t\tthis.stride = source.stride;\n\t\tthis.usage = source.usage;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies a vector from the given interleaved buffer to this one. The start\n\t * and destination position in the attribute buffers are represented by the\n\t * given indices.\n\t *\n\t * @param {number} index1 - The destination index into this interleaved buffer.\n\t * @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.\n\t * @param {number} index2 - The source index into the given interleaved buffer.\n\t * @return {InterleavedBuffer} A reference to this instance.\n\t */\n\tcopyAt( index1, interleavedBuffer, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= interleavedBuffer.stride;\n\n\t\tfor ( let i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = interleavedBuffer.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the given array data in the interleaved buffer.\n\t *\n\t * @param {(TypedArray|Array)} value - The array data to set.\n\t * @param {number} [offset=0] - The offset in this interleaved buffer's array.\n\t * @return {InterleavedBuffer} A reference to this instance.\n\t */\n\tset( value, offset = 0 ) {\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a new interleaved buffer with copied values from this instance.\n\t *\n\t * @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.\n\t * @return {InterleavedBuffer} A clone of this instance.\n\t */\n\tclone( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;\n\n\t\t}\n\n\t\tconst array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );\n\n\t\tconst ib = new this.constructor( array, this.stride );\n\t\tib.setUsage( this.usage );\n\n\t\treturn ib;\n\n\t}\n\n\t/**\n\t * Sets the given callback function that is executed after the Renderer has transferred\n\t * the array data to the GPU. Can be used to perform clean-up operations after\n\t * the upload when data are not needed anymore on the CPU side.\n\t *\n\t * @param {Function} callback - The `onUpload()` callback.\n\t * @return {InterleavedBuffer} A reference to this instance.\n\t */\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Serializes the interleaved buffer into JSON.\n\t *\n\t * @param {Object} [data] - An optional value holding meta information about the serialization.\n\t * @return {Object} A JSON object representing the serialized interleaved buffer.\n\t */\n\ttoJSON( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\t// generate UUID for array buffer if necessary\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );\n\n\t\t}\n\n\t\t//\n\n\t\treturn {\n\t\t\tuuid: this.uuid,\n\t\t\tbuffer: this.array.buffer._uuid,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tstride: this.stride\n\t\t};\n\n\t}\n\n}\n\nexport { InterleavedBuffer };\n", "import InputNode from '../core/InputNode.js';\nimport { nodeObject, addMethodChaining } from '../tsl/TSLCore.js';\nimport { varying } from '../core/VaryingNode.js';\n\nimport { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';\nimport { InterleavedBuffer } from '../../core/InterleavedBuffer.js';\nimport { StaticDrawUsage, DynamicDrawUsage } from '../../constants.js';\n\n/**\n * In earlier `three.js` versions it was only possible to define attribute data\n * on geometry level. With `BufferAttributeNode`, it is also possible to do this\n * on the node level.\n * ```js\n * const geometry = new THREE.PlaneGeometry();\n * const positionAttribute = geometry.getAttribute( 'position' );\n *\n * const colors = [];\n * for ( let i = 0; i < position.count; i ++ ) {\n * \tcolors.push( 1, 0, 0 );\n * }\n *\n * material.colorNode = bufferAttribute( new THREE.Float32BufferAttribute( colors, 3 ) );\n * ```\n * This new approach is especially interesting when geometry data are generated via\n * compute shaders. The below line converts a storage buffer into an attribute node.\n * ```js\n * material.positionNode = positionBuffer.toAttribute();\n * ```\n * @augments InputNode\n */\nclass BufferAttributeNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'BufferAttributeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer attribute node.\n\t *\n\t * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.\n\t * @param {?string} [bufferType=null] - The buffer type (e.g. `'vec3'`).\n\t * @param {number} [bufferStride=0] - The buffer stride.\n\t * @param {number} [bufferOffset=0] - The buffer offset.\n\t */\n\tconstructor( value, bufferType = null, bufferStride = 0, bufferOffset = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferNode = true;\n\n\t\t/**\n\t\t * The buffer type (e.g. `'vec3'`).\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.bufferType = bufferType;\n\n\t\t/**\n\t\t * The buffer stride.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferStride = bufferStride;\n\n\t\t/**\n\t\t * The buffer offset.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferOffset = bufferOffset;\n\n\t\t/**\n\t\t * The usage property. Set this to `THREE.DynamicDrawUsage` via `.setUsage()`,\n\t\t * if you are planning to update the attribute data per frame.\n\t\t *\n\t\t * @type {number}\n\t\t * @default StaticDrawUsage\n\t\t */\n\t\tthis.usage = StaticDrawUsage;\n\n\t\t/**\n\t\t * Whether the attribute is instanced or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.instanced = false;\n\n\t\t/**\n\t\t * A reference to the buffer attribute.\n\t\t *\n\t\t * @type {?BufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.attribute = null;\n\n\t\t/**\n\t\t * `BufferAttributeNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tif ( value && value.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute = value;\n\t\t\tthis.usage = value.usage;\n\t\t\tthis.instanced = value.isInstancedBufferAttribute;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is overwritten since the attribute data might be shared\n\t * and thus the hash should be shared as well.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The hash.\n\t */\n\tgetHash( builder ) {\n\n\t\tif ( this.bufferStride === 0 && this.bufferOffset === 0 ) {\n\n\t\t\tlet bufferData = builder.globalCache.getData( this.value );\n\n\t\t\tif ( bufferData === undefined ) {\n\n\t\t\t\tbufferData = {\n\t\t\t\t\tnode: this\n\t\t\t\t};\n\n\t\t\t\tbuilder.globalCache.setData( this.value, bufferData );\n\n\t\t\t}\n\n\t\t\treturn bufferData.node.uuid;\n\n\t\t}\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the buffer attribute.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.bufferType === null ) {\n\n\t\t\tthis.bufferType = builder.getTypeFromAttribute( this.attribute );\n\n\t\t}\n\n\t\treturn this.bufferType;\n\n\t}\n\n\t/**\n\t * Depending on which value was passed to the node, `setup()` behaves\n\t * differently. If no instance of `BufferAttribute` was passed, the method\n\t * creates an internal attribute and configures it respectively.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this.attribute !== null ) return;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst array = this.value;\n\t\tconst itemSize = builder.getTypeLength( type );\n\t\tconst stride = this.bufferStride || itemSize;\n\t\tconst offset = this.bufferOffset;\n\n\t\tconst buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer( array, stride );\n\t\tconst bufferAttribute = new InterleavedBufferAttribute( buffer, itemSize, offset );\n\n\t\tbuffer.setUsage( this.usage );\n\n\t\tthis.attribute = bufferAttribute;\n\t\tthis.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the buffer attribute node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( builder ) {\n\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tconst nodeAttribute = builder.getBufferAttributeFromNode( this, nodeType );\n\t\tconst propertyName = builder.getPropertyName( nodeAttribute );\n\n\t\tlet output = null;\n\n\t\tif ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {\n\n\t\t\tthis.name = propertyName;\n\n\t\t\toutput = propertyName;\n\n\t\t} else {\n\n\t\t\tconst nodeVarying = varying( this );\n\n\t\t\toutput = nodeVarying.build( builder, nodeType );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'bufferAttribute';\n\n\t}\n\n\t/**\n\t * Sets the `usage` property to the given value.\n\t *\n\t * @param {number} value - The usage to set.\n\t * @return {BufferAttributeNode} A reference to this node.\n\t */\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\tif ( this.attribute && this.attribute.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute.usage = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the `instanced` property to the given value.\n\t *\n\t * @param {boolean} value - The value to set.\n\t * @return {BufferAttributeNode} A reference to this node.\n\t */\n\tsetInstanced( value ) {\n\n\t\tthis.instanced = value;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport default BufferAttributeNode;\n\n/**\n * TSL function for creating a buffer attribute node.\n *\n * @tsl\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [stride=0] - The buffer stride.\n * @param {number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nexport const bufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => nodeObject( new BufferAttributeNode( array, type, stride, offset ) );\n\n/**\n * TSL function for creating a buffer attribute node but with dynamic draw usage.\n * Use this function if attribute data are updated per frame.\n *\n * @tsl\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [stride=0] - The buffer stride.\n * @param {number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nexport const dynamicBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => bufferAttribute( array, type, stride, offset ).setUsage( DynamicDrawUsage );\n\n/**\n * TSL function for creating a buffer attribute node but with enabled instancing\n *\n * @tsl\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [stride=0] - The buffer stride.\n * @param {number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nexport const instancedBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => bufferAttribute( array, type, stride, offset ).setInstanced( true );\n\n/**\n * TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing\n *\n * @tsl\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [stride=0] - The buffer stride.\n * @param {number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nexport const instancedDynamicBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => dynamicBufferAttribute( array, type, stride, offset ).setInstanced( true );\n\naddMethodChaining( 'toAttribute', ( bufferNode ) => bufferAttribute( bufferNode.value ) );\n", "import Node from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { addMethodChaining, nodeObject } from '../tsl/TSLCore.js';\n\n/**\n * TODO\n *\n * @augments Node\n */\nclass ComputeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ComputeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new compute node.\n\t *\n\t * @param {Node} computeNode - TODO\n\t * @param {Array<number>} workgroupSize - TODO.\n\t */\n\tconstructor( computeNode, workgroupSize ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isComputeNode = true;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.computeNode = computeNode;\n\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Array<number>}\n\t\t * @default [ 64 ]\n\t\t */\n\t\tthis.workgroupSize = workgroupSize;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.count = null;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.version = 1;\n\n\t\t/**\n\t\t * The name or label of the uniform.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = '';\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.OBJECT` since {@link ComputeNode#updateBefore}\n\t\t * is executed once per object by default.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {?Function}\n\t\t */\n\t\tthis.onInitFunction = null;\n\n\t}\n\n\tsetCount( count ) {\n\n\t\tthis.count = count;\n\n\t\treturn this;\n\n\t}\n\n\tgetCount() {\n\n\t\treturn this.count;\n\n\t}\n\n\t/**\n\t * Executes the `dispose` event for this node.\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\t/**\n\t * Sets the {@link ComputeNode#name} property.\n\t *\n\t * @param {string} name - The name of the uniform.\n\t * @return {ComputeNode} A reference to this node.\n\t */\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the {@link ComputeNode#name} property.\n\t *\n\t * @deprecated\n\t * @param {string} name - The name of the uniform.\n\t * @return {ComputeNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\tconsole.warn( 'THREE.TSL: \"label()\" has been deprecated. Use \"setName()\" instead.' ); // @deprecated r179\n\n\t\treturn this.setName( name );\n\n\t}\n\n\t/**\n\t * TODO\n\t *\n\t * @param {Function} callback - TODO.\n\t * @return {ComputeNode} A reference to this node.\n\t */\n\tonInit( callback ) {\n\n\t\tthis.onInitFunction = callback;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The method execute the compute for this node.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateBefore( { renderer } ) {\n\n\t\trenderer.compute( this );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst result = this.computeNode.build( builder );\n\n\t\tif ( result ) {\n\n\t\t\tconst properties = builder.getNodeProperties( this );\n\t\t\tproperties.outputComputeNode = result.outputNode;\n\n\t\t\tresult.outputNode = null;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { shaderStage } = builder;\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tconst snippet = this.computeNode.build( builder, 'void' );\n\n\t\t\tif ( snippet !== '' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst properties = builder.getNodeProperties( this );\n\t\t\tconst outputComputeNode = properties.outputComputeNode;\n\n\t\t\tif ( outputComputeNode ) {\n\n\t\t\t\treturn outputComputeNode.build( builder, output );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport default ComputeNode;\n\n/**\n * TSL function for creating a compute kernel node.\n *\n * @tsl\n * @function\n * @param {Node} node - TODO\n * @param {Array<number>} [workgroupSize=[64]] - TODO.\n * @returns {AtomicFunctionNode}\n */\nexport const computeKernel = ( node, workgroupSize = [ 64 ] ) => {\n\n\tif ( workgroupSize.length === 0 || workgroupSize.length > 3 ) {\n\n\t\tconsole.error( 'THREE.TSL: compute() workgroupSize must have 1, 2, or 3 elements' );\n\n\t}\n\n\tfor ( let i = 0; i < workgroupSize.length; i ++ ) {\n\n\t\tconst val = workgroupSize[ i ];\n\n\t\tif ( typeof val !== 'number' || val <= 0 || ! Number.isInteger( val ) ) {\n\n\t\t\tconsole.error( `THREE.TSL: compute() workgroupSize element at index [ ${ i } ] must be a positive integer` );\n\n\t\t}\n\n\t}\n\n\t// Implicit fill-up to [ x, y, z ] with 1s, just like WGSL treats @workgroup_size when fewer dimensions are specified\n\n\twhile ( workgroupSize.length < 3 ) workgroupSize.push( 1 );\n\n\t//\n\n\treturn nodeObject( new ComputeNode( nodeObject( node ), workgroupSize ) );\n\n};\n\n/**\n * TSL function for creating a compute node.\n *\n * @tsl\n * @function\n * @param {Node} node - TODO\n * @param {number} count - TODO.\n * @param {Array<number>} [workgroupSize=[64]] - TODO.\n * @returns {AtomicFunctionNode}\n */\nexport const compute = ( node, count, workgroupSize ) => computeKernel( node, workgroupSize ).setCount( count );\n\naddMethodChaining( 'compute', compute );\naddMethodChaining( 'computeKernel', computeKernel );\n", "import Node from './Node.js';\nimport { addMethodChaining, nodeObject } from '../tsl/TSLCore.js';\n\n/**\n * This node can be used as a cache management component for another node.\n * Caching is in general used by default in {@link NodeBuilder} but this node\n * allows the usage of a shared parent cache during the build process.\n *\n * @augments Node\n */\nclass CacheNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'CacheNode';\n\n\t}\n\n\t/**\n\t * Constructs a new cache node.\n\t *\n\t * @param {Node} node - The node that should be cached.\n\t * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.\n\t */\n\tconstructor( node, parent = true ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be cached.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * Whether this node refers to a shared parent cache or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isCacheNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst previousCache = builder.getCache();\n\t\tconst cache = builder.getCacheFromNode( this, this.parent );\n\n\t\tbuilder.setCache( cache );\n\n\t\tconst nodeType = this.node.getNodeType( builder );\n\n\t\tbuilder.setCache( previousCache );\n\n\t\treturn nodeType;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousCache = builder.getCache();\n\t\tconst cache = builder.getCacheFromNode( this, this.parent );\n\n\t\tbuilder.setCache( cache );\n\n\t\tconst data = this.node.build( builder, ...params );\n\n\t\tbuilder.setCache( previousCache );\n\n\t\treturn data;\n\n\t}\n\n}\n\nexport default CacheNode;\n\n/**\n * TSL function for creating a cache node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node that should be cached.\n * @param {boolean} [parent] - Whether this node refers to a shared parent cache or not.\n * @returns {CacheNode}\n */\nexport const cache = ( node, parent ) => nodeObject( new CacheNode( nodeObject( node ), parent ) );\n\naddMethodChaining( 'cache', cache );\n", "import Node from './Node.js';\nimport { addMethodChaining, nodeProxy } from '../tsl/TSLCore.js';\n\n/**\n * The class generates the code of a given node but returns another node in the output.\n * This can be used to call a method or node that does not return a value, i.e.\n * type `void` on an input where returning a value is required. Example:\n *\n * ```js\n * material.colorNode = myColor.bypass( runVoidFn() )\n *```\n *\n * @augments Node\n */\nclass BypassNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'BypassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new bypass node.\n\t *\n\t * @param {Node} outputNode - The output node.\n\t * @param {Node} callNode - The call node.\n\t */\n\tconstructor( outputNode, callNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBypassNode = true;\n\n\t\t/**\n\t\t * The output node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.outputNode = outputNode;\n\n\t\t/**\n\t\t * The call node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.callNode = callNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = this.callNode.build( builder, 'void' );\n\n\t\tif ( snippet !== '' ) {\n\n\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t}\n\n\t\treturn this.outputNode.build( builder );\n\n\t}\n\n}\n\nexport default BypassNode;\n\n/**\n * TSL function for creating a bypass node.\n *\n * @tsl\n * @function\n * @param {Node} outputNode - The output node.\n * @param {Node} callNode - The call node.\n * @returns {BypassNode}\n */\nexport const bypass = /*@__PURE__*/ nodeProxy( BypassNode ).setParameterLength( 2 );\n\naddMethodChaining( 'bypass', bypass );\n", "import Node from '../core/Node.js';\nimport { float, addMethodChaining, nodeProxy } from '../tsl/TSLCore.js';\n\n/**\n * This node allows to remap a node value from one range into another. E.g a value of\n * `0.4` in the range `[ 0.3, 0.5 ]` should be remapped into the normalized range `[ 0, 1 ]`.\n * `RemapNode` takes care of that and converts the original value of `0.4` to `0.5`.\n *\n * @augments Node\n */\nclass RemapNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'RemapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new remap node.\n\t *\n\t * @param {Node} node - The node that should be remapped.\n\t * @param {Node} inLowNode - The source or current lower bound of the range.\n\t * @param {Node} inHighNode - The source or current upper bound of the range.\n\t * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.\n\t * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.\n\t */\n\tconstructor( node, inLowNode, inHighNode, outLowNode = float( 0 ), outHighNode = float( 1 ) ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be remapped.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The source or current lower bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.inLowNode = inLowNode;\n\n\t\t/**\n\t\t * The source or current upper bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.inHighNode = inHighNode;\n\n\t\t/**\n\t\t * The target lower bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default float(0)\n\t\t */\n\t\tthis.outLowNode = outLowNode;\n\n\t\t/**\n\t\t * The target upper bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default float(1)\n\t\t */\n\t\tthis.outHighNode = outHighNode;\n\n\t\t/**\n\t\t * Whether the node value should be clamped before\n\t\t * remapping it to the target range.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.doClamp = true;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;\n\n\t\tlet t = node.sub( inLowNode ).div( inHighNode.sub( inLowNode ) );\n\n\t\tif ( doClamp === true ) t = t.clamp();\n\n\t\treturn t.mul( outHighNode.sub( outLowNode ) ).add( outLowNode );\n\n\t}\n\n}\n\nexport default RemapNode;\n\n/**\n * TSL function for creating a remap node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node that should be remapped.\n * @param {Node} inLowNode - The source or current lower bound of the range.\n * @param {Node} inHighNode - The source or current upper bound of the range.\n * @param {?Node} [outLowNode=float(0)] - The target lower bound of the range.\n * @param {?Node} [outHighNode=float(1)] - The target upper bound of the range.\n * @returns {RemapNode}\n */\nexport const remap = /*@__PURE__*/ nodeProxy( RemapNode, null, null, { doClamp: false } ).setParameterLength( 3, 5 );\n\n/**\n * TSL function for creating a remap node, but with enabled clamping.\n *\n * @tsl\n * @function\n * @param {Node} node - The node that should be remapped.\n * @param {Node} inLowNode - The source or current lower bound of the range.\n * @param {Node} inHighNode - The source or current upper bound of the range.\n * @param {?Node} [outLowNode=float(0)] - The target lower bound of the range.\n * @param {?Node} [outHighNode=float(1)] - The target upper bound of the range.\n * @returns {RemapNode}\n */\nexport const remapClamp = /*@__PURE__*/ nodeProxy( RemapNode ).setParameterLength( 3, 5 );\n\naddMethodChaining( 'remap', remap );\naddMethodChaining( 'remapClamp', remapClamp );\n", "import Node from '../core/Node.js';\nimport { nodeProxy } from '../tsl/TSLCore.js';\n\n/**\n * This class can be used to implement basic expressions in shader code.\n * Basic examples for that are `return`, `continue` or `discard` statements.\n *\n * @augments Node\n */\nclass ExpressionNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ExpressionNode';\n\n\t}\n\n\t/**\n\t * Constructs a new expression node.\n\t *\n\t * @param {string} [snippet=''] - The native code snippet.\n\t * @param {string} [nodeType='void'] - The node type.\n\t */\n\tconstructor( snippet = '', nodeType = 'void' ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The native code snippet.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.snippet = snippet;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst snippet = this.snippet;\n\n\t\tif ( type === 'void' ) {\n\n\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t} else {\n\n\t\t\treturn builder.format( snippet, type, output );\n\n\t\t}\n\n\t}\n\n}\n\nexport default ExpressionNode;\n\n/**\n * TSL function for creating an expression node.\n *\n * @tsl\n * @function\n * @param {string} [snippet] - The native code snippet.\n * @param {?string} [nodeType='void'] - The node type.\n * @returns {ExpressionNode}\n */\nexport const expression = /*@__PURE__*/ nodeProxy( ExpressionNode ).setParameterLength( 1, 2 );\n", "import { select } from '../math/ConditionalNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { addMethodChaining } from '../tsl/TSLCore.js';\n\n/**\n * Represents a `discard` shader operation in TSL.\n *\n * @tsl\n * @function\n * @param {?ConditionalNode} conditional - An optional conditional node. It allows to decide whether the discard should be executed or not.\n * @return {Node} The `discard` expression.\n */\nexport const Discard = ( conditional ) => ( conditional ? select( conditional, expression( 'discard' ) ) : expression( 'discard' ) ).toStack();\n\n/**\n * Represents a `return` shader operation in TSL.\n *\n * @tsl\n * @function\n * @return {ExpressionNode} The `return` expression.\n */\nexport const Return = () => expression( 'return' ).toStack();\n\naddMethodChaining( 'discard', Discard );\n", "import TempNode from '../core/TempNode.js';\nimport { addMethodChaining, nodeObject } from '../tsl/TSLCore.js';\n\nimport { NoColorSpace, NoToneMapping } from '../../constants.js';\nimport { ColorManagement } from '../../math/ColorManagement.js';\n\n/**\n * Normally, tone mapping and color conversion happens automatically\n * before outputting pixel too the default (screen) framebuffer. In certain\n * post processing setups this happens to late because certain effects\n * require e.g. sRGB input. For such scenarios, `RenderOutputNode` can be used\n * to apply tone mapping and color space conversion at an arbitrary point\n * in the effect chain.\n *\n * When applying tone mapping and color space conversion manually with this node,\n * you have to set {@link PostProcessing#outputColorTransform} to `false`.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n * postProcessing.outputColorTransform = false;\n *\n * const scenePass = pass( scene, camera );\n * const outputPass = renderOutput( scenePass );\n *\n * postProcessing.outputNode = outputPass;\n * ```\n *\n * @augments TempNode\n */\nclass RenderOutputNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'RenderOutputNode';\n\n\t}\n\n\t/**\n\t * Constructs a new render output node.\n\t *\n\t * @param {Node} colorNode - The color node to process.\n\t * @param {?number} toneMapping - The tone mapping type.\n\t * @param {?string} outputColorSpace - The output color space.\n\t */\n\tconstructor( colorNode, toneMapping, outputColorSpace ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The color node to process.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t\t/**\n\t\t * The tone mapping type.\n\t\t *\n\t\t * @type {?number}\n\t\t */\n\t\tthis.toneMapping = toneMapping;\n\n\t\t/**\n\t\t * The output color space.\n\t\t *\n\t\t * @type {?string}\n\t\t */\n\t\tthis.outputColorSpace = outputColorSpace;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderOutputNode = true;\n\n\t}\n\n\tsetup( { context } ) {\n\n\t\tlet outputNode = this.colorNode || context.color;\n\n\t\t// tone mapping\n\n\t\tconst toneMapping = ( this.toneMapping !== null ? this.toneMapping : context.toneMapping ) || NoToneMapping;\n\t\tconst outputColorSpace = ( this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace ) || NoColorSpace;\n\n\t\tif ( toneMapping !== NoToneMapping ) {\n\n\t\t\toutputNode = outputNode.toneMapping( toneMapping );\n\n\t\t}\n\n\t\t// working to output color space\n\n\t\tif ( outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace ) {\n\n\t\t\toutputNode = outputNode.workingToColorSpace( outputColorSpace );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nexport default RenderOutputNode;\n\n/**\n * TSL function for creating a posterize node.\n *\n * @tsl\n * @function\n * @param {Node} color - The color node to process.\n * @param {?number} [toneMapping=null] - The tone mapping type.\n * @param {?string} [outputColorSpace=null] - The output color space.\n * @returns {RenderOutputNode}\n */\nexport const renderOutput = ( color, toneMapping = null, outputColorSpace = null ) => nodeObject( new RenderOutputNode( nodeObject( color ), toneMapping, outputColorSpace ) );\n\naddMethodChaining( 'renderOutput', renderOutput );\n", "import TempNode from '../core/TempNode.js';\nimport { addMethodChaining, nodeObject } from '../tsl/TSLCore.js';\n\nclass DebugNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'DebugNode';\n\n\t}\n\n\tconstructor( node, callback = null ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.callback = callback;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\treturn this.node.build( builder );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\treturn this.node.build( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst callback = this.callback;\n\t\tconst snippet = this.node.build( builder );\n\n\t\tconst title = '--- TSL debug - ' + builder.shaderStage + ' shader ---';\n\t\tconst border = '-'.repeat( title.length );\n\n\t\tlet code = '';\n\t\tcode += '// #' + title + '#\\n';\n\t\tcode += builder.flow.code.replace( /^\\t/mg, '' ) + '\\n';\n\t\tcode += '/* ... */ ' + snippet + ' /* ... */\\n';\n\t\tcode += '// #' + border + '#\\n';\n\n\t\tif ( callback !== null ) {\n\n\t\t\tcallback( builder, code );\n\n\t\t} else {\n\n\t\t\tconsole.log( code );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n}\n\nexport default DebugNode;\n\n/**\n * TSL function for creating a debug node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node to debug.\n * @param {?Function} [callback=null] - Optional callback function to handle the debug output.\n * @returns {DebugNode}\n */\nexport const debug = ( node, callback = null ) => nodeObject( new DebugNode( nodeObject( node ), callback ) ).toStack();\n\naddMethodChaining( 'debug', debug );\n", "import { Vector3 } from './Vector3.js';\n\n/**\n * Represents an axis-aligned bounding box (AABB) in 3D space.\n */\nclass Box3 {\n\n\t/**\n\t * Constructs a new bounding box.\n\t *\n\t * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.\n\t * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.\n\t */\n\tconstructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBox3 = true;\n\n\t\t/**\n\t\t * The lower boundary of the box.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.min = min;\n\n\t\t/**\n\t\t * The upper boundary of the box.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.max = max;\n\n\t}\n\n\t/**\n\t * Sets the lower and upper boundaries of this box.\n\t * Please note that this method only copies the values from the given objects.\n\t *\n\t * @param {Vector3} min - The lower boundary of the box.\n\t * @param {Vector3} max - The upper boundary of the box.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the upper and lower bounds of this box so it encloses the position data\n\t * in the given array.\n\t *\n\t * @param {Array<number>} array - An array holding 3D position data.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tsetFromArray( array ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\tthis.expandByPoint( _vector.fromArray( array, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the upper and lower bounds of this box so it encloses the position data\n\t * in the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tsetFromBufferAttribute( attribute ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( _vector.fromBufferAttribute( attribute, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the upper and lower bounds of this box so it encloses the position data\n\t * in the given array.\n\t *\n\t * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Centers this box on the given center vector and sets this box's width, height and\n\t * depth to the given size values.\n\t *\n\t * @param {Vector3} center - The center of the box.\n\t * @param {Vector3} size - The x, y and z dimensions of the box.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector.copy( size ).multiplyScalar( 0.5 );\n\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the world-axis-aligned bounding box for the given 3D object\n\t * (including its children), accounting for the object's, and children's,\n\t * world transforms. The function may result in a larger box than strictly necessary.\n\t *\n\t * @param {Object3D} object - The 3D object to compute the bounding box for.\n\t * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest\n\t * world-axis-aligned bounding box at the expense of more computation.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tsetFromObject( object, precise = false ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object, precise );\n\n\t}\n\n\t/**\n\t * Returns a new box with copied values from this instance.\n\t *\n\t * @return {Box3} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Copies the values of the given box to this instance.\n\t *\n\t * @param {Box3} box - The box to copy.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Makes this box empty which means in encloses a zero space in 3D.\n\t *\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns true if this box includes zero points within its bounds.\n\t * Note that a box with equal lower and upper bounds still includes one\n\t * point, the one both bounds share.\n\t *\n\t * @return {boolean} Whether this box is empty or not.\n\t */\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t}\n\n\t/**\n\t * Returns the center point of this box.\n\t *\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The center point.\n\t */\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\t/**\n\t * Returns the dimensions of this box.\n\t *\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The size.\n\t */\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\t/**\n\t * Expands the boundaries of this box to include the given point.\n\t *\n\t * @param {Vector3} point - The point that should be included by the bounding box.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Expands this box equilaterally by the given vector. The width of this\n\t * box will be expanded by the x component of the vector in both\n\t * directions. The height of this box will be expanded by the y component of\n\t * the vector in both directions. The depth of this box will be\n\t * expanded by the z component of the vector in both directions.\n\t *\n\t * @param {Vector3} vector - The vector that should expand the bounding box.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Expands each dimension of the box by the given scalar. If negative, the\n\t * dimensions of the box will be contracted.\n\t *\n\t * @param {number} scalar - The scalar value that should expand the bounding box.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Expands the boundaries of this box to include the given 3D object and\n\t * its children, accounting for the object's, and children's, world\n\t * transforms. The function may result in a larger box than strictly\n\t * necessary (unless the precise parameter is set to true).\n\t *\n\t * @param {Object3D} object - The 3D object that should expand the bounding box.\n\t * @param {boolean} precise - If set to `true`, the method expands the bounding box\n\t * as little as necessary at the expense of more computation.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\texpandByObject( object, precise = false ) {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tobject.updateWorldMatrix( false, false );\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t// precise AABB computation based on vertex data requires at least a position attribute.\n\t\t\t// instancing isn't supported so far and uses the normal (conservative) code path.\n\n\t\t\tif ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\tif ( object.isMesh === true ) {\n\n\t\t\t\t\t\tobject.getVertexPosition( i, _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_vector.applyMatrix4( object.matrixWorld );\n\t\t\t\t\tthis.expandByPoint( _vector );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( object.boundingBox !== undefined ) {\n\n\t\t\t\t\t// object-level bounding box\n\n\t\t\t\t\tif ( object.boundingBox === null ) {\n\n\t\t\t\t\t\tobject.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box.copy( object.boundingBox );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// geometry-level bounding box\n\n\t\t\t\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box.copy( geometry.boundingBox );\n\n\t\t\t\t}\n\n\t\t\t\t_box.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tthis.union( _box );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis.expandByObject( children[ i ], precise );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given point lies within or on the boundaries of this box.\n\t *\n\t * @param {Vector3} point - The point to test.\n\t * @return {boolean} Whether the bounding box contains the given point or not.\n\t */\n\tcontainsPoint( point ) {\n\n\t\treturn point.x >= this.min.x && point.x <= this.max.x &&\n\t\t\tpoint.y >= this.min.y && point.y <= this.max.y &&\n\t\t\tpoint.z >= this.min.z && point.z <= this.max.z;\n\n\t}\n\n\t/**\n\t * Returns `true` if this bounding box includes the entirety of the given bounding box.\n\t * If this box and the given one are identical, this function also returns `true`.\n\t *\n\t * @param {Box3} box - The bounding box to test.\n\t * @return {boolean} Whether the bounding box contains the given bounding box or not.\n\t */\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t}\n\n\t/**\n\t * Returns a point as a proportion of this box's width, height and depth.\n\t *\n\t * @param {Vector3} point - A point in 3D space.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} A point as a proportion of this box's width, height and depth.\n\t */\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t}\n\n\t/**\n\t * Returns `true` if the given bounding box intersects with this bounding box.\n\t *\n\t * @param {Box3} box - The bounding box to test.\n\t * @return {boolean} Whether the given bounding box intersects with this bounding box.\n\t */\n\tintersectsBox( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x >= this.min.x && box.min.x <= this.max.x &&\n\t\t\tbox.max.y >= this.min.y && box.min.y <= this.max.y &&\n\t\t\tbox.max.z >= this.min.z && box.min.z <= this.max.z;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given bounding sphere intersects with this bounding box.\n\t *\n\t * @param {Sphere} sphere - The bounding sphere to test.\n\t * @return {boolean} Whether the given bounding sphere intersects with this bounding box.\n\t */\n\tintersectsSphere( sphere ) {\n\n\t\t// Find the point on the AABB closest to the sphere center.\n\t\tthis.clampPoint( sphere.center, _vector );\n\n\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\treturn _vector.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given plane intersects with this bounding box.\n\t *\n\t * @param {Plane} plane - The plane to test.\n\t * @return {boolean} Whether the given plane intersects with this bounding box.\n\t */\n\tintersectsPlane( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tlet min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given triangle intersects with this bounding box.\n\t *\n\t * @param {Triangle} triangle - The triangle to test.\n\t * @return {boolean} Whether the given triangle intersects with this bounding box.\n\t */\n\tintersectsTriangle( triangle ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compute box center and extents\n\t\tthis.getCenter( _center );\n\t\t_extents.subVectors( this.max, _center );\n\n\t\t// translate triangle to aabb origin\n\t\t_v0.subVectors( triangle.a, _center );\n\t\t_v1.subVectors( triangle.b, _center );\n\t\t_v2.subVectors( triangle.c, _center );\n\n\t\t// compute edge vectors for triangle\n\t\t_f0.subVectors( _v1, _v0 );\n\t\t_f1.subVectors( _v2, _v1 );\n\t\t_f2.subVectors( _v0, _v2 );\n\n\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\tlet axes = [\n\t\t\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\n\t\t\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\n\t\t\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\n\t\t];\n\t\tif ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// test 3 face normals from the aabb\n\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\tif ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// finally testing the face normal of the triangle\n\t\t// use already existing triangle edge vectors here\n\t\t_triangleNormal.crossVectors( _f0, _f1 );\n\t\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\n\n\t\treturn satForAxes( axes, _v0, _v1, _v2, _extents );\n\n\t}\n\n\t/**\n\t * Clamps the given point within the bounds of this box.\n\t *\n\t * @param {Vector3} point - The point to clamp.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The clamped point.\n\t */\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\t/**\n\t * Returns the euclidean distance from any edge of this box to the specified point. If\n\t * the given point lies inside of this box, the distance will be `0`.\n\t *\n\t * @param {Vector3} point - The point to compute the distance to.\n\t * @return {number} The euclidean distance.\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector ).distanceTo( point );\n\n\t}\n\n\t/**\n\t * Returns a bounding sphere that encloses this bounding box.\n\t *\n\t * @param {Sphere} target - The target sphere that is used to store the method's result.\n\t * @return {Sphere} The bounding sphere that encloses this bounding box.\n\t */\n\tgetBoundingSphere( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\ttarget.makeEmpty();\n\n\t\t} else {\n\n\t\t\tthis.getCenter( target.center );\n\n\t\t\ttarget.radius = this.getSize( _vector ).length() * 0.5;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Computes the intersection of this bounding box and the given one, setting the upper\n\t * bound of this box to the lesser of the two boxes' upper bounds and the\n\t * lower bound of this box to the greater of the two boxes' lower bounds. If\n\t * there's no overlap, makes this box empty.\n\t *\n\t * @param {Box3} box - The bounding box to intersect with.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the union of this box and another and the given one, setting the upper\n\t * bound of this box to the greater of the two boxes' upper bounds and the\n\t * lower bound of this box to the lesser of the two boxes' lower bounds.\n\t *\n\t * @param {Box3} box - The bounding box that will be unioned with this instance.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Transforms this bounding box by the given 4x4 transformation matrix.\n\t *\n\t * @param {Matrix4} matrix - The transformation matrix.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tapplyMatrix4( matrix ) {\n\n\t\t// transform of empty box is an empty box.\n\t\tif ( this.isEmpty() ) return this;\n\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\tthis.setFromPoints( _points );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds the given offset to both the upper and lower bounds of this bounding box,\n\t * effectively moving it in 3D space.\n\t *\n\t * @param {Vector3} offset - The offset that should be used to translate the bounding box.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this bounding box is equal with the given one.\n\t *\n\t * @param {Box3} box - The box to test for equality.\n\t * @return {boolean} Whether this bounding box is equal with the given one.\n\t */\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n\t/**\n\t * Returns a serialized structure of the bounding box.\n\t *\n\t * @return {Object} Serialized structure with fields representing the object state.\n\t */\n\ttoJSON() {\n\n\t\treturn {\n\t\t\tmin: this.min.toArray(),\n\t\t\tmax: this.max.toArray()\n\t\t};\n\n\t}\n\n\t/**\n\t * Returns a serialized structure of the bounding box.\n\t *\n\t * @param {Object} json - The serialized json to set the box from.\n\t * @return {Box3} A reference to this bounding box.\n\t */\n\tfromJSON( json ) {\n\n\t\tthis.min.fromArray( json.min );\n\t\tthis.max.fromArray( json.max );\n\t\treturn this;\n\n\t}\n\n}\n\nconst _points = [\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3()\n];\n\nconst _vector = /*@__PURE__*/ new Vector3();\n\nconst _box = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes( axes, v0, v1, v2, extents ) {\n\n\tfor ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t_testAxis.fromArray( axes, i );\n\t\t// project the aabb onto the separating axis\n\t\tconst r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\n\t\t// project all 3 vertices of the triangle onto the separating axis\n\t\tconst p0 = v0.dot( _testAxis );\n\t\tconst p1 = v1.dot( _testAxis );\n\t\tconst p2 = v2.dot( _testAxis );\n\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t// the axis is separating and we can exit\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nexport { Box3 };\n", "import { Box3 } from './Box3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _box = /*@__PURE__*/ new Box3();\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\n\n/**\n * An analytical 3D sphere defined by a center and radius. This class is mainly\n * used as a Bounding Sphere for 3D objects.\n */\nclass Sphere {\n\n\t/**\n\t * Constructs a new sphere.\n\t *\n\t * @param {Vector3} [center=(0,0,0)] - The center of the sphere\n\t * @param {number} [radius=-1] - The radius of the sphere.\n\t */\n\tconstructor( center = new Vector3(), radius = - 1 ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSphere = true;\n\n\t\t/**\n\t\t * The center of the sphere\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.center = center;\n\n\t\t/**\n\t\t * The radius of the sphere.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.radius = radius;\n\n\t}\n\n\t/**\n\t * Sets the sphere's components by copying the given values.\n\t *\n\t * @param {Vector3} center - The center.\n\t * @param {number} radius - The radius.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\tset( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the minimum bounding sphere for list of points.\n\t * If the optional center point is given, it is used as the sphere's\n\t * center. Otherwise, the center of the axis-aligned bounding box\n\t * encompassing the points is calculated.\n\t *\n\t * @param {Array<Vector3>} points - A list of points in 3D space.\n\t * @param {Vector3} [optionalCenter] - The center of the sphere.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\tsetFromPoints( points, optionalCenter ) {\n\n\t\tconst center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tlet maxRadiusSq = 0;\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the values of the given sphere to this instance.\n\t *\n\t * @param {Sphere} sphere - The sphere to copy.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\tcopy( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if the sphere is empty (the radius set to a negative number).\n\t *\n\t * Spheres with a radius of `0` contain only their center point and are not\n\t * considered to be empty.\n\t *\n\t * @return {boolean} Whether this sphere is empty or not.\n\t */\n\tisEmpty() {\n\n\t\treturn ( this.radius < 0 );\n\n\t}\n\n\t/**\n\t * Makes this sphere empty which means in encloses a zero space in 3D.\n\t *\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\tmakeEmpty() {\n\n\t\tthis.center.set( 0, 0, 0 );\n\t\tthis.radius = - 1;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this sphere contains the given point inclusive of\n\t * the surface of the sphere.\n\t *\n\t * @param {Vector3} point - The point to check.\n\t * @return {boolean} Whether this sphere contains the given point or not.\n\t */\n\tcontainsPoint( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t}\n\n\t/**\n\t * Returns the closest distance from the boundary of the sphere to the\n\t * given point. If the sphere contains the point, the distance will\n\t * be negative.\n\t *\n\t * @param {Vector3} point - The point to compute the distance to.\n\t * @return {number} The distance to the point.\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t}\n\n\t/**\n\t * Returns `true` if this sphere intersects with the given one.\n\t *\n\t * @param {Sphere} sphere - The sphere to test.\n\t * @return {boolean} Whether this sphere intersects with the given one or not.\n\t */\n\tintersectsSphere( sphere ) {\n\n\t\tconst radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t}\n\n\t/**\n\t * Returns `true` if this sphere intersects with the given box.\n\t *\n\t * @param {Box3} box - The box to test.\n\t * @return {boolean} Whether this sphere intersects with the given box or not.\n\t */\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t}\n\n\t/**\n\t * Returns `true` if this sphere intersects with the given plane.\n\t *\n\t * @param {Plane} plane - The plane to test.\n\t * @return {boolean} Whether this sphere intersects with the given plane or not.\n\t */\n\tintersectsPlane( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t}\n\n\t/**\n\t * Clamps a point within the sphere. If the point is outside the sphere, it\n\t * will clamp it to the closest point on the edge of the sphere. Points\n\t * already inside the sphere will not be affected.\n\t *\n\t * @param {Vector3} point - The plane to clamp.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The clamped point.\n\t */\n\tclampPoint( point, target ) {\n\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Returns a bounding box that encloses this sphere.\n\t *\n\t * @param {Box3} target - The target box that is used to store the method's result.\n\t * @return {Box3} The bounding box that encloses this sphere.\n\t */\n\tgetBoundingBox( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\t// Empty sphere produces empty bounding box\n\t\t\ttarget.makeEmpty();\n\t\t\treturn target;\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Transforms this sphere with the given 4x4 transformation matrix.\n\t *\n\t * @param {Matrix4} matrix - The transformation matrix.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Translates the sphere's center by the given offset.\n\t *\n\t * @param {Vector3} offset - The offset.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\ttranslate( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Expands the boundaries of this sphere to include the given point.\n\t *\n\t * @param {Vector3} point - The point to include.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\texpandByPoint( point ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.center.copy( point );\n\n\t\t\tthis.radius = 0;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t_v1.subVectors( point, this.center );\n\n\t\tconst lengthSq = _v1.lengthSq();\n\n\t\tif ( lengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t// calculate the minimal sphere\n\n\t\t\tconst length = Math.sqrt( lengthSq );\n\n\t\t\tconst delta = ( length - this.radius ) * 0.5;\n\n\t\t\tthis.center.addScaledVector( _v1, delta / length );\n\n\t\t\tthis.radius += delta;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Expands this sphere to enclose both the original sphere and the given sphere.\n\t *\n\t * @param {Sphere} sphere - The sphere to include.\n\t * @return {Sphere} A reference to this sphere.\n\t */\n\tunion( sphere ) {\n\n\t\tif ( sphere.isEmpty() ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.copy( sphere );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.center.equals( sphere.center ) === true ) {\n\n\t\t\t this.radius = Math.max( this.radius, sphere.radius );\n\n\t\t} else {\n\n\t\t\t_v2.subVectors( sphere.center, this.center ).setLength( sphere.radius );\n\n\t\t\tthis.expandByPoint( _v1.copy( sphere.center ).add( _v2 ) );\n\n\t\t\tthis.expandByPoint( _v1.copy( sphere.center ).sub( _v2 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this sphere is equal with the given one.\n\t *\n\t * @param {Sphere} sphere - The sphere to test for equality.\n\t * @return {boolean} Whether this bounding sphere is equal with the given one.\n\t */\n\tequals( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n\t/**\n\t * Returns a new sphere with copied values from this instance.\n\t *\n\t * @return {Sphere} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Returns a serialized structure of the bounding sphere.\n\t *\n\t * @return {Object} Serialized structure with fields representing the object state.\n\t */\n\ttoJSON() {\n\n\t\treturn {\n\t\t\tradius: this.radius,\n\t\t\tcenter: this.center.toArray()\n\t\t};\n\n\t}\n\n\t/**\n\t * Returns a serialized structure of the bounding sphere.\n\t *\n\t * @param {Object} json - The serialized json to set the sphere from.\n\t * @return {Box3} A reference to this bounding sphere.\n\t */\n\tfromJSON( json ) {\n\n\t\tthis.radius = json.radius;\n\t\tthis.center.fromArray( json.center );\n\t\treturn this;\n\n\t}\n\n}\n\nexport { Sphere };\n", "import Node from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport UniformNode from '../core/UniformNode.js';\nimport { nodeProxy } from '../tsl/TSLBase.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Sphere } from '../../math/Sphere.js';\n\nconst _sphere = /*@__PURE__*/ new Sphere();\n\n/**\n * This node can be used to access transformation related metrics of 3D objects.\n * Depending on the selected scope, a different metric is represented as a uniform\n * in the shader. The following scopes are supported:\n *\n * - `POSITION`: The object's position in world space.\n * - `VIEW_POSITION`: The object's position in view/camera space.\n * - `DIRECTION`: The object's direction in world space.\n * - `SCALE`: The object's scale in world space.\n * - `WORLD_MATRIX`: The object's matrix in world space.\n *\n * @augments Node\n */\nclass Object3DNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'Object3DNode';\n\n\t}\n\n\t/**\n\t * Constructs a new object 3D node.\n\t *\n\t * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.\n\t * @param {?Object3D} [object3d=null] - The 3D object.\n\t */\n\tconstructor( scope, object3d = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node reports a different type of transformation depending on the scope.\n\t\t *\n\t\t * @type {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * The 3D object.\n\t\t *\n\t\t * @type {?Object3D}\n\t\t * @default null\n\t\t */\n\t\tthis.object3d = object3d;\n\n\t\t/**\n\t\t * Overwritten since this type of node is updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Holds the value of the node as a uniform.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis.uniformNode = new UniformNode( null );\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the scope.\n\t *\n\t * @return {('mat4'|'vec3'|'float')} The node type.\n\t */\n\tgetNodeType() {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\treturn 'mat4';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else if ( scope === Object3DNode.RADIUS ) {\n\n\t\t\treturn 'float';\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the uniform value depending on the scope.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst object = this.object3d;\n\t\tconst uniformNode = this.uniformNode;\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tuniformNode.value = object.matrixWorld;\n\n\t\t} else if ( scope === Object3DNode.POSITION ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.SCALE ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tuniformNode.value.setFromMatrixScale( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.DIRECTION ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tobject.getWorldDirection( uniformNode.value );\n\n\t\t} else if ( scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\tconst camera = frame.camera;\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t\tuniformNode.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t} else if ( scope === Object3DNode.RADIUS ) {\n\n\t\t\tconst geometry = frame.object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t\tuniformNode.value = _sphere.radius;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the uniform node. The node type of the uniform\n\t * node also depends on the selected scope.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tthis.uniformNode.nodeType = 'mat4';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {\n\n\t\t\tthis.uniformNode.nodeType = 'vec3';\n\n\t\t} else if ( scope === Object3DNode.RADIUS ) {\n\n\t\t\tthis.uniformNode.nodeType = 'float';\n\n\t\t}\n\n\t\treturn this.uniformNode.build( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nObject3DNode.WORLD_MATRIX = 'worldMatrix';\nObject3DNode.POSITION = 'position';\nObject3DNode.SCALE = 'scale';\nObject3DNode.VIEW_POSITION = 'viewPosition';\nObject3DNode.DIRECTION = 'direction';\nObject3DNode.RADIUS = 'radius';\n\nexport default Object3DNode;\n\n/**\n * TSL function for creating an object 3D node that represents the object's direction in world space.\n *\n * @tsl\n * @function\n * @param {?Object3D} [object3d] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nexport const objectDirection = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.DIRECTION ).setParameterLength( 1 );\n\n/**\n * TSL function for creating an object 3D node that represents the object's world matrix.\n *\n * @tsl\n * @function\n * @param {?Object3D} [object3d] - The 3D object.\n * @returns {Object3DNode<mat4>}\n */\nexport const objectWorldMatrix = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.WORLD_MATRIX ).setParameterLength( 1 );\n\n/**\n * TSL function for creating an object 3D node that represents the object's position in world space.\n *\n * @tsl\n * @function\n * @param {?Object3D} [object3d] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nexport const objectPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.POSITION ).setParameterLength( 1 );\n\n/**\n * TSL function for creating an object 3D node that represents the object's scale in world space.\n *\n * @tsl\n * @function\n * @param {?Object3D} [object3d] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nexport const objectScale = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.SCALE ).setParameterLength( 1 );\n\n/**\n * TSL function for creating an object 3D node that represents the object's position in view/camera space.\n *\n * @tsl\n * @function\n * @param {?Object3D} [object3d] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nexport const objectViewPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.VIEW_POSITION ).setParameterLength( 1 );\n\n/**\n * TSL function for creating an object 3D node that represents the object's radius.\n *\n * @tsl\n * @function\n * @param {?Object3D} [object3d] - The 3D object.\n * @returns {Object3DNode<float>}\n */\nexport const objectRadius = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.RADIUS ).setParameterLength( 1 );\n", "import UniformNode from '../core/UniformNode.js';\nimport { nodeObject } from '../tsl/TSLBase.js';\n\n/**\n * A special type of uniform node which represents array-like data\n * as uniform buffers. The access usually happens via `element()`\n * which returns an instance of {@link ArrayElementNode}. For example:\n *\n * ```js\n * const bufferNode = buffer( array, 'mat4', count );\n * const matrixNode = bufferNode.element( index ); // access a matrix from the buffer\n * ```\n * In general, it is recommended to use the more managed {@link UniformArrayNode}\n * since it handles more input types and automatically cares about buffer paddings.\n *\n * @augments UniformNode\n */\nclass BufferNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'BufferNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer node.\n\t *\n\t * @param {Array<number>} value - Array-like buffer data.\n\t * @param {string} bufferType - The data type of the buffer.\n\t * @param {number} [bufferCount=0] - The count of buffer elements.\n\t */\n\tconstructor( value, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferNode = true;\n\n\t\t/**\n\t\t * The data type of the buffer.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.bufferType = bufferType;\n\n\t\t/**\n\t\t * The uniform node that holds the value of the reference node.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferCount = bufferCount;\n\n\t}\n\n\t/**\n\t * The data type of the buffer elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The element type.\n\t */\n\tgetElementType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'buffer'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'buffer';\n\n\t}\n\n}\n\nexport default BufferNode;\n\n/**\n * TSL function for creating a buffer node.\n *\n * @tsl\n * @function\n * @param {Array<number>} value - Array-like buffer data.\n * @param {string} type - The data type of a buffer element.\n * @param {number} count - The count of buffer elements.\n * @returns {BufferNode}\n */\nexport const buffer = ( value, type, count ) => nodeObject( new BufferNode( value, type, count ) );\n", "import { nodeObject } from '../tsl/TSLBase.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { getValueType } from '../core/NodeUtils.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport BufferNode from './BufferNode.js';\n\n/**\n * Represents the element access on uniform array nodes.\n *\n * @augments ArrayElementNode\n */\nclass UniformArrayElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer node.\n\t *\n\t * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.\n\t * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.\n\t */\n\tconstructor( uniformArrayNode, indexNode ) {\n\n\t\tsuper( uniformArrayNode, indexNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayBufferElementNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst type = this.getNodeType();\n\t\tconst paddedType = this.node.getPaddedType();\n\n\t\treturn builder.format( snippet, paddedType, type );\n\n\t}\n\n}\n\n/**\n * Similar to {@link BufferNode} this module represents array-like data as\n * uniform buffers. Unlike {@link BufferNode}, it can handle more common\n * data types in the array (e.g `three.js` primitives) and automatically\n * manage buffer padding. It should be the first choice when working with\n * uniforms buffers.\n * ```js\n * const tintColors = uniformArray( [\n * \tnew Color( 1, 0, 0 ),\n * \tnew Color( 0, 1, 0 ),\n * \tnew Color( 0, 0, 1 )\n * ], 'color' );\n *\n * const redColor = tintColors.element( 0 );\n *\n * @augments BufferNode\n */\nclass UniformArrayNode extends BufferNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform array node.\n\t *\n\t * @param {Array<any>} value - Array holding the buffer data.\n\t * @param {?string} [elementType=null] - The data type of a buffer element.\n\t */\n\tconstructor( value, elementType = null ) {\n\n\t\tsuper( null );\n\n\t\t/**\n\t\t * Array holding the buffer data. Unlike {@link BufferNode}, the array can\n\t\t * hold number primitives as well as three.js objects like vectors, matrices\n\t\t * or colors.\n\t\t *\n\t\t * @type {Array<any>}\n\t\t */\n\t\tthis.array = value;\n\n\t\t/**\n\t\t * The data type of an array element.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.elementType = elementType === null ? getValueType( value[ 0 ] ) : elementType;\n\n\t\t/**\n\t\t * The padded type. Uniform buffers must conform to a certain buffer layout\n\t\t * so a separate type is computed to ensure correct buffer size.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.paddedType = this.getPaddedType();\n\n\t\t/**\n\t\t * Overwritten since uniform array nodes are updated per render.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.RENDER;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayBufferNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the\n\t * {@link UniformArrayNode#paddedType}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.paddedType;\n\n\t}\n\n\t/**\n\t * The data type of the array elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The element type.\n\t */\n\tgetElementType() {\n\n\t\treturn this.elementType;\n\n\t}\n\n\t/**\n\t * Returns the padded type based on the element type.\n\t *\n\t * @return {string} The padded type.\n\t */\n\tgetPaddedType() {\n\n\t\tconst elementType = this.elementType;\n\n\t\tlet paddedType = 'vec4';\n\n\t\tif ( elementType === 'mat2' ) {\n\n\t\t\tpaddedType = 'mat2';\n\n\t\t} else if ( /mat/.test( elementType ) === true ) {\n\n\t\t\tpaddedType = 'mat4';\n\n\t\t} else if ( elementType.charAt( 0 ) === 'i' ) {\n\n\t\t\tpaddedType = 'ivec4';\n\n\t\t} else if ( elementType.charAt( 0 ) === 'u' ) {\n\n\t\t\tpaddedType = 'uvec4';\n\n\t\t}\n\n\t\treturn paddedType;\n\n\t}\n\n\t/**\n\t * The update makes sure to correctly transfer the data from the (complex) objects\n\t * in the array to the internal, correctly padded value buffer.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconst { array, value } = this;\n\n\t\tconst elementType = this.elementType;\n\n\t\tif ( elementType === 'float' || elementType === 'int' || elementType === 'uint' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\n\t\t\t\tvalue[ index ] = array[ i ];\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'color' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.r;\n\t\t\t\tvalue[ index + 1 ] = vector.g;\n\t\t\t\tvalue[ index + 2 ] = vector.b || 0;\n\t\t\t\t//value[ index + 3 ] = vector.a || 0;\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat2' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tvalue[ index ] = matrix.elements[ 0 ];\n\t\t\t\tvalue[ index + 1 ] = matrix.elements[ 1 ];\n\t\t\t\tvalue[ index + 2 ] = matrix.elements[ 2 ];\n\t\t\t\tvalue[ index + 3 ] = matrix.elements[ 3 ];\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat3' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 16;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tvalue[ index ] = matrix.elements[ 0 ];\n\t\t\t\tvalue[ index + 1 ] = matrix.elements[ 1 ];\n\t\t\t\tvalue[ index + 2 ] = matrix.elements[ 2 ];\n\n\t\t\t\tvalue[ index + 4 ] = matrix.elements[ 3 ];\n\t\t\t\tvalue[ index + 5 ] = matrix.elements[ 4 ];\n\t\t\t\tvalue[ index + 6 ] = matrix.elements[ 5 ];\n\n\t\t\t\tvalue[ index + 8 ] = matrix.elements[ 6 ];\n\t\t\t\tvalue[ index + 9 ] = matrix.elements[ 7 ];\n\t\t\t\tvalue[ index + 10 ] = matrix.elements[ 8 ];\n\n\t\t\t\tvalue[ index + 15 ] = 1;\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat4' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 16;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tfor ( let i = 0; i < matrix.elements.length; i ++ ) {\n\n\t\t\t\t\tvalue[ index + i ] = matrix.elements[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.x;\n\t\t\t\tvalue[ index + 1 ] = vector.y;\n\t\t\t\tvalue[ index + 2 ] = vector.z || 0;\n\t\t\t\tvalue[ index + 3 ] = vector.w || 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Implement the value buffer creation based on the array data.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {null}\n\t */\n\tsetup( builder ) {\n\n\t\tconst length = this.array.length;\n\t\tconst elementType = this.elementType;\n\n\t\tlet arrayType = Float32Array;\n\n\t\tconst paddedType = this.paddedType;\n\t\tconst paddedElementLength = builder.getTypeLength( paddedType );\n\n\t\tif ( elementType.charAt( 0 ) === 'i' ) arrayType = Int32Array;\n\t\tif ( elementType.charAt( 0 ) === 'u' ) arrayType = Uint32Array;\n\n\t\tthis.value = new arrayType( length * paddedElementLength );\n\t\tthis.bufferCount = length;\n\t\tthis.bufferType = paddedType;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Overwrites the default `element()` method to provide element access\n\t * based on {@link UniformArrayNode}.\n\t *\n\t * @param {IndexNode} indexNode - The index node.\n\t * @return {UniformArrayElementNode}\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new UniformArrayElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n}\n\nexport default UniformArrayNode;\n\n/**\n * TSL function for creating an uniform array node.\n *\n * @tsl\n * @function\n * @param {Array<any>} values - Array-like data.\n * @param {?string} [nodeType] - The data type of the array elements.\n * @returns {UniformArrayNode}\n */\nexport const uniformArray = ( values, nodeType ) => nodeObject( new UniformArrayNode( values, nodeType ) );\n", "import Node from '../core/Node.js';\nimport { nodeProxy } from '../tsl/TSLBase.js';\n\n/**\n * The node allows to set values for built-in shader variables. That is\n * required for features like hardware-accelerated vertex clipping.\n *\n * @augments Node\n */\nclass BuiltinNode extends Node {\n\n\t/**\n\t * Constructs a new builtin node.\n\t *\n\t * @param {string} name - The name of the built-in shader variable.\n\t */\n\tconstructor( name ) {\n\n\t\tsuper( 'float' );\n\n\t\t/**\n\t\t * The name of the built-in shader variable.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBuiltinNode = true;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the builtin node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( /* builder */ ) {\n\n\t\treturn this.name;\n\n\t}\n\n}\n\nexport default BuiltinNode;\n\n/**\n * TSL function for creating a builtin node.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the built-in shader variable.\n * @returns {BuiltinNode}\n */\nexport const builtin = nodeProxy( BuiltinNode ).setParameterLength( 1 );\n", "import Node from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { Fn, nodeImmutable, vec2 } from '../tsl/TSLBase.js';\n\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector4 } from '../../math/Vector4.js';\n\nlet _screenSizeVec, _viewportVec;\n\n/**\n * This node provides a collection of screen related metrics.\n * Depending on {@link ScreenNode#scope}, the nodes can represent\n * resolution or viewport data as well as fragment or uv coordinates.\n *\n * @augments Node\n */\nclass ScreenNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScreenNode';\n\n\t}\n\n\t/**\n\t * Constructs a new screen node.\n\t *\n\t * @param {('coordinate'|'viewport'|'size'|'uv'|'dpr')} scope - The node's scope.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node represents different metric depending on which scope is selected.\n\t\t *\n\t\t * - `ScreenNode.COORDINATE`: Window-relative coordinates of the current fragment according to WebGPU standards.\n\t\t * - `ScreenNode.VIEWPORT`: The current viewport defined as a four-dimensional vector.\n\t\t * - `ScreenNode.SIZE`: The dimensions of the current bound framebuffer.\n\t\t * - `ScreenNode.UV`: Normalized coordinates.\n\t\t * - `ScreenNode.DPR`: Device pixel ratio.\n\t\t *\n\t\t * @type {('coordinate'|'viewport'|'size'|'uv'|'dpr')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * This output node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis._output = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isViewportNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type depends on the selected scope.\n\t *\n\t * @return {('float'|'vec2'|'vec4')} The node type.\n\t */\n\tgetNodeType() {\n\n\t\tif ( this.scope === ScreenNode.DPR ) return 'float';\n\t\tif ( this.scope === ScreenNode.VIEWPORT ) return 'vec4';\n\t\telse return 'vec2';\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node's update type depends on the selected scope.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateType() {\n\n\t\tlet updateType = NodeUpdateType.NONE;\n\n\t\tif ( this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT || this.scope === ScreenNode.DPR ) {\n\n\t\t\tupdateType = NodeUpdateType.RENDER;\n\n\t\t}\n\n\t\tthis.updateType = updateType;\n\n\t\treturn updateType;\n\n\t}\n\n\t/**\n\t * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information\n\t * from the current renderer.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( { renderer } ) {\n\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\tif ( this.scope === ScreenNode.VIEWPORT ) {\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\t_viewportVec.copy( renderTarget.viewport );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.getViewport( _viewportVec );\n\n\t\t\t\t_viewportVec.multiplyScalar( renderer.getPixelRatio() );\n\n\t\t\t}\n\n\t\t} else if ( this.scope === ScreenNode.DPR ) {\n\n\t\t\tthis._output.value = renderer.getPixelRatio();\n\n\t\t} else {\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\t_screenSizeVec.width = renderTarget.width;\n\t\t\t\t_screenSizeVec.height = renderTarget.height;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.getDrawingBufferSize( _screenSizeVec );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( /*builder*/ ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet output = null;\n\n\t\tif ( scope === ScreenNode.SIZE ) {\n\n\t\t\toutput = uniform( _screenSizeVec || ( _screenSizeVec = new Vector2() ) );\n\n\t\t} else if ( scope === ScreenNode.VIEWPORT ) {\n\n\t\t\toutput = uniform( _viewportVec || ( _viewportVec = new Vector4() ) );\n\n\t\t} else if ( scope === ScreenNode.DPR ) {\n\n\t\t\toutput = uniform( 1 );\n\n\t\t} else {\n\n\t\t\toutput = vec2( screenCoordinate.div( screenSize ) );\n\n\t\t}\n\n\t\tthis._output = output;\n\n\t\treturn output;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tif ( this.scope === ScreenNode.COORDINATE ) {\n\n\t\t\tlet coord = builder.getFragCoord();\n\n\t\t\tif ( builder.isFlipY() ) {\n\n\t\t\t\t// follow webgpu standards\n\n\t\t\t\tconst size = builder.getNodeProperties( screenSize ).outputNode.build( builder );\n\n\t\t\t\tcoord = `${ builder.getType( 'vec2' ) }( ${ coord }.x, ${ size }.y - ${ coord }.y )`;\n\n\t\t\t}\n\n\t\t\treturn coord;\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n}\n\nScreenNode.COORDINATE = 'coordinate';\nScreenNode.VIEWPORT = 'viewport';\nScreenNode.SIZE = 'size';\nScreenNode.UV = 'uv';\nScreenNode.DPR = 'dpr';\n\nexport default ScreenNode;\n\n// Screen\n\n/**\n * TSL object that represents the current DPR.\n *\n * @tsl\n * @type {ScreenNode<float>}\n */\nexport const screenDPR = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.DPR );\n\n/**\n * TSL object that represents normalized screen coordinates, unitless in `[0, 1]`.\n *\n * @tsl\n * @type {ScreenNode<vec2>}\n */\nexport const screenUV = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.UV );\n\n/**\n * TSL object that represents the screen resolution in physical pixel units.\n *\n * @tsl\n * @type {ScreenNode<vec2>}\n */\nexport const screenSize = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.SIZE );\n\n/**\n * TSL object that represents the current `x`/`y` pixel position on the screen in physical pixel units.\n *\n * @tsl\n * @type {ScreenNode<vec2>}\n */\nexport const screenCoordinate = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.COORDINATE );\n\n// Viewport\n\n/**\n * TSL object that represents the viewport rectangle as `x`, `y`, `width` and `height` in physical pixel units.\n *\n * @tsl\n * @type {ScreenNode<vec4>}\n */\nexport const viewport = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.VIEWPORT );\n\n/**\n * TSL object that represents the viewport resolution in physical pixel units.\n *\n * @tsl\n * @type {ScreenNode<vec2>}\n */\nexport const viewportSize = viewport.zw;\n\n/**\n * TSL object that represents the current `x`/`y` pixel position on the viewport in physical pixel units.\n *\n * @tsl\n * @type {ScreenNode<vec2>}\n */\nexport const viewportCoordinate = /*@__PURE__*/ screenCoordinate.sub( viewport.xy );\n\n/**\n * TSL object that represents normalized viewport coordinates, unitless in `[0, 1]`.\n *\n * @tsl\n * @type {ScreenNode<vec2>}\n */\nexport const viewportUV = /*@__PURE__*/ viewportCoordinate.div( viewportSize );\n\n// Deprecated\n\n/**\n * @deprecated since r169. Use {@link screenSize} instead.\n */\nexport const viewportResolution = /*@__PURE__*/ ( Fn( () => { // @deprecated, r169\n\n\tconsole.warn( 'THREE.TSL: \"viewportResolution\" is deprecated. Use \"screenSize\" instead.' );\n\n\treturn screenSize;\n\n}, 'vec2' ).once() )();\n", "import { uniform } from '../core/UniformNode.js';\nimport { renderGroup, sharedUniformGroup } from '../core/UniformGroupNode.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Fn, vec4 } from '../tsl/TSLBase.js';\nimport { uniformArray } from './UniformArrayNode.js';\nimport { builtin } from './BuiltinNode.js';\nimport { screenSize } from '../display/ScreenNode.js';\n\n/**\n * TSL object that represents the current `index` value of the camera if used ArrayCamera.\n *\n * @tsl\n * @type {UniformNode<uint>}\n */\nexport const cameraIndex = /*@__PURE__*/ uniform( 0, 'uint' ).setName( 'u_cameraIndex' ).setGroup( sharedUniformGroup( 'cameraIndex' ) ).toVarying( 'v_cameraIndex' );\n\n/**\n * TSL object that represents the `near` value of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<float>}\n */\nexport const cameraNear = /*@__PURE__*/ uniform( 'float' ).setName( 'cameraNear' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.near );\n\n/**\n * TSL object that represents the `far` value of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<float>}\n */\nexport const cameraFar = /*@__PURE__*/ uniform( 'float' ).setName( 'cameraFar' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.far );\n\n/**\n * TSL object that represents the projection matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nexport const cameraProjectionMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraProjectionMatrix;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.projectionMatrix );\n\n\t\t}\n\n\t\tconst cameraProjectionMatrices = uniformArray( matrices ).setGroup( renderGroup ).setName( 'cameraProjectionMatrices' );\n\n\t\tcameraProjectionMatrix = cameraProjectionMatrices.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toConst( 'cameraProjectionMatrix' );\n\n\t} else {\n\n\t\tcameraProjectionMatrix = uniform( 'mat4' ).setName( 'cameraProjectionMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrix );\n\n\t}\n\n\treturn cameraProjectionMatrix;\n\n} ).once() )();\n\n/**\n * TSL object that represents the inverse projection matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nexport const cameraProjectionMatrixInverse = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraProjectionMatrixInverse;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.projectionMatrixInverse );\n\n\t\t}\n\n\t\tconst cameraProjectionMatricesInverse = uniformArray( matrices ).setGroup( renderGroup ).setName( 'cameraProjectionMatricesInverse' );\n\n\t\tcameraProjectionMatrixInverse = cameraProjectionMatricesInverse.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toConst( 'cameraProjectionMatrixInverse' );\n\n\t} else {\n\n\t\tcameraProjectionMatrixInverse = uniform( 'mat4' ).setName( 'cameraProjectionMatrixInverse' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrixInverse );\n\n\t}\n\n\treturn cameraProjectionMatrixInverse;\n\n} ).once() )();\n\n/**\n * TSL object that represents the view matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nexport const cameraViewMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraViewMatrix;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.matrixWorldInverse );\n\n\t\t}\n\n\t\tconst cameraViewMatrices = uniformArray( matrices ).setGroup( renderGroup ).setName( 'cameraViewMatrices' );\n\n\t\tcameraViewMatrix = cameraViewMatrices.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toConst( 'cameraViewMatrix' );\n\n\t} else {\n\n\t\tcameraViewMatrix = uniform( 'mat4' ).setName( 'cameraViewMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorldInverse );\n\n\t}\n\n\treturn cameraViewMatrix;\n\n} ).once() )();\n\n/**\n * TSL object that represents the world matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nexport const cameraWorldMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraWorldMatrix;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.matrixWorld );\n\n\t\t}\n\n\t\tconst cameraWorldMatrices = uniformArray( matrices ).setGroup( renderGroup ).setName( 'cameraWorldMatrices' );\n\n\t\tcameraWorldMatrix = cameraWorldMatrices.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toConst( 'cameraWorldMatrix' );\n\n\t} else {\n\n\t\tcameraWorldMatrix = uniform( 'mat4' ).setName( 'cameraWorldMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorld );\n\n\t}\n\n\treturn cameraWorldMatrix;\n\n} ).once() )();\n\n/**\n * TSL object that represents the normal matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat3>}\n */\nexport const cameraNormalMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraNormalMatrix;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.normalMatrix );\n\n\t\t}\n\n\t\tconst cameraNormalMatrices = uniformArray( matrices ).setGroup( renderGroup ).setName( 'cameraNormalMatrices' );\n\n\t\tcameraNormalMatrix = cameraNormalMatrices.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toConst( 'cameraNormalMatrix' );\n\n\t} else {\n\n\t\tcameraNormalMatrix = uniform( 'mat3' ).setName( 'cameraNormalMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.normalMatrix );\n\n\t}\n\n\treturn cameraNormalMatrix;\n\n} ).once() )();\n\n/**\n * TSL object that represents the position in world space of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<vec3>}\n */\nexport const cameraPosition = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraPosition;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst positions = [];\n\n\t\tfor ( let i = 0, l = camera.cameras.length; i < l; i ++ ) {\n\n\t\t\tpositions.push( new Vector3() );\n\n\t\t}\n\n\t\tconst cameraPositions = uniformArray( positions ).setGroup( renderGroup ).setName( 'cameraPositions' ).onRenderUpdate( ( { camera }, self ) => {\n\n\t\t\tconst subCameras = camera.cameras;\n\t\t\tconst array = self.array;\n\n\t\t\tfor ( let i = 0, l = subCameras.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].setFromMatrixPosition( subCameras[ i ].matrixWorld );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tcameraPosition = cameraPositions.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toConst( 'cameraPosition' );\n\n\t} else {\n\n\t\tcameraPosition = uniform( new Vector3() ).setName( 'cameraPosition' ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => self.value.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t}\n\n\treturn cameraPosition;\n\n} ).once() )();\n\n\n/**\n * TSL object that represents the viewport of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<vec4>}\n */\nexport const cameraViewport = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraViewport;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst viewports = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tviewports.push( subCamera.viewport );\n\n\t\t}\n\n\t\tconst cameraViewports = uniformArray( viewports, 'vec4' ).setGroup( renderGroup ).setName( 'cameraViewports' );\n\n\t\tcameraViewport = cameraViewports.element( cameraIndex ).toConst( 'cameraViewport' );\n\n\t} else {\n\n\t\t// Fallback for single camera\n\t\tcameraViewport = vec4( 0, 0, screenSize.x, screenSize.y ).toConst( 'cameraViewport' );\n\n\t}\n\n\treturn cameraViewport;\n\n} ).once() )();\n", "import Object3DNode from './Object3DNode.js';\nimport { Fn, nodeImmutable } from '../tsl/TSLBase.js';\nimport { uniform } from '../core/UniformNode.js';\n\nimport { Matrix4 } from '../../math/Matrix4.js';\nimport { cameraViewMatrix } from './Camera.js';\nimport { Matrix3 } from '../../math/Matrix3.js';\n\n/**\n * This type of node is a specialized version of `Object3DNode`\n * with larger set of model related metrics. Unlike `Object3DNode`,\n * `ModelNode` extracts the reference to the 3D object from the\n * current node frame state.\n *\n * @augments Object3DNode\n */\nclass ModelNode extends Object3DNode {\n\n\tstatic get type() {\n\n\t\treturn 'ModelNode';\n\n\t}\n\n\t/**\n\t * Constructs a new object model node.\n\t *\n\t * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper( scope );\n\n\t}\n\n\t/**\n\t * Extracts the model reference from the frame state and then\n\t * updates the uniform value depending on the scope.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tthis.object3d = frame.object;\n\n\t\tsuper.update( frame );\n\n\t}\n\n}\n\nexport default ModelNode;\n\n/**\n * TSL object that represents the object's direction in world space.\n *\n * @tsl\n * @type {ModelNode<vec3>}\n */\nexport const modelDirection = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.DIRECTION );\n\n/**\n * TSL object that represents the object's world matrix.\n *\n * @tsl\n * @type {ModelNode<mat4>}\n */\nexport const modelWorldMatrix = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );\n\n/**\n * TSL object that represents the object's position in world space.\n *\n * @tsl\n * @type {ModelNode<vec3>}\n */\nexport const modelPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.POSITION );\n\n/**\n * TSL object that represents the object's scale in world space.\n *\n * @tsl\n * @type {ModelNode<vec3>}\n */\nexport const modelScale = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.SCALE );\n\n/**\n * TSL object that represents the object's position in view/camera space.\n *\n * @tsl\n * @type {ModelNode<vec3>}\n */\nexport const modelViewPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );\n\n/**\n * TSL object that represents the object's radius.\n *\n * @tsl\n * @type {ModelNode<float>}\n */\nexport const modelRadius = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.RADIUS );\n\n/**\n * TSL object that represents the object's normal matrix.\n *\n * @tsl\n * @type {UniformNode<mat3>}\n */\nexport const modelNormalMatrix = /*@__PURE__*/ uniform( new Matrix3() ).onObjectUpdate( ( { object }, self ) => self.value.getNormalMatrix( object.matrixWorld ) );\n\n/**\n * TSL object that represents the object's inverse world matrix.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nexport const modelWorldMatrixInverse = /*@__PURE__*/ uniform( new Matrix4() ).onObjectUpdate( ( { object }, self ) => self.value.copy( object.matrixWorld ).invert() );\n\n/**\n * TSL object that represents the object's model view matrix.\n *\n * @tsl\n * @type {Node<mat4>}\n */\nexport const modelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.renderer.overrideNodes.modelViewMatrix || mediumpModelViewMatrix;\n\n} ).once() )().toVar( 'modelViewMatrix' );\n\n// GPU Precision\n\n/**\n * TSL object that represents the object's model view in `mediump` precision.\n *\n * @tsl\n * @type {Node<mat4>}\n */\nexport const mediumpModelViewMatrix = /*@__PURE__*/ cameraViewMatrix.mul( modelWorldMatrix );\n\n// CPU Precision\n\n/**\n * TSL object that represents the object's model view in `highp` precision\n * which is achieved by computing the matrix in JS and not in the shader.\n *\n * @tsl\n * @type {Node<mat4>}\n */\nexport const highpModelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tbuilder.context.isHighPrecisionModelViewMatrix = true;\n\n\treturn uniform( 'mat4' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\treturn object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t} );\n\n} ).once() )().toVar( 'highpModelViewMatrix' );\n\n/**\n * TSL object that represents the object's model normal view in `highp` precision\n * which is achieved by computing the matrix in JS and not in the shader.\n *\n * @tsl\n * @type {Node<mat3>}\n */\nexport const highpModelNormalViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tconst isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;\n\n\treturn uniform( 'mat3' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\tif ( isHighPrecisionModelViewMatrix !== true ) {\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\t}\n\n\t\treturn object.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t} );\n\n} ).once() )().toVar( 'highpModelNormalViewMatrix' );\n", "import Node from './Node.js';\nimport { nodeObject, varying } from '../tsl/TSLBase.js';\n\n/**\n * Base class for representing shader attributes as nodes.\n *\n * @augments Node\n */\nclass AttributeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'AttributeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new attribute node.\n\t *\n\t * @param {string} attributeName - The name of the attribute.\n\t * @param {?string} nodeType - The node type.\n\t */\n\tconstructor( attributeName, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * `AttributeNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tthis._attributeName = attributeName;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getAttributeName( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tlet nodeType = this.nodeType;\n\n\t\tif ( nodeType === null ) {\n\n\t\t\tconst attributeName = this.getAttributeName( builder );\n\n\t\t\tif ( builder.hasGeometryAttribute( attributeName ) ) {\n\n\t\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\n\t\t\t\tnodeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\t} else {\n\n\t\t\t\tnodeType = 'float';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\t/**\n\t * Sets the attribute name to the given value. The method can be\n\t * overwritten in derived classes if the final name must be computed\n\t * analytically.\n\t *\n\t * @param {string} attributeName - The name of the attribute.\n\t * @return {AttributeNode} A reference to this node.\n\t */\n\tsetAttributeName( attributeName ) {\n\n\t\tthis._attributeName = attributeName;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the attribute name of this node. The method can be\n\t * overwritten in derived classes if the final name must be computed\n\t * analytically.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The attribute name.\n\t */\n\tgetAttributeName( /*builder*/ ) {\n\n\t\treturn this._attributeName;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\t\t\tconst attributeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\tconst nodeAttribute = builder.getAttribute( attributeName, attributeType );\n\n\t\t\tif ( builder.shaderStage === 'vertex' ) {\n\n\t\t\t\treturn builder.format( nodeAttribute.name, attributeType, nodeType );\n\n\t\t\t} else {\n\n\t\t\t\tconst nodeVarying = varying( this );\n\n\t\t\t\treturn nodeVarying.build( builder, nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( `AttributeNode: Vertex attribute \"${ attributeName }\" not found on geometry.` );\n\n\t\t\treturn builder.generateConst( nodeType );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.global = this.global;\n\t\tdata._attributeName = this._attributeName;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.global = data.global;\n\t\tthis._attributeName = data._attributeName;\n\n\t}\n\n}\n\nexport default AttributeNode;\n\n/**\n * TSL function for creating an attribute node.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the attribute.\n * @param {?string} [nodeType=null] - The node type.\n * @returns {AttributeNode}\n */\nexport const attribute = ( name, nodeType = null ) => nodeObject( new AttributeNode( name, nodeType ) );\n", "import { attribute } from '../core/AttributeNode.js';\nimport { Fn } from '../tsl/TSLCore.js';\nimport { modelWorldMatrix } from './ModelNode.js';\n\n/**\n * TSL object that represents the position attribute of the current rendered object.\n *\n * @tsl\n * @type {AttributeNode<vec3>}\n */\nexport const positionGeometry = /*@__PURE__*/ attribute( 'position', 'vec3' );\n\n/**\n * TSL object that represents the vertex position in local space of the current rendered object.\n *\n * @tsl\n * @type {AttributeNode<vec3>}\n */\nexport const positionLocal = /*@__PURE__*/ positionGeometry.toVarying( 'positionLocal' );\n\n/**\n * TSL object that represents the previous vertex position in local space of the current rendered object.\n * Used in context of {@link VelocityNode} for rendering motion vectors.\n *\n * @tsl\n * @type {AttributeNode<vec3>}\n */\nexport const positionPrevious = /*@__PURE__*/ positionGeometry.toVarying( 'positionPrevious' );\n\n/**\n * TSL object that represents the vertex position in world space of the current rendered object.\n *\n * @tsl\n * @type {VaryingNode<vec3>}\n */\nexport const positionWorld = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn modelWorldMatrix.mul( positionLocal ).xyz.toVarying( builder.getSubBuildProperty( 'v_positionWorld' ) );\n\n}, 'vec3' ).once( [ 'POSITION' ] ) )();\n\n/**\n * TSL object that represents the position world direction of the current rendered object.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nexport const positionWorldDirection = /*@__PURE__*/ ( Fn( () => {\n\n\tconst vertexPWD = positionLocal.transformDirection( modelWorldMatrix ).toVarying( 'v_positionWorldDirection' );\n\n\treturn vertexPWD.normalize().toVar( 'positionWorldDirection' );\n\n}, 'vec3' ).once( [ 'POSITION' ] ) )();\n\n/**\n * TSL object that represents the vertex position in view space of the current rendered object.\n *\n * @tsl\n * @type {VaryingNode<vec3>}\n */\nexport const positionView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.context.setupPositionView().toVarying( 'v_positionView' );\n\n}, 'vec3' ).once( [ 'POSITION' ] ) )();\n\n/**\n * TSL object that represents the position view direction of the current rendered object.\n *\n * @tsl\n * @type {VaryingNode<vec3>}\n */\nexport const positionViewDirection = /*@__PURE__*/ positionView.negate().toVarying( 'v_positionViewDirection' ).normalize().toVar( 'positionViewDirection' );\n", "import TempNode from '../core/TempNode.js';\nimport { modelViewMatrix } from './ModelNode.js';\nimport { positionLocal, positionPrevious } from './Position.js';\nimport { nodeImmutable } from '../tsl/TSLBase.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { sub } from '../math/OperatorNode.js';\nimport { cameraProjectionMatrix } from './Camera.js';\nimport { renderGroup } from '../core/UniformGroupNode.js';\n\nconst _objectData = new WeakMap();\n\n/**\n * A node for representing motion or velocity vectors. Foundation\n * for advanced post processing effects like motion blur or TRAA.\n *\n * The node keeps track of the model, view and projection matrices\n * of the previous frame and uses them to compute offsets in NDC space.\n * These offsets represent the final velocity.\n *\n * @augments TempNode\n */\nclass VelocityNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'VelocityNode';\n\n\t}\n\n\t/**\n\t * Constructs a new vertex color node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t\t/**\n\t\t * The current projection matrix.\n\t\t *\n\t\t * @type {?Matrix4}\n\t\t * @default null\n\t\t */\n\t\tthis.projectionMatrix = null;\n\n\t\t/**\n\t\t * Overwritten since velocity nodes are updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Overwritten since velocity nodes save data after the update.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateAfterType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Uniform node representing the previous model matrix in world space.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousModelWorldMatrix = uniform( new Matrix4() );\n\n\t\t/**\n\t\t * Uniform node representing the previous projection matrix.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousProjectionMatrix = uniform( new Matrix4() ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the previous view matrix.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousCameraViewMatrix = uniform( new Matrix4() );\n\n\t}\n\n\t/**\n\t * Sets the given projection matrix.\n\t *\n\t * @param {Matrix4} projectionMatrix - The projection matrix to set.\n\t */\n\tsetProjectionMatrix( projectionMatrix ) {\n\n\t\tthis.projectionMatrix = projectionMatrix;\n\n\t}\n\n\t/**\n\t * Updates velocity specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( { frameId, camera, object } ) {\n\n\t\tconst previousModelMatrix = getPreviousMatrix( object );\n\n\t\tthis.previousModelWorldMatrix.value.copy( previousModelMatrix );\n\n\t\t//\n\n\t\tconst cameraData = getData( camera );\n\n\t\tif ( cameraData.frameId !== frameId ) {\n\n\t\t\tcameraData.frameId = frameId;\n\n\t\t\tif ( cameraData.previousProjectionMatrix === undefined ) {\n\n\t\t\t\tcameraData.previousProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.previousCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.currentProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.currentCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\t} else {\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( cameraData.currentProjectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( cameraData.currentCameraViewMatrix );\n\n\t\t\t}\n\n\t\t\tcameraData.currentProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\tcameraData.currentCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\tthis.previousProjectionMatrix.value.copy( cameraData.previousProjectionMatrix );\n\t\t\tthis.previousCameraViewMatrix.value.copy( cameraData.previousCameraViewMatrix );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Overwritten to updated velocity specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateAfter( { object } ) {\n\n\t\tgetPreviousMatrix( object ).copy( object.matrixWorld );\n\n\t}\n\n\t/**\n\t * Implements the velocity computation based on the previous and current vertex data.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {Node<vec2>} The motion vector.\n\t */\n\tsetup( /*builder*/ ) {\n\n\t\tconst projectionMatrix = ( this.projectionMatrix === null ) ? cameraProjectionMatrix : uniform( this.projectionMatrix );\n\n\t\tconst previousModelViewMatrix = this.previousCameraViewMatrix.mul( this.previousModelWorldMatrix );\n\n\t\tconst clipPositionCurrent = projectionMatrix.mul( modelViewMatrix ).mul( positionLocal );\n\t\tconst clipPositionPrevious = this.previousProjectionMatrix.mul( previousModelViewMatrix ).mul( positionPrevious );\n\n\t\tconst ndcPositionCurrent = clipPositionCurrent.xy.div( clipPositionCurrent.w );\n\t\tconst ndcPositionPrevious = clipPositionPrevious.xy.div( clipPositionPrevious.w );\n\n\t\tconst velocity = sub( ndcPositionCurrent, ndcPositionPrevious );\n\n\t\treturn velocity;\n\n\t}\n\n}\n\nfunction getData( object ) {\n\n\tlet objectData = _objectData.get( object );\n\n\tif ( objectData === undefined ) {\n\n\t\tobjectData = {};\n\t\t_objectData.set( object, objectData );\n\n\t}\n\n\treturn objectData;\n\n}\n\nfunction getPreviousMatrix( object, index = 0 ) {\n\n\tconst objectData = getData( object );\n\n\tlet matrix = objectData[ index ];\n\n\tif ( matrix === undefined ) {\n\n\t\tobjectData[ index ] = matrix = new Matrix4();\n\t\tobjectData[ index ].copy( object.matrixWorld );\n\n\t}\n\n\treturn matrix;\n\n}\n\nexport default VelocityNode;\n\n/**\n * TSL object that represents the velocity of a render pass.\n *\n * @tsl\n * @type {VelocityNode}\n */\nexport const velocity = /*@__PURE__*/ nodeImmutable( VelocityNode );\n"],
  "mappings": "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",
  "names": ["array", "ColorManagement", "color", "color", "max", "min", "array", "attribute", "array", "min", "max", "length", "array", "attribute", "array", "min", "max", "length", "array", "attribute", "min", "max", "length", "array", "attribute", "property", "array", "array", "hash", "output", "nodeData", "property", "cache", "data", "output", "output", "output", "length", "output", "length", "length", "output", "property", "property", "element", "array", "subBuild", "output", "bool", "uint", "int", "float", "output", "hash", "varying", "output", "output", "output", "normalize", "output", "normalize", "clamp", "normalize", "clamp", "output", "ifSnippet", "output", "varying", "color", "property", "property", "toneMapping", "color", "_vector", "_vector2", "array", "attribute", "_vector", "array", "array", "array", "bufferAttribute", "output", "array", "output", "cache", "output", "toneMapping", "context", "color", "toneMapping", "min", "max", "array", "_vector", "attribute", "_v1", "_box", "_v1", "_v2", "lengthSq", "length", "array", "i", "length", "output", "cameraProjectionMatrix", "camera", "cameraProjectionMatrixInverse", "cameraViewMatrix", "cameraWorldMatrix", "cameraNormalMatrix", "cameraPosition", "array", "cameraViewport", "attribute", "velocity"]
}
